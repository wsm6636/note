---
created: 2023-09-11T19:16
updated: 2024-02-13T22:41
tags:
  - 笔记
  - 笔记/文献笔记
---

# Efficient Run-Time Environments for System-Level LET Programming

| Title                 | Efficient Run-Time Environments for System-Level LET Programming        |
| --------------------- | ----------------------------------------------------------------------- |
| Journal or Conference | 2021 Design, Automation & Test in Europe Conference & Exhibition (DATE) |
| Authors               | Kai-Bjorn Gemlau; Leonie Kohler; Rolf Ernst                             |
| Pub. date             | 2021-2-1                                                                |
| DOI                   | [10/gsfbqr](https://doi.org/10/gsfbqr)                                  |
| Level                 |                                                                         |

# 用于系统级LET编程的高效运行时环境

## 摘要

大型工业和汽车软件系统的需求不断增长，已经开始从单一且紧密集成的运行时环境(RTE)向在具有不同物理体系结构的更少域计算机上实现的虚拟平台转移。这一趋势催生了新的编程范例，以实现对在干扰和变化中可预测和健壮的软件系统的规范、实现和监督。其中一个范例，逻辑执行时间(LET)，现在是汽车软件标准AUTOSAR的一部分。虽然最初应用于单共享内存多核处理器，但系统级LET(SL LET)将这种方法扩展到虚拟和分布式平台，为未来工业系统中的CP提供了强大的范例。这一贡献解释并展示了技术和技术教育面临的挑战，以及提高其效率的机会，特别是通信堆栈。

## 引言

即将推出的用于工业和汽车应用的网络物理系统(CPS)架构是异类的，将高性能多核架构与图形或机器学习等加速器相结合，并为以数据为中心的应用程序提供更大的存储系统。包括摄像头和激光雷达在内的高分辨率传感器要求高数据速率，这给实时通信带来了压力。CPS编程越来越接近高性能计算机编程，不同之处主要在于它们之间相互依赖的大型应用功能网络、实时性和安全性要求。由此产生的系统复杂性是对运行时环境(RTE)、软件体系结构和网络堆栈的重大挑战。

汽车行业最近引入了逻辑执行时间(LET)范例，以便在日益复杂的并行体系结构的计时行为中掌握同步[1]、[2]。它有助于通过无锁通信有效地对多核架构进行编程。还有更多的优点，例如减少了因果关系链中的抖动。然而，将LET应用于较大的系统受到其对紧密同步和隐含的狭窄截止日期的要求的限制。已提议将LET扩展到系统级别，以克服这些限制[3]、[4]。该扩展的一个核心概念是系统级逻辑执行时间(SL Let)，它是桥接本地Let域的互连任务。作为这一概念的一部分，互连任务监控数据生命周期并支持数据同步。

## 4 软件体系结构

正如所讨论的，三个主要方面影响最先进的RTE的计时行为：(1)由于服务、中间件和基础软件之间的资源共享而引起的干扰。(2)RTE中由于特征复杂性而导致的有限的时序确定性。(3)硬件性能和可预测性之间的权衡。

在这一部分中，我们提出了一种新颖的RTE通信体系结构，通过严格分离关键和非关键特性以及利用SL let的特性来解决这些问题，以实现关键中间件流量的确定性和低延迟。

SL let启用确定性数据版本管理，因为历史缓存中的每个样本都具有预定义的数据年龄。SL LET范例可以通过使用每个ECU上的任何本地LET调度器来实现，例如，[14]中的==基于表的调度器==，以及一些具有有界误差的全局同步(例如，精确时间协议(PTP))。对历史缓存的访问是通过利用序列号执行的，将每个访问映射到正确的历史缓存，这消除了比较时间戳的需要[3]。

图4显示了通信RTE的体系结构，将过滤器堆栈与类似DDS的中间件结合在一起，其中通信由SL let指定。在下文中，我们将概述图中所示的相关部分。

### A.水平分隔

除了任何软件堆栈都知道的垂直层之外，我们还应用了额外的水平分隔。筛选器堆栈将每个包标识为时间关键或非关键，而不是减少功能。这允许将功能丰富的元素(如网络堆栈或中间件)划分为时间关键部分和非关键部分，这是一种水平分离。作为SL LET的直接结果，实现SL LET互连任务所需的所有特征都可以被识别为时间关键。这包括网络堆栈的UDP/IP部分以及中间件中的串行化、数据传输和监控。非关键部件可能很复杂，并对正确性提出要求，但没有严格的时间要求。这样，它们就可以在后台优先级上运行。例如，网络堆栈中的有状态协议，如TCP或DHCP，以及中间件功能，如服务表示和发现。

作为第二步，这一分离还促进了在现代MPSoC架构中使用配套内核，如Xilinx UltraScale+、瑞萨R-Car H3或恩智浦S32。虽然高性能ARM Cortex-A内核和图形加速器非常适合服务实施(例如图像处理)，但这些不同的架构提供了轻量级但可预测的Cortex-R或Cortex-M内核，足以以最小的延迟处理关键流量。带有SL LET的规范进一步支持在两个核心之间的共享内存中实现DDS历史缓存的无锁实现。

### B.有效处理优先事项

由于CPS中的大量非LET流量，[5]中建议的过滤器堆栈必须在关键流量和非关键流量之间提供一种形式的仲裁。与仅处理一个FIFO队列的未经修改的LWIP堆栈不同，过滤器堆栈在所有层提供优先级仲裁。它支持例如从IEEE 802.1Q[15]获知的多达8个优先级。此外，通过轮询实现与经典堆栈的接口，定期从经典堆栈获取数据，可以减少实时内核上的中断负载。除了提供传输时间的确定性之外，它也是完全可配置的，并且可以在运行时重新配置，例如用于网络管理。

### C.使用分散-聚集DMA的零拷贝操作

高效传输大型数据对象的一个中心方面是内存组织。数据样本的片段必须用中间件报头以及网络报头来补充以形成网络分组。由于SL let的无锁行为，确保历史缓存中的样本在传输过程中是不变的。因此，可以利用网络驱动器硬件中的分散-聚集直接存储器访问(DMA)。这与安全考虑因素并不冲突，因为历史缓冲区的内存由生产服务拥有，并且每个较低层已经具有更高的特权。因此，可以避免中间件和网络堆栈中的复制操作，从而大大减少了计时和缓冲内存的开销。

### D.输入过滤

在接收端，SL LET流量必须与非关键流量分开。在[5]中建议的过滤器堆栈能够通过关注中间件所使用的端口的UDP包来实现这一点。由于过滤器堆栈中的复杂性降低，因此可以在最小延迟的情况下进行这种区分。经典堆栈负责提供可存储非关键数据包的缓冲区。由于用于DMA的内存包含关键和非关键包，因此它由过滤器堆栈拥有，而非关键数据必须复制到传统堆栈拥有的缓冲区中。这可以作为过滤器堆栈中的后台任务来实现。根据硬件功能的不同，网络硬件已经可以完成区分，对每种流量类型使用不同的DMA队列。这将进一步提高过滤器堆栈的性能。

### E.改进的Socket-API

接收路径不能直接使用零复制方法，因为必须处理中间件报头来识别片段的目标存储器。正常的UDP套接字被认为是面向数据报的，如果没有立即读取剩余的数据报，则丢弃该数据报。这导致了重要的复制操作，因为中间件必须读取内部缓冲器中的整个分组，处理中间件头部，然后将片段从缓冲器复制到相应的历史高速缓存。情况变得更糟，因为网络分组中的片段可能不具有与历史高速缓存中的目标存储器相同的存储器对齐，从而禁止有效的复制操作。

由于中间件实际上是面向流的应用程序(它知道预期将接收什么)，因此我们在这里建议对套接字API进行简单修改，允许部分从UDP套接字读取。这使得中间件能够在两个步骤中接收网络分组。第一个API调用仅接收用于标识目标内存的小中间件标头。第二次调用可以直接指向历史缓存中的内存，从而避免了额外的复制操作。





***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考



---
标签
#端到端/通信方式/LET 

链接
Referred in [LET.md](E:\笔记\LET\LET.md)

[LET](LET/LET.md)



