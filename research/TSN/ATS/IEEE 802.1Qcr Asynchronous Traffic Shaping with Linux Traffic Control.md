---
created: 2023-10-18T11:25
updated: 2024-03-26T23:33
tags:
  - 笔记
  - 笔记/文献笔记
---

# IEEE 802.1Qcr Asynchronous Traffic Shaping with Linux Traffic Control
# 具有 Linux 流量控制的 IEEE 802.1Qcr 异步流量整形

| Title                 | Asynchonous Traffic Shaping with Linux traffic control                |
| --------------------- | --------------------------------------------------------------------- |
| Journal or Conference |                                                                       |
| Authors               | Christopher Pfefferle; Chair Of Network Architectures                 |
| Pub. date             | 2021                                                                  |
| DOI                   | [10.2313/NET-2022-01-1\_03](https://doi.org/10.2313/NET-2022-01-1_03) |
| Level                 |                                                                       |

# 摘要
IEEE 802.1 工作组引入的广泛 TSN 标准提供低延迟调度和整形，并保证数据包传输。直到最近，它们还依赖于所有网络节点之间的同步时钟。然而，新推出的 ATS 标准消除了对具有实时要求的软件的这种依赖，并且可以将 TSN 引入更广泛的社区。本文描述了使用Linux TC工具进行流量整形和调度来实现ATS标准的要求。虽然目前不可能使用 TC 命令实现 LRQ 队列或 Paternoster 调度程序，但将提出使用 TBE 队列的 UBS 算法模型。

## 1引言
网络标准不断进步，彻底改变我们的日常生活。演示是在网上进行的，参与者分散在全球各地，甚至办公室的演示系统也会通过局域网将幻灯片从演示者发送到显示器。在这些情况下，轻微的延迟不会刺激扬声器，但在处理精密机械时，仅几毫秒的延迟就可能损坏脆弱的组件。对于这些用例，IEEE 802.1 工作组创建了时间敏感网络 (TSN) 标准，以提供可实现精确通信的通信协议和功能。
一个主要贡献是在网络中的参与设备之间引入同步，这是由 IEEE 802.1BA 音频视频桥接 (AVB) 标准引入的，允许精确的流量调度和有保证的数据包传输 [1]。然而，<span style="color:black;background:#d59e83 !important;">时间同步机制增加了网络设置和维护的复杂性。 IEEE 802.1Qcr 异步流量整形 (ATS) 标准旨在通过撤销同步并允许每个网络节点按自己的时间发送流量来绕过同步的复杂性 [2]。</span> 尽管如此，它仍然旨在实现确定性和低传输延迟。
<span style="color:black;background:#fff88f !important;">为了在 Linux 机器上调整和调度流量，需要一个程序来干预数据包从创建到网络接口的路径。</span>随着ATS放宽了对TSN和TC的要求，并提供了必要的工具，日常使用的软件能够建立实时需求，并进一步促进互联网不断增长的影响。
本文概述了 ATS 和 Linux TC，提出了使用该工具实现部分标准的可能模型，并指出了其当前的局限性。其结构如下：第 2 节将简要介绍相关工作的历史，第 3 节描述 ATS 的实现细节，并选择性地概述 TC 的可能性。第 4 节将详细介绍如何利用 TC 来实现 ATS 的要求，第 5 节将总结这项工作并建议后续步骤。
## 2.相关工作
本节第一部分将简要概述 TSN 的发展以及 ATS 标准的背景及其最新发展。第二部分将介绍Linux TC命令及其在Linux机器上的网络方面的贡献，以及它的相关性。
### 2.1异步流量整形
网络流量的异步性长期以来一直被确立为共享网络的标准，并且是连接数百万节点的互联网的骨干。里戈里奥等人。早在 1991 年就提出了对异步传输模式 (ATM) 的整形，提供对给定系统的带宽和流量的控制 [4]。
2011 年，AVB 的 IEEE 802.1BA 标准获得批准，提出了至今仍然适用的 TSN 功能 [1]。它引入了网络设备之间的时间同步和流量整形，以最大限度地减少具有实时约束的分布式系统的延迟和抖动。
在作为 IEEE 标准推出之前，Specht 和 Samii 在 2016 年在 [5](Urgency-Based%20Scheduler%20for%20Time-Sensitive%20Switched%20Ethernet%20Networks.md) 中引入了基于紧急度的调度程序 (UBS)，并提出了两种算法：长度速率商 (LRQ) 和令牌桶仿真 (TBE)。它们都基于速率控制服务规则（RCSD），因此可以通过分离调度和整形组件来保证确定性和统计性能[6]。
一年后，UBS 和当时新推出的基于循环排队和转发 (CQF) [7] 的 Paternoster 调度程序在 IEEE P802.1Qcr ATS 修正案中被 IEEE TSN 工作组批准为官方标准。周等人。对 ATS 进行了详细的了解，并在各种模拟环境中进行了性能评估[8]。
由于它最近才出版，所以纳入它的作品还不多； Specht 和 Samii 在 [9] 中以及 Zhou 等人给出了性能评估。在[10]和Mohammadpour等人中。在[11]中提供了计算出的延迟和积压的最坏情况界限。Le Boudec 在 [12] 和 Grigorjew 等人中分析了 UBS 的更通用方法。在[13]中提出增加抖动控制的建议。新引入的标准也考虑了 ATS，IEEE P802.1Qdd 资源分配协议标准纳入了对 ATS 的支持[14]。
Fang 等人发布了 ATS 的最新绩效评估。 2020年11月，考虑到TSN工作组发布的各种标准，揭示了ATS的性能优势，特别是在重负载情况下[15]。

### 2.2Linux流量控制
Linux TC 工具于 2001 年随 Linux 内核版本 2.2 一起引入，位于 iproute2 软件包中。 Hubert 完成了一项有影响力的工作，将定义和应用示例结合在一份精心编排的文档中，并持续更新他的在线 HOWTO 文档 [16]。
TC 是一个用于分配和调整网络流量的强大工具，允许用户定义详细的规则。它用于统治通过能力有限的网络进行通信的多个服务，例如 Vila-Carbo 等人所做的工作。 [17]中表明其质量能够定义实时传输的规则。
根据 IEEE 802.1Q-2014 标准定义，引入基于信用的整形器 (CBS) 来实现 TC [18]，进一步展示了 TC 在 TSN 应用中的潜力，并用于在计算机上实现同步流量整形使用基于 Linux 的操作系统。

## 3架构细节
这里，将选择性地简要概述 ATS 标准和 Linux TC 的架构。特别是后者是一个强大的工具，并且有相应的大量文档。因此，重点将放在比较 TC 的可能性与第 4 节中 ATS 的要求所需的流量整形功能的子集上。

### 3.1ATS算法
本节主要基于[8]。 <span style="color:black;background:#fff88f !important;">ATS 背后的理念是网络中每个连接设备的独立时钟，消除了分布式设备必须就同步计时器达成一致时出现的问题</span>。它的主要要求是支持异步的队列。<span style="color:black;background:#40a9ff !important;">每一个都绑定了一个整形器，该整形器为队列中的帧分配合格时间，并且根据该信息，传输选择算法决定何时传输帧。</span> 
该算法可以描述为一种简单的门禁控制，考虑了合格时间。这些初始整形队列是简单的FIFO队列，它们确保高优先级流的处理不受恶意流或其他干扰流的影响。
整形队列需要遵循队列分配规则，直接引用自[8]：
<span style="color:black;background:#d3f8b6 !important;">QAR1：不允许将来自不同发射机的帧存储在相同的整形队列中。</span>
<span style="color:black;background:#d3f8b6 !important;">QAR2：来自相同发送器但不属于发送器中相同优先级的帧，不允许被存储在相同的整形队列中。</span>
<span style="color:black;background:#d3f8b6 !important;">QAR3：来自相同发送器的帧在发送器中具有相同的优先级，但在接收器中不属于相同的优先级，不允许将其存储在相同的整形队列中。</span>

> 来自相同发射器，在发射器和接收器中都具有相同的优先级，可以存储在相同的整形队列中。

在整形合格的帧之后，它们被从整形的队列中发送并存储在共享队列中。这些由下面描述的整形器之一管理，该整形器选择它们并将它们转发到网络接口，将它们释放到网络中。

ATS标准提出了两种可用于实现异步整形队列的调度算法，其中最重要的是UBS算法和Paternoster算法。

<span style="color:black;background:#ffbbff !important;">UBS方案允许使用两种类型的整形队列：LRQ和TBE，分别基于逐帧漏桶算法和基于令牌的漏桶算法[6]。</span>

LRQ通过将分组的<span style="color:black;background:#d3f8b6 !important;">合格时间计算为“先前传输的帧的大小与特定类别的预留链路速率之间的商”</span>来忽略具有稳定的传输/泄漏速率的传入流模式和形状。
> 基于逐帧漏桶算法

TBE允许一定程度的突发流量传输，同时保持平均速率，它使用“桶”中“令牌”的累积时间来计算数据包的合格时间。与 LRQ 相比，它可以在较轻的负载下更好地利用给定带宽。

调度是使用基于漏桶方法的ATS算法实现的。根据帧的合格时间、到达时间、最后一帧的大小以及允许丢弃过期帧的当前系统时钟来处理帧。因此，ATS调度器充当可用带宽的最终整形器。

Paternoster 排队和调度算法是一种循环方法。它使用四个队列，在每个 epoch 中都会经过先前、当前、下一个和最后四种状态之一，如表 1 所示。在每个 epoch 中，帧都会排队到当前队列中，如果队列已满，则帧会传递到下一个或最后一个队列或被丢弃，并且仅从当前队列中出列。纪元长度会影响延迟，并且必须在网络内保持一致。 [8]
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202310192225586.png)
### 3.2流量整形TC
本节主要基于[16]编制的信息。每个网络数据包，无论是本地程序产生的还是正在转发的，都必须经过TC架构。

主要组成部分是<span style="color:black;background:#d59e83 !important;">排队规则（qdiscs），即指定的排队算法</span>。它们可以是无类的，也可以是有类的，后者支持内部划分为同样包含可配置 qdisc 的类。因此，它们以树形结构排列，Linux 内核仅与根节点交互（网络数据包入队和出队）。 qdisc 可以对排队的数据包执行三种操作：(1) 调度，即数据包优先于其他数据包；(2) 整形，即延迟甚至丢弃数据包以满足最大流量速率要求；(3) 策略（如果用于传入流量），即丢弃数据包以满足传入流量的内部要求。

如果 qdisc 可能为了<span style="color:black;background:#fbc2eb !important;">保持恒定的传输速率而延迟数据包，则它被认为是非工作保护的。另一方面，如果数据包一可用就发送出去，则被认为是节省工作的</span>。

最后，<span style="color:black;background:#ffbbff !important;">可以为每个类别分配一个过滤器，它保存可以对数据包进行分类的条件</span>。如果过滤器与数据包匹配，它将被转发到相应类别的 qdisc。下面对本文中提到的 qdisc 进行解释：

pﬁfo_fast：默认 qdisc 是一种无类别整形器，具有三个 FIFO 队列，每个队列对应网络数据包的服务类型 (TOS) 标志定义的每个优先级。数据包从最高优先级队列开始出队。

Token Bucket Filter (TBF)：令牌桶过滤器，一种无类别整形器，支持短突发的设定最大速率。

Stochastic Fairness Queuing (SFQ)：随机公平排队，一种无类调度程序，通过流以循环方式使数据包出列，这些流主要对应于 TCP/IP 连接。

PRIO：与 pfifo_fast 类似的有类调度程序，但它支持使用过滤器和子类而不是简单的 FIFO 队列进行排队。出队以相同的方式完成，从定义的第一个 qdisc 开始。

Hierarchical Token Bucket (HTB)：分层令牌桶，一个有类整形器，允许精确限制其子 qdisc 的带宽，并可以借用未使用的资源。

Clark-Shenker-Zhang algorithm (CSZ)：三位同名研究人员在[19]中提出了一种复杂的有类调度程序，为实时应用程序提供有保证的服务以及尽力而为的队列，**通过故意不整形来减少延迟和抖动**。

Credit-Based Shaper (CBS)：基于信用的整形器，一种无类整形器，它根据设定的带宽实施IEEE 802.1Qav标准中引入的CBS算法。

Earliest TxTime First (ETF)：最早的TxTime优先，一种无类整形器，构建为支持TSN中的整形，在可配置的定时器上将数据包出队。

## 4.与 TC 一起实施 ATS
通过介绍需求和可用工具，提出了使用 UBS 方案和 TBE 队列实现 ATS 标准的可能方案。 4.2 节将解释尝试实现 LRQ 队列或 Paternoster 方案时遇到的问题。两个小节都将 ATS 算法的细节称为要求，将 TC 的功能称为实现前者的能力。有关详细描述和定义，请参阅第 3 节和相应的小节。


### 4.1 UBS/TBE的TC模型
TC方案的根qdisc不一定需要任何整形能力，整形将通过进一步的qdisc来实现。但为了包含更多的类，它需要有类。其目的是根据优先级将数据包分成队列，因此具有相同优先级的数据包由同一队列处理。这强制按照 QAR2 的要求分离不同的优先级。由于数据包的分类分配可以由过滤器控制，因此重点在于正确的出队策略。根qdisc必须遵守ATS调度算法。作为根节点的潜在候选者包括实现严格优先级的 PRIO qdisc、为高优先级数据包提供有保证的服务同时可能忽略低优先级数据包的 CSZ 算法，以及不提供严格优先级的 HTB，它通常是一个很好的竞争者并充当整形器，这可能会引入延迟和抖动。 ATS 算法一方面执行整形，这将使 HTB 成为最佳选择，但另一方面它也执行严格的优先级划分，这需要 PRIO qdisc。作为解决方案，两者都将用于考虑 ATS 算法的要求。

分配给优先级的每个类都必须实现 TBE 队列的要求。一个可行的选择是 TBF 整形器应用几乎相同的令牌/桶技术，但由于它是无类 qdisc，因此此时的应用将违反 QAR1。

实现 QAR1 和 QAR3 的唯一 qdisc 是无类 SFQ 调度程序，它允许通过会话拆分包。由于它不支持整形，因此需要单独的整形器。

本文提出的解决方案是使用只有一个子类（PRIO qdisc）的 HTB 根节点。通过此设置，如图 1 所示，可以按优先级插入 SFQ qdisc，以确保满足所有三个队列分配规则。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202310192300051.png)

### 4.2.局限性
LRQ队列不能用TC提供的qdisc来实现，因为它严重依赖于资格时间的计算及其通过该方案的传播。 ETF 是目前唯一允许计算资格时间的 qdisc。因为它是无类的，所以它本身缺乏用作根节点的要求，并且由于计算出的时间不能在进一步的调度程序中使用，因此需要一个新的 qdisc 来考虑 ATS 算法完成的调度，考虑到计时器ETF。

同样，Paternoster 也无法通过可用的工具来实现。它需要根据当前的纪元在不同的队列中入队和出队，这既不能用当前的 qdisc 也不能用过滤器来完成。
## 5 结论和未来工作
IEEE 802.1Qcr ATS 标准的推出是为了提高网络的实时功能，这些网络没有可用于每个节点的同步计时器，从而降低了要求，同时仍然为时间敏感的应用程序提供保证。本文使用 TC 工具展示了在 Linux 机器上实现该标准的可能模型，特别是带有 TBE 队列的 UBS 方案。仅使用 HTB、PRIO 和 SFQ qdisc 就可以遵守 ATS 的条件。

它进一步强调了在研究该标准的其他可能方案时出现的问题，即具有 LRQ 队列的 UBS 和 Paternoster 排队/调度算法。在满足大部分要求的情况下，TC 目前缺乏一些关键功能，例如资格时间的使用或动态更改队列的角色。然而，似乎有可能在未来的更新中添加这些功能。

下一步将实施所提出的方案，以分析其实用性和性能。尽管 TSN 标准仅适用于特定领域，但如果这种方法被证明可行，它可能会在智能家居或物联网中实现更广泛的应用。





***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考

***

标签 

链接
[ATS](ATS.md)

Referred in <a href="zotero://note/u/V5BHLJX8/?ignore=1&#x26;line=10" rel="noopener noreferrer nofollow" zhref="zotero://note/u/V5BHLJX8/?ignore=1&#x26;line=10" ztype="znotelink" class="internal-link">ATS</a>
