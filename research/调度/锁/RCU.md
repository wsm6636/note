---
created: 2023-07-08T20:33
updated: 2024-03-26T23:34
tags:
  - 笔记
  - 笔记/学习笔记
---

# RCU: Read-Copy-Update

## 基本概念

**读侧临界区** (read-side critical sections): RCU读者执行的区域，每一个临界区开始于rcu_read_lock()，结束于rcu_read_unlock()，可能包含rcu_dereference()等访问RCU保护的数据结构的函数。这些指针函数实现了依赖顺序加载的概念，称为memory_order_consume加载。
**写侧临界区**：为适应读侧临界区，写侧推迟销毁并维护多个版本的数据结构，有大量的同步开销。此外，编写者必须使用某种同步机制（例如锁定）来提供有序的更新。
**静默态**(quiescent state): 当一个线程没有运行在读侧临界区时，其就处在静默状态。持续相当长一段时间的静默状态称之为延长的静默态（extended quiescent state）。
**宽限期**（Grace period): 宽限期是指所有线程都至少A一次进入静默态的时间。宽限期前所有在读侧临界区的读者在宽限区后都会结束。不同的宽限期可能有部分或全部重叠。

> **临界区**
>
> 指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：semaphore。只能被单一线程访问的设备，例如：打印机。

在PREEMPT_RT中，普通的自旋锁（spinlock_t and rwlock_t）是抢占式的，RCU读取侧临界区（(rcu_read_lock() 和rcu_read_unlock()）也是一样的。

> “实时RCU”列与经典RCU有相同的API，区别仅在于RCU读侧临界部分在获取自旋锁时可被抢占和阻塞。

## 概述

RCU背后的基本理念是将更新分为==“移除”==和==“回收”==阶段。

**删除阶段**删除对数据结构中数据项的引用（可能通过将其替换为对这些数据项的新版本的引用），并且可以与读取器同时运行。与读卡器同时运行删除阶段是安全的原因是，**现代CPU的语义保证读者可以看到数据结构的旧版本或新版本，而不是部分更新的引用**。

**回收阶段**进行回收（例如，释放）在移除阶段从数据结构中移除的数据项的工作。由于回收数据项可能会中断同时引用这些数据项的任何读取器，因此**回收阶段必须在读取器不再持有对那些数据项的引用之前才能开始**。

将更新分为删除和回收阶段**允许更新者立即执行删除阶段，并将回收阶段推迟到删除阶段中所有活动的读卡器都完成为止**，方法是阻塞直到它们完成，或者注册在它们完成后调用的回调。只需要考虑在删除阶段处于活动状态的读卡器，因为在删除阶段之后启动的任何读卡器都将无法获得对已删除数据项的引用，因此不会被回收阶段中断。

> 移除阶段和回收阶段。两个阶段通过宽限期隔开。更新者在移除元素后，通过synchronize_rcu()原语，初始化一个宽限期，并等待宽限期结束后，回收移除的元素。 1. 移除阶段：RCU更新通过rcu_assign_pointer()等函数移除或插入元素。现代CPU的指针操作都是原子的， rcu_assign_pointer()原语在大多数系统上编译为一个简单的指针赋值操作。移除的元素仅可被移除阶段（以灰色显示）前的读者访问。 2. 回收阶段：一个宽限期后，宽限期开始前的原有读者都完成读操作，因此，此阶段可安全释放由删除阶段删除的元素。

#### 典型的RCU更新序列如下所示：

删除指向数据结构的指针，以便后续的读取器无法获得对该结构的引用。

等待所有以前的读卡器完成其RCU读取端关键部分。

此时，不能有任何读者持有对数据结构的引用，因此现在可以安全地回收数据结构（例如，kfree（）d）。

> 典型的RCU更新时序如下:
>
> - **复制**：将需要更新的数据复制到新内存地址；
> - **更新**：更新复制数据，这时候操作的新的内存地址；
> - **替换**：使用新内存地址指针替换旧数据内存地址指针，此后旧数据将无法被后续读者访问；
> - **等待**，所有访问旧数据的读者进入静默期，即访问旧数据完成；
> - **回收**：当没有任何持有旧数据结构引用的读者后，安全地回收旧数据内存。

RCU 首先将需要修改的内容复制出一份副本，然后在副本上进行修改操作。在写者进行修改操作的过程中，旧数据没有做任何更新，不会产生读写竞争，因此依然可以被读者并行访问。当写者修改完成后，写者直接将新数据内存地址替换掉旧数据的内存地址，由于内存地址替换操作是原子的，因此可以保证读写不会产生冲突。内存地址替换后，原有读者访问旧数据，新的读者将访问新数据。当原有读者访问完旧数据，进入静默期后，旧数据将被写者删除回收。当然，通常写者只进行更新、删除指针操作，旧数据内存的回收由另一个线程完成。

## RCU 核心API

### rcu_read_lock()

读卡器用于通知回收，读卡器正在进入RCU读侧临界段。在RCU读端关键部分时进行阻止是非法的，尽管**使用CONFIG_PREEMPT_RCU构建的内核可以抢占RCU读侧关键部分**。在RCU读端关键段期间访问的任何RCU保护的数据结构都保证在该关键段的整个持续时间内保持未声明。参考计数可与RCU一起使用，以维护数据结构的长期参考。

### rcu_read_unlock()

读卡器用于通知回收，读卡器正在退出RCU读侧临界段。请注意，RCU读取端关键部分可能嵌套和/或重叠。

### synchronize_rcu() / call_rcu()

### rcu_assign_pointer() 

### rcu_dereference()

# LWN.net

## 介绍

RCU 同步机制

RCU通过允许读取与更新同时发生来实现可扩展性改进。

RCU支持单个更新器和多个读写器之间的并发，前者确保并发线程之间的互斥，后者允许并发读取，但不允许更新。

RCU通过维护多个版本的对象并确保在所有预先存在的读取端关键部分完成之前不会释放这些对象来确保读取是一致的。RCU定义并使用高效且可扩展的机制来发布和读取对象的新版本，以及延迟旧版本的收集。

**RCU由三个基本机制组成**，第一个用于插入，第二个用于删除，第三个用于允许读者同时插入和删除。

1. 发布订阅机制（用于插入）

   将rcu_reference（）原语视为订阅指定指针的给定值，从而保证后续的解引用操作将看到在相应的发布（rcu_assign_pointer（））操作之前发生的任何初始化。rcu_read_lock（）和rcu_read_unlock（）调用是绝对必要的：它们定义rcu读端关键部分的范围。它们的目的将在下一节中解释，但是，它们从不旋转或阻塞，也不会阻止list_add_cur（）并发执行。事实上，在非CONFIG_PREEMPT内核中，它们绝对不会生成代码。

2. 等待现有RCU读卡器完成（删除）

3. 维护最近更新对象的多个版本（供读者使用）