---
created: 2023-07-21T14:09
updated: 2024-02-13T22:42
tags:
  - 笔记
  - 笔记/文献笔记
---

# LAG-based Analysis for Preemptive Global Scheduling with Dynamic Cache Allocation

| Title                 | LAG-based Analysis for Preemptive Global Scheduling with Dynamic Cache Allocation |
| --------------------- | --------------------------------------------------------------------------------- |
| Journal or Conference | RTCSA                                                                             |
| Authors               | Yuhan Lin; Jinghao Sun; Qingxu Deng; Meilin Han; Zhiwei Feng; Shumo Wang          |
| Pub. date             |                                                                                   |
| DOI                   |                                                                                   |
| Level                 |                                                                                   |

# 基于LAG的动态缓存分配抢占式全局调度分析

## 摘要

近年来，现代多核处理器技术的成熟及其在关键工业领域的日益采用给实时系统带来了巨大的挑战，这主要是由于对<span style="background:#FFFFBB !important;">共享高速缓存资源的争夺以及由此带来的不确定性</span>。为了解决这一问题，当代处理器使用高速缓存分区技术，通过隔离处理器核心之间的高速缓存访问来增强时间可预测性。然而，由于<span style="background:#FFFFBB !important;">缓存分区数量不足，这种隔离技术可能会导致实时任务错过最后期限。</span>因此，本文研究了<span style="background:#BBFFBB !important;">支持动态缓存分配的抢占式全局最早截止期优先(EDF)实时调度算法的可调度性</span>。针对这些算法，我们提出了一种新颖的基于LAG的可调度性分析方法，并提出了一种基于利用率的可调度性条件，在提高分析精度的同时降低了分析时间复杂度。最后，通过随机生成任务的仿真实验验证了所提出的可调度性判定方法的性能和效率。

## 1 引言

在实时嵌入式系统领域，现代多核处理器的应用日益广泛。这些多核处理器通常采用共享的末级缓存来提高缓存命中率并加快内存访问。尽管共享缓存有助于提供卓越的平均性能和效率，但它对确保实时和可预测的系统行为构成了重大挑战。由于各个处理器内核可以同时访问共享内存，因此当不同内核访问的内存映射到同一缓存行时，可能会发生缓存争用。因此，高速缓存中的任务可能会被在其他核上执行的任务逐出，从而导致高速缓存未命中和显著延迟。在核间缓存争用情况下，考虑并发任务的缓存行为(命中或未命中)会产生复杂的相互依赖关系，使得很难准确预测延迟的发生、频率和持续时间[1]。忽略缓存争用的影响会破坏系统的时间确定性和可预测性，对于具有严格实时要求的域，这可能会导致灾难性的后果。

缓存分区是一种广泛使用的技术，用于有效缓解多核处理器中的缓存争用，如页面着色[2]、LBM[3]和CAT[4]。这种方法将共享缓存划分为多个缓存分区，并将处理器核心映射到不同的分区。因此，在不同核上并行执行的任务不能逐出彼此的高速缓存内容，从而避免了在多核处理器上同时运行的任务的高速缓存争用。这减少了干扰引起的开销，同时增强了系统行为确定性。现有的研究大多采用静态缓存分区策略，将缓存分区和任务离线分配给特定的处理器核，并在运行时维护这些分配[3]、[5]。虽然这种方法极大地简化了分析，但它可能会导致严重的资源利用不足，因为当单个核过载时，其他核可能会保持空闲状态。

研究人员还提出了支持动态缓存分区分配的全局调度策略。这些策略允许在系统运行期间根据任务要求将共享高速缓存动态分配给各个处理器核心，同时还允许任务跨核心迁移以充分利用系统资源。对于这种全局调度策略，文献[3]、[6]采用了基于“问题窗”的分析方法来推导可调度性条件。基于窗口的分析方法是实时调度领域中广泛使用的一种方法，它根据任务特征划分特定的时间窗口，并分析该窗口内的最大工作量，最终推导出可调度性判断条件。由于动态缓存分区分配策略规定，只有当可用缓存空间至少等于相应任务所需的缓存时，才能调度已释放的作业，因此可能会出现缓存不足导致的任务阻塞。这种情况可能会<span style="background:#FFFFBB !important;">导致从基于窗口的分析方法得出的过度宽松的可调度性条件，从而引入相当多和不必要的悲观情绪</span>[7]。

<span style="background:#bbffff !important;">基于LAG的分析方法的基本原理包括比较由目标调度算法分配给任务的处理器时间和由虚拟理想调度器分配的处理器时间，其中LAG表示两者之间的处理器时间分配的差异</span>。由<span style="background:#bbffff !important;">于实际调度算法不能为任务分配比理想调度器更多的处理器时间，因此可以通过矛盾证明来推导可调度性条件</span>。这种方法传统上被用来推导软实时任务的延迟界。最近的研究发现，它在分析硬实时系统的可调度性条件方面也取得了很好的结果，特别是对于执行条件更复杂的实时任务，如自挂起任务[8]、群组任务[9]、[10]和DAG任务[7]、[11]。通过检验，我们发现这种分析方法背后的推理也可以应用于支持动态缓存分区的全局调度。

研究了支持动态缓存分配的抢占式全局EDF调度算法的可调度性问题。与已有工作相比，我们提出了一种新的基于LAG的分析方法，并利用该方法<span style="background:#FF9999 !important;">推导了基于利用率的可调度性判定条件。这不仅降低了分析的时间复杂性，而且增强了分析的紧密性。</span>大量的随机实验验证了调度分析的有效性，与基于问题窗口的分析方法相比，随机生成的任务集的接受率有了显著的提高。

## 2 相关工作

近年来，高速缓存分区技术因其在实时系统中的应用而备受关注，因为它们具有显著的减少共享高速缓存干扰的能力[4]、[5]、[12]、[13]。实现高速缓存分区主要有两种方式：基于软件的方法，例如页面着色[14]，其利用操作系统中的虚拟到物理页面地址映射来实现高速缓存分区；以及基于硬件的方法，例如高速缓存锁定[15]和CAT[4]，最近的处理器为高速缓存分区提供更有效的硬件支持[13]、[16]。

另一方面，高速缓存干扰已被纳入最近的调度器和分析方法[17]-[19]。限制每个核心可访问的高速缓存分区会增加任务执行时间；因此，需要有效的分配技术来最大化可调度性。缓存分区分配方法大致可以分为静态分配[4]、[13]、[20]-[22]、动态分配[3]、[6]。静态分配将缓存分区分配给核心，而分配在整个任务集的执行过程中保持不变。这种分配方法与分区调度具有天然的相关性，并显著简化了分析。然而，如果缓存敏感的任务要求所有缓存分区都满足其截止日期，则<span style="background:#FFFFBB !important;">静态分配下的其他核心任务几乎不可避免地会错过其截止日期。</span>

动态分配将缓存分区分配给任务，允许根据任务要求将缓存分区动态分配给核心。目前同时考虑全局调度和动态缓存分配的工作包括[6]和[3]。Guan et al.[6]提出了一种基于缓存感知的非抢占固定优先级调度方法(NFPca)，消除了任务执行过程中的抢占开销。然而，非抢占性质可能会导致优先级反转情况，从而降低可调度性。对此，徐等人做出了回应。[3]提出了一种基于缓存感知的抢占固定优先级调度方法(GFPca)，并在实际硬件上实现。这两种方法都采用了基于窗口的分析技术，通过将问题窗口划分为核心忙和缓存忙间隔，将可调度性问题编码为线性规划问题。相反，我们的方法基于LAG方法，适用于更一般的调度策略，不仅提高了可调度性，而且减少了分析时间。

## 3 准备

### 3.1 任务模型

我们考虑一个支持共享缓存分区的多核处理器。该处理器由M个独立的同构核心和A个大小相等的独立缓存分区组成。所有内核都可以访问这些缓存分区。

考虑一个独立的零星任务集τ={τ1，τ2，...，τn}。任务τi由四元组(ei，di，pi，ai)表示，其中，ei表示任务的最坏情况执行时间(WCET)，di表示任务的相对截止期限，其是任务在释放之后必须完成的时间长度，pi表示任务的周期，其是任务实例两次连续发布之间的最小时间间隔，并且ai表示任务需要占用的高速缓存分区的数量。与传统任务的本质区别在于，本文中的任务在执行过程中占用固定大小的缓存。单个任务占用的缓存分区数不超过处理器中缓存分区的总数，即0≤ai≤A。	

本文研究了隐式截止期任务，其中任务τi的截止期di等于其周期pi。任务τi的空闲时间为Si=di-ei。任务τi的利用率定义为ui=ei/pi。任务τi的高速缓存利用率定义为$U_i^a=a_i*e_i/p_i$。任务集缓存的利用率定义为$U={\sum_{\forall \tau_i\in\tau }}u_i$，τ的缓存利用率定义为$U^a={\sum_{\forall \tau_i\in\tau }}u_i^a$。

每个零星任务τi释放无限的作业序列，其中每个作业的到达时间被至少pi个时间单位隔开。第j个作业由$\tau_i^j$表示，作业序列可以表示为$\tau_i^1,\tau_i^2...$，作业$\tau_i^j$的释放时间由$r_i^j$表示，作业的完成时间由$f_i^j$表示，绝对截止时间由$d_i^j$表示，<span style="background:#BBFFBB !important;">最迟开始时间由$l_i^l$表示</span>，其中$d_i^j=r_i^j+d_i$,$l_i^j=r_i^j+S_i$。τi的每个作业最多保留ai个ei时间单位的缓存分区。因此，我们将作业的缓存需求定义为时间空间中的ai×ei矩形。类似地，作业的执行需求被定义为ei。

### 3.2 缓存感知调度

提出了一种支持缓存分区的抢占式全局EDF调度算法(简称gEDFca)。该算法将EDF策略应用于高速缓存感知全局调度：具有较早绝对截止日期的作业被赋予较高的优先级。与经典的全局EDF不同，gEDFca始终允许并行执行M个就绪任务，同时考虑到可用缓存分区的限制。

具体地说，gEDFca总是在作业完成或释放时做出调度决策：给定足够的高速缓存分区和核心，总是选择最高优先级的任务(即，具有最早的绝对截止日期)来执行(包括抢占占用高速缓存分区和核心的其他低优先级任务)。对于任何作业$\tau_i^j$:

·除了优先级较高的任务占用的核心外，至少有一个核心可用。

·除了高优先级任务占用的分区外，至少还有其他AI缓存分区可用。

·$\tau_i^j$是满足上述条件的所有任务中优先级最高的任务。

![image-20230722182241395](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307221822523.png)

算法1的输入是就绪任务队列QReady，它包含根据最早的绝对截止日期排序的所有已发布但未完成的任务。该算法的输出是执行队列Qrun。函数First(QReady)返回队列QReady中最高优先级的任务(即，具有最早绝对截止日期的任务)。函数调度(Qrun)通过以下方式来调度执行队列Qrun：如果当前正在执行的任务在队列中，则保留该任务；如果该任务不在队列中(即，被抢占)，则释放由该任务占用的核心和高速缓存分区；以及允许队列Qrun中但当前没有执行的任务使用剩余的核心和资源来开始执行。

该算法的第一行初始化队列Qrun和QReady。生成执行队列Qrun的主要过程在算法的第3行到第9行中实现。在循环的每次迭代中，标识当前就绪任务中具有最早绝对截止日期的任务(第4行)，并检查当前核心和高速缓存分区约束(第5行)。如果满足约束，则将任务添加到执行队列Qrun(第6行)，并且在循环结束时从就绪队列QReady中移除该任务(第8行)。该算法重复上述循环，直到QReady为空。在算法结束时，可以得到当前的执行队列。请注意，尽管该算法使用最早截止日期优先策略，但由于缓存空间有限，具有较大缓存需求的高优先级任务可能会被阻塞。为了减少系统资源的浪费，该算法允许其他截止时间较晚但满足缓存空间约束的任务在这种情况下使用空闲资源并优先执行。

![image-20230722182526191](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307221825284.png)

例1.如表1所示，任务集τ包含三个独立的 受最后期限限制的任务。假设任务集τ中的所有任务在时间0被释放。图1给出了由GEDFCA调度算法调度的任务集τ的具体示例。在图1中，在时间0处，同时释放$\tau_1^1$、$\tau_2^1$和$\tau_3^1$。尽管$\tau_2^1$具有与$\tau_3^1$相同的优先级(绝对截止日期4)，但最高优先级任务$\tau_1^1$占用两个缓存分区，导致$\tau_2^1$由于缓存可用性不足而被阻塞。因此，$\tau_3^1$利用剩余的缓存和处理器资源并首先执行。在时间1，$\tau_1^1$完成其执行，释放被占用的核心和高速缓存。因此，被阻止的任务$\tau_2^1$现在可以执行。类似地，在时间2处，$\tau_1^2$被释放。由于$\tau_2^1$具有与$\tau_1^2$相同的绝对截止日期，并且$\tau_1^2$需要占用两个缓存分区，因此即使在存在空闲处理器(核心1)的情况下，$\tau_1^2$也保持被阻塞状态，直到$\tau_2^1$在时间3完成并释放资源。

## 4、可调度性分析

### 4.1 基于LAG的分析技术

在介绍基于LAG的分析技术之前，有必要引入<span style="background:#bbffff !important;">理想调度(IS)的</span>概念，这是一种理论上和实际不存在的虚拟调度策略。这类调度通常满足某些特殊性质，通常用于辅助证明其他已有调度策略的性质。以下是对理想调度的描述：

**定义1**.如果存在使得$r_i^j$≤t<$d_i^j$的作业$\tau_i^j$，则任务τi在时间t是活动的。

**定义2(资源共享调度)**。对于任何支持动态缓存分配的任务集τ，资源共享(RS)调度是一种理想的调度。在RS调度下，任务τi满足两个属性：1)任务τi占用大小为$u_i^a$的高速缓存；2)任务τi以等于其利用率ui的速度执行(即，在任务τi的任何活动时间，它完成其工作负荷的ui部分)。

注意，如果任务集τ的利用率U和高速缓存利用率Ua分别不大于M和A，则任务集τ具有RS调度。此外，虽然在RS调度下，任务τi占用的缓存减少到Uai，但任务活动期间的缓存需求保持不变，即$u_i^j*d_i=a_i*d_i$。图2给出了RS调度的示例。

![image-20230722195352309](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307221953454.png)

例2.如表I所示，任务集τ由三个相互独立的隐式截止日期任务组成。假设任务集τ中的所有任务在时间0被释放，图2示出了RS调度下的任务集τ的示例。由于任务的执行速度等于其利用率，因此在RS调度下，任务的执行时间等于其周期。此外，在RS调度下，任务在其执行周期内每次占用的高速缓存等于其高速缓存利用率。因此，在RS调度下，任务τ1的执行时间为2，其执行期间占用0.5个处理器核和1个缓存分区；任务τ2的执行时间为4，其执行期间占用0.5个处理器核和1个缓存分区；任务τ3的执行时间为4，其执行期间占用0.5个处理器核和0.5个缓存分区。请注意，<span style="background:#BBFFBB !important;">尽管在RS调度下，任务占用的处理器核心和缓存分区发生了变化，但任务执行和缓存需求保持不变。</span>

<span style="background:#FFDBBB !important;">基于LAG分析的方法将任意调度(称为S)和相应RS调度的执行时间分配和缓存分配进行比较，并量化两者之间的差异以得出可调度性条件。</span>首先，我们分析了任务级的时间分配和缓存分配：设A($\tau_i^j$，t1，t2，S)表示作业$\tau_i^j$在S调度下在时间间隔[t1，T2)内的时间分配；对应$A^a$($\tau_i^j$，t1，t2，S)表示作业$\tau_i^j$在S调度下在时间间隔[t1，t2)内的缓存分配。因此，在S调度下，任务τi在时间间隔[t1，t2)内的时间分配由下式给出：

![image-20230722200944261](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222009334.png)

相应地，在S调度下，任务τi在时间间隔[T1，T2)内的缓存分配由下式给出：

![image-20230722201123729](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222011792.png)

考虑到作业$\tau_i^j$在执行期间占用的高速缓存大小由ai表示，它如下所示：

![image-20230722201446462](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222014533.png)

设RS表示S调度对应的RS调度，其中RS中所有作业的时间分配和缓存分配与S中一致。

<span style="background:#BBFFBB !important;">**定义3(lag)**。作业$\tau_i^j$在时间t的lag是在时间间隔[0，t]内RS调度和S调度的分配之差，具体地说：</span>

![image-20230722203859406](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222038512.png)

<span style="background:#BBFFBB !important;">**定义4(缓存lag)。**作业$\tau_i^j$在时间t的缓存lag是RS和S调度在时间间隔[0，t]内的缓存分区分配之差，具体为：</span>

![image-20230722203958246](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222039326.png)

> RS，资源共享的缓存分区调度
>
> S，实际的缓存分区调度
>
> lag，资源共享调度cpu分配-实际调度cpu分配
>
> laga，资源共享调度缓存分区分配-实际调度缓存分区分配
>
> 大写的LAG是任务集的

同样，任务τi在时间t的lag是RS和S调度在时间间隔[0，t]内的工作量之差，如下：

![image-20230722204155747](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222041827.png)

任务τi在时间t的缓存lag是RS调度和S调度在时间间隔[0，t]内的缓存工作量之差，如下：

![image-20230722204306979](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222043056.png)

示例3.图3给出了作业的lag和高速缓存lag的示例。让我们考虑一个任务τi=(2，4，4，2)。假设在调度策略S下，任务τi由于某种原因从时间3开始执行，在时间间隔[0，4]内，任务τi在处理器1上执行1个时间单位，因此时间分配为A(τi，0，4，S)=1×1=1，在这段时间内，任务τi占用2个缓存分区，缓存分配Aa(τi，0，4，S)=1×2=2，根据定义，任务τi的利用率为UI=0.5，缓存利用率为UAI=1。在调度策略RS下，任务τi在时间间隔[0，4)内的时间分配为A(τi，0，4，RS)=0.5×4=2，缓存分配为Aa(τi，0，4，RS)=1×4=4。因此，根据定义，任务τi在时间间隔[0，4)内的lag为Lag(τi，4，S)=2-1=1，缓存lag为Laaga(τi，4，S)=4-2=2。

![image-20230722204334030](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222043126.png)

**定义5**.调度策略S下任务集τ在t时刻的LAG和缓存LAGa定义如下：

![image-20230722205504071](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222055159.png)

假设在调度策略S下，任务集τ是不可调度的。设$t_d$表示在该调度中错过第一个最后期限的时间，并且设$\tau_p^q$表示在时间$t_d$错过最后期限$d_p^q$的第一个作业。由于本部分涉及抢占式最早截止日期优先调度，对于所有绝对截止日期晚于$t_d$的作业，其优先级低于$\tau_p^q$，因此，它们不影响截止日期早于$t_d$的作业的调度。因此，为简单起见，在下面的文本中，我们从<span style="background:#BBFFBB !important;">τ中删除了所有绝对截止日期晚于$t_d$的作业。</span>

**定理1.**如果在调度策略S下存在一个在时间$t_d$错过截止期的作业$\tau_p^q$，则存在LAG(τ，$t_d$，S)>0和LAGa(τ，$t_d$，S)>0。

证据。在调度S中，对于在时间$t_d$之前没有错过截止日期的任何任务τi，由于没有错过截止日期，所以完成的工作量和高速缓存负载等于RS调度中的工作量和高速缓存负载。根据lag的定义，lag(τi，$t_d$，S)=0和laga(τi，$t_d$，S)=0成立。

由于S调度下的作业$\tau_p^q$在时间$t_d$处错过了其截止日期，这相当于作业$\tau_p^q$没有完成在S调度下的时间间隔[0，Td]内本应完成的工作量。因此，A($\tau_p^q$，0，$t_d$，RS)>A($\tau_p^q$，0，$t_d$，S)成立。类似地，Aa($\tau_p^q$，0，$t_d$，RS)>Aa($\tau_p^q$，0，$t_d$，S)。

使用公式(2)和等式(3)，<span style="background:#BBFFBB !important;">如果任一任务τp有一个作业在时间$t_d$错过了截止日期，则lag(τp，$t_d$，S)>0和laga(τp，$t_d$，S)>0同时成立。</span>

根据定义5，如果任务集合τ中有一个作业在时间$t_d$错过了截止日期，则LAG(τ，$t_d$，S)>0和LAGa(τ，$t_d$，S)>0同时保持。

### 4.2 基于利用率的可调度性测试

**定义6(执行间隔)**。时间间隔[t1，t2)，其中t1<t2，如果存在在整个间隔内执行的τi的一个作业，则称其为τi的执行间隔，即，1)<span style="background:#BBFFBB !important;">一个核</span>和2)<span style="background:#BBFFBB !important;">ai高速缓存分区</span>用于执行该间隔中的τi的一个作业；否则，称其为τi的非执行间隔。

**定义7**.一个时间间隔[t1，t2)，其中t1<t2，如果在整个时间间隔内所有M个核都在执行τ的任务，即在该时间间隔内没有核是空闲的，则**对τ说是忙的**；否则，说它对τ是非忙的。

**定义8(非执行核心-忙/高速缓存-忙间隔)。**对于**任务τi的非执行间隔[T1，T2]**，如果处理器在该间隔期间的任何时刻都是忙的(即，<span style="background:#BBFFBB !important;">没有空闲的处理器)，则该间隔称为任务τi的**非执行核忙间隔**</span>。如果在该间隔期间的任何时间，所有处理器核都是非忙的(即，<span style="background:#BBFFBB !important;">至少一个处理器核是空闲的)，则该间隔称为任务τi的**非执行高速缓存忙间隔**</span>

通过应用执行-繁忙区间分区的分析技术，我们可以很容易地推断，如果作业$\tau_i^j$在**其非执行区间内被释放但仍未完成**，则可以归因于两种可能性之一：要么所有处理器核心都忙，要么最多有Ai-1空闲高速缓存分区可用。这些可能性分别对应于非执行核心忙碌间隔和非执行缓存忙碌间隔。

> 作业在一段时间间隔内被释放，但是没有完成，要么因为没有空闲cpu要么因为没有空闲缓存分区

**定义9(最早正LAG时间瞬间)**。如果在gEDFca调度下，任务集τ在时间td第一次错过其最后期限，则τ(0<t0<td)的最早正LAG时间t0是时间间隔[0，td)内满足以下条件的最早时刻：

![image-20230722225722890](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222257983.png)

基于定理1和LAG(τ，0，gEDFca)=0，很好地定义了最早正LAG时刻t0。此外，根据定理1和LAGa(τ，0，gedfca)=0，任务在执行过程中还需要占用相应的缓存，并且时间t0也满足：

![image-20230722230250643](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222302726.png)

**推论1**.如果任务集τ在gEDFca调度下错过了最后期限，则至少存在一个记为τl的任务满足lag(τl，t0，gEDFca)>0和laga(τl，t0，gEDFca)>0。

证据。根据定义，任务集τ在t0时刻的LAG等于所有任务在t0时刻的lag之和。因此，根据等式(6)，在τ中至少有一个任务在时间t0具有大于0的lag。设τl表示这样一个任务，我们有：lag(τl，t0，gEDFca)>0。根据公式(1)和(3)，对于任务τl，我们有：laga(τl，t0，gedfca)=al×laga(τl，t0，gedfca)>0。

由于任务τl在t0的lag大于0，因此τl至少有一个在时间t0之前发布的作业在时间t0未完成。因为$t_d$是作业错过最后期限的最早时刻，所以我们有t0≤td。此外，由于任何截止日期任务在单个周期内没有多个作业，因此<span style="background:#BBFFBB !important;">任务τl只有一个作业在t0之前发布，在时间t0没有完成。设任务$\tau_l^h$为该作业</span>，作业$\tau_l^h$的释放时间为$r_l^h$，由于在时间td之前没有其他作业错过截止期，且$r_l^h$<t0≤td，所以在τl的时间$r_l^h$之前释放的所有作业都在gEDFca调度下完成。类似地，在RS调度下，在任务τl的时间$r_l^h$之前发布的所有作业都已经完成。因此，对于τl，在时间$r_l^h$，lag(τl，$r_l^h$，gedfca)=0。类似地，laga(τl，$r_l^h$，gedfca)=0。

设**E**表示在时间间隔\[$r_l^h$，t0)内**执行作业**$\tau_l^h$的累积时间，即，在\[$r_l^h$，t0)内的**执行间隔长度**。$\overline{E}$表示作业$\tau_l^h$在时间间隔\[$r_l^h$，t0]内**未执行且没有处理器核心空闲的累积时间**，即\[$r_l^h$，t0)内**未执行的核心忙碌间隔的长度**。$\overline{E^a}$表示作业$\tau_l^h$在时间间隔\[$r_l^h$，t0]内**未执行且至少有一个处理器核心空闲的累积时间**，即\[$r_l^h$，t0)内**未执行的高速缓存忙间隔的长度**。如图4所示，根据上述定义，它认为：

![image-20230722233305980](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222333050.png)

![image-20230722233258575](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307222332683.png)

> 图上，rjk还是rlh

引理1.如果任务集τ在gEDFca调度下遇到错过截止期的情况，则存在一个任务τl使得lag(τl，t0，gEDFca)>0，且<span style="background:#BBFFBB !important;">该任务满足</span>：

![image-20230723110325375](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307231103525.png)

证据。根据推论1，给定任务集τ在gEDFca调度下的不可调度性，存在任务τl使得lag(τl，t0，gEDFca)>0。利用lag的属性，任务τl在时间t0的lag可以计算如下：

![image-20230723111705460](C:/Users/wsf/AppData/Roaming/Typora/typora-user-images/image-20230723111705460.png)

因为lag(τl，$r_l^h$，gEDFca)=0，根据推论1，我们有：

![image-20230723195817218](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307231958329.png)

由于作业$\tau_l^h$在时刻$r_l^h$被释放并且在时刻t0未完成，因此基于定义6中的执行间隔，.众所周知，在gEDFca调度下，作业$\tau_l^h$在E间隔期间的每个时间点在处理器核上执行。根据RS调度的定义，作业$\tau_l^h$在RS调度下的执行率等于其利用率ul。基于公式(8)，我们有：

![image-20230723200238995](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307232002114.png)

此外，我们知道ul=el/pl≤1.注意，如果ul=1，则$U > \left \lceil \frac{A-a_l+1}{\max_{\tau_i\in \tau} a_i}  \right \rceil(1-u_l) +u_l=u_l$成立，对于所有k，n>1且==ek>0==。因此，考虑ul<1的情况，我们得到：

> ek还是el

![image-20230723201814820](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307232018944.png)

根据公式(10)$(E+\overline{E} +\overline{E^a})*u_l-E>0$.因此，$(\overline{E} +\overline{E^a})*u_l>E-E*u_l$，对于0<ul<1，我们有$\overline{E} +\overline{E^a}>0$

根据公式(6)，LAG(τ，t0，gEDFca)>0以及<span style="background:#BBFFBB !important;">LAG(τ，$r_l^h$，gEDFca)≤0</span>，因此，LAG(τ，t0，gEDFca)-LAG(τ，$r_l^h$，gEDFca)>0。根据定义，我们有：

> 为什么小于等于0 

根据定义，我们有：

![image-20230723221101767](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307232211884.png)


根据定义8中对非执行间隔的定义。显而易见，在gEDFca调度下：$\overline{E}$期间的每个时刻，所有M个处理器核都是忙碌的；此外，$\overline{E^a}$期间的每个时刻，至少有一个处理器核心处于空闲状态。由于尽管有空闲处理器可用，但作业$\tau_l^h$无法在$\overline{E^a}$期间执行，因此至少有$A-a_l+1$个缓存分区被其他任务占用。任务集τ中的单个任务τi最多占用ai个缓存分区（$max_{\tau_i \in \tau}a_i$），因此$\overline{E^a}$期间，最少$min(\left \lceil \frac{A-a_l+1}{\max_{\tau_i\in \tau} a_i}  \right \rceil, M-1)$任务在执行。

让$B=min(\left \lceil \frac{A-a_l+1}{\max_{\tau_i\in \tau} a_i}  \right \rceil, M-1)$.由于每个核在任何给定时间只能执行一个任务，因此$\overline{E^a}$期间，至少有B个处理器核处于忙碌状态。通过上述分析，我们可以得出：

![image-20230724210235317](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242102431.png)

根据RS调度的定义，将任务集τ在时间间隔\[$r_l^h$，t0)内的执行率表示为U，可以表示为：

![image-20230724210501630](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242105712.png)

代之以等式(12)和公式(13)到上面的表达式中产生：

![image-20230724211033124](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242110233.png)

将上述表达式的两侧除$\overline{E}+\overline{E^a}$，其$\overline{E}+\overline{E^a}$>0，我们得到：

![image-20230724212127810](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242121954.png)

由于ul<1，将上述公式的两边乘以1−ul，我们得到：

![image-20230724221101468](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242211561.png)

重新安排以获得：

![image-20230724221133792](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242211864.png)

由于$0\le \frac{\overline{E^a}}{\overline{E}+\overline{E^a}} \le 1$和B<M成立，我们有：

![image-20230724222848719](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242228818.png)

因此，当在gEDFca调度策略下存在错过其最后期限的任务时，存在任务τl使得该任务集被利用$U>min(\left \lceil \frac{A-a_l+1}{\max_{\tau_i\in \tau} a_i}  \right \rceil, M-1)*(1-u_l)+u_l$

证据是完整的。

**引理2**.如果任务集τ在gEDFca调度下错过一个截止日期，则存在一个任务τl使得laga(τl，t0，gEDFca)>0，且该任务满足：

![image-20230724223115957](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242231053.png)

证据。由于任务集τ在gEDFca下不可调度，因此在时间t0存在lag大于0的任务τl。根据公式(7)，任务τl在时间t0的laga也大于0。根据定义，任务τL在时间t0的缓存lag时间可以确定如下：

![image-20230724223234556](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242232646.png)

此外，由于laga(τl，$r_l^h$，gedfca)=0，根据推论1，我们有：

![image-20230724223308075](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242233165.png)

由于作业$\tau_l^h$在时刻$r_l^h$被释放且在时刻t0未完成，基于执行忙区间定义6，在gEDFca调度下，作业$\tau_l^h$在E期间的每个时刻占用的缓存大小为al。根据RS调度定义，作业$\tau_l^h$在RS调度下占用的缓存大小等于其缓存使用率$u_l^a$。从方程(8)，我们有：

![image-20230724223826420](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242238523.png)

由于$u_l^a = \frac{a_l*e_l}{d_l} \le a_l$ ，我们得到：

![image-20230724224255847](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242242949.png)

通过公式6，LAGa≤(τ，t0，gEDFca)>0和LAGa(τ，$r_l^h$，gEDFca)≤0，所以LAGa(τ，t0，gEDFca)-LAGa(τ，$r_l^h$，gEDFca)>0。根据定义，我们拥有：

![image-20230724225538907](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242255006.png)


基于非执行区间定义8，在GEDFCA调度下：在非执行高速缓存忙区间$\overline{E^a}$中的每个时刻期间，至少$A-a_l+1$个高速缓存空间被占用；另外，在非执行核心==忙区== $\overline{E}$ 中==的每个时刻期间，所有M个处理器核都处于忙碌状态。任务集τ中任务占用的最小缓存空间为$\min_{\tau_i\in \tau} a_i$，==因此$\overline{E}$中的每个时刻==，至少会占用$M*\min_{\tau_i\in \tau} a_i$缓存分区。从前述分析中，我们推断：

> $\overline{E}$ 还是 $\overline{E^a}$                               

![image-20230724230435257](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242304343.png)

根据RS调度定义，任务集τ在时间间隔\[$r_l^h$，t0)占用的缓存空间为Ua，产生：

![image-20230724231245605](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242312727.png)


代之以等式(15)和等式(16)在上述表达式中，我们获得：

![image-20230724231727045](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242317159.png)


将上述公式的两边除$\overline{E}+\overline{E^a}$。$\overline{E}+\overline{E^a}$>0以来，我们拥有：

![image-20230724233327781](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242333947.png)


将上述表达式的两边乘以$\frac{a_l-u_l^a}{u_l^a}$ ，其中$\frac{a_l-u_l^a}{u_l^a}$ >0，我们得到：

![image-20230724234140333](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242341442.png)


重新排列上面的表达式，我们得到：

![image-20230724234407418](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242344507.png)


将等式的两边乘以$\frac{u_l^a}{a_l}$，我们得到：

![image-20230724234925130](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242349220.png)


观察方程(17)，很明显，除$\frac{\overline{E^a}}{\overline{E}+\overline{E^a}}$ 的未定值外，该不等式的右侧包含已知参数。令![image-20230724235123186](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242351300.png)；![image-20230724235134694](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242351792.png)![image-20230724235153318](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242351443.png)。该不等式的右侧可以用函数$y'=\beta '*x'+\alpha '$表示。根据Eq.(17)，我们有：

![image-20230724235309403](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242353505.png)

有两种情况：1) $\beta '\ge0$ ；2)$\beta '<0$ 。对于情况1)，我们有：

![image-20230724235409259](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242354658.png)

对于情况2)，我们有：

![image-20230724235453596](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242354688.png)


因此，结合这两种情况，当存在在gEDFca调度策略下错过其期限的任务时，存在任务τL使得高速缓存利用率Ua>![image-20230724235726469](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242357567.png)。证据是完整的。

定理2.如果对任一任务集τ，所有任务τk满足：

![image-20230724235807160](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307242358248.png)


然后，任务集τ可以由gEDFca进行调度。

> u和ua大于后面的话，说明有任务l错过截止期
>
> 小于等于说明没有任务错过截止期，任务集可gedfca调度

证据。下面的证明是基于矛盾的。假设定理不成立，这意味着存在一个特定的任务集τ满足所有任务的公式τi∈τ，并且在gEDFca调度下至少有一个作业错过了它的最后期限。

假设任务集τ包含在==GEDF==调度下错过其最后期限的任务，基于推论1，存在任务τL使得lag(τL，t0，gEDFca)>0和laga(L，t0，gEDF ca)>0。参考引理1，本任务τL满足等式(9)。此外，根据引理2，本任务τL也满足等式(14)。因此，根据等式(9)和(14)，当任务在==gEDF==调度下错过截止期时，存在一个任务τL满足：

![image-20230725000123245](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307250001338.png)


这与等式(18)相矛盾。从而证明了该定理。

> gedfca?

## 5 实验

### 5.1.实验装置

在本节中，我们使用一组随机生成的<span style="background:#FFDBBB !important;">隐式截止日期任务</span>，其参数设置与[6]中给出的参数设置一致。具体地说，表示为<span style="background:#FFDBBB !important;">M的处理器核的数量被设置为6</span>，并且表示为<span style="background:#FFDBBB !important;">A的高速缓存分区的数量被设置为40</span>。任务<span style="background:#FFDBBB !important;">周期在范围[10，20]内均匀分布，截止日期等于它们各自的周期</span>。最坏情况下的执行时间由任务利用率及其周期的乘积决定。在图5中，根据任务类型将任务利用率ui和缓存分区数ai分为三类，遵循[6]中的参数：在图5A中，ui均匀分布在[0.1，0.3]内，而ai均匀分布在[1，5]内；在图5B中，ui均匀分布在[0.1，0.6]内，而ai均匀分布在[1，5]内；在图5C中，ui均匀分布在[0.1，0.3]内，而ai均匀分布在[2，10]内。同样，图6中的任务也分为三种类型：图6A中，ui均匀分布在[0.1，0.3]内，而ai均匀分布在[5，20]内；图6B中，ui均匀分布在[0.1，0.6]内，而ai均匀分布在[5，20]内；图6C中，ui均匀分布在[0.1，0.3]内，而ai均匀分布在[20，35]内。

任务集是迭代生成的，<span style="background:#fbc2eb !important;">每次迭代产生一个满足参数设置的随机任务，并将其添加到任务集，直到任务集的利用率之和(分别为缓存利用率)超过目标值</span>。随后，<span style="background:#fbc2eb !important;">降低最后任务的利用率(分别为高速缓存利用率)，以使集合中所有任务的利用率(分别为高速缓存利用率)之和等于目标值。</span>我们为曲线上的每个点测试了1000个随机生成的任务集。这些实验是在一台笔记本电脑上进行的，该笔记本电脑配备了AMD Ryzen 7 5800H处理器(3.2 GHz)和16 GB的主内存。在实验中，我们使用开源工具Python-MIP[23]作为LP求解器来求解LP公式。

### 5.2实验结果

我们比较了不同方法的可调度性，其中gEDFca是基于lag的方法；而gFPca[3]、nFPcaT1和nFPcaT2[6]是基于窗口的方法。图6和图5分别显示了当改变U和Ua时，在相应方法下的可调度任务集的比例。

从实验结果中，我们观察到<span style="background:#FF9999 !important;">基于LAG的方法在几乎所有情况下都表现出比基于窗口的方法更好的性能</span>。特别是当任务利用率ui和所需高速缓存ai较低时，如图5A所示，基于lag的方法表现出值得称赞的性能。这归因于公式(18)中1−ui和A−ai+1的较高值。<span style="background:#FF9999 !important;">当ui和ai较低时，这明显有助于增强的可调度性</span>。然而，当任务利用率UI高时，如图5B所示，基于lag的方法的性能经历了显著的下降。这是因为当ui较高时，1−ui会变小，如公式所示。(18)，这对任务集的可调度性有相当负面的影响。此外，我们观察到，当ai的分布范围上升到A/2以上时，由于方程(18)中min(Ai)和max(Ai)的较高值，基于lag的方法的性能有不直观的提高。促进提高可调度性。

表二列出了不同方法所需的分析时间。实验结果表明，在我们的实验平台上处理包含1100个任务的任务集时，基于lag的可调度性分析方法所需时间不到0.5秒，而基于LP的分析方法nFPcaT1和gFPca分别需要6800秒和2900秒以上。这是<span style="background:#FF9999 !important;">由于基于利用率的可调度性条件大大简化了分析过程</span>。此外，nfpca-t2作为nfpca-t1的过度逼近，由于其较低的时间复杂度，所需的时间显著较短(小于0.8秒)。因此，与基于LP的分析方法相比，基于lag的可调度性分析方法具有更高的效率。

## 6 结论

共享缓存分区技术提供了一种减少任务执行时间不确定性的方法。提出了一种支持动态缓存分配的全局EDF调度算法，并针对该算法提出了一种基于lag的可调度性分析方法。通过该方法得到了<span style="background:#FF9999 !important;">基于利用率的可调度性条件，不仅降低了可调度性分析的计算复杂度，而且得到了更准确的分析结果</span>。随机实验表明，该分析方法具有较高的效率和性能。

## 优化

在上一节中，我们介绍了一个基于LAG的可调度性分析测试(定理2)。我们现在提出了一种有效的优化技术来进一步提高可调度性。通过考察可调度性条件的推导过程，我们发现在估计非执行间隔任务的高速缓存分区时存在过度悲观的情况。也就是说，如果作业i，j在其非执行间隔内被释放但保持未执行，则1)在非执行核心忙间隔期间，至少$M\min_{\tau_i\in \tau} a_i$高速缓存分区被占用，以及2)在非执行高速缓存忙间隔期间，至少A-ai+1高速缓存分区被占用。虽然这两个估计是安全的，但对于任务参数已知的系统，仍然可以进行进一步的优化。

具体地说，在第一种情况下，由于处理器稀缺，任务在非执行核心忙碌间隔期间保持未执行状态，因为所有M个处理器都在执行其他更高优先级的任务。因此，至少$M\min_{\tau_i\in \tau} a_i$缓存分区被占用。如果在这M个任务中，有些任务占用的缓存分区数大于$\min_{\tau_i\in \tau} a_i$，则先前的估计可能过于悲观。这低估了在非执行核心繁忙间隔期间执行的任务的高速缓存利用率。考虑下面的例子来说明这种情况。

示例4.我们考虑在配备四个缓存分区的双核处理器上执行三个任务的任务集：τ1(e1=1，d1=4，p1=4，a1=3)，τ2(1，4，4，1)，τ3(3，4，4，1)。该任务集的总利用率为U=1.25，总缓存利用率为UA=1.75。设rhs1=$min(\left \lceil \frac{A-a_k+1}{\max_{\tau_i\in \tau} a_i}  \right \rceil, M-1)*(1-u_k)+u_k$，且rhs2=$min(M\min_{\tau_i\in \tau} a_i\rceil, M-1)*(1-u_k)+u_k^a$.对于任务集3，rhs1=1.0<1.25，rhs2=1.25<1.75，按定理2判定该任务集不可调度.

在示例2中，我们观察到任务集{τ1，τ2，τ3}实际上是可调度的。尽管总的高速缓存需求a1+a2+a3=5超过了可用高速缓存分区A=4，从而排除了所有三个任务的并发执行，但是使用抢占式EDF调度，该集合仍然是可调度的。具体地说，任务τ1和τ3可以在同一处理器上连续执行，同时满足它们的最后期限。在定理2的S可调度性准则的背景下，我们使用$M\min_{\tau_i\in \tau} a_i$=2×1=2来估计τ3的非执行核心忙期所占用的最小缓存分区数。虽然这是一个安全的估计，但它过于悲观。根据任务集的具体参数，除非1和3并行运行，否则τ3无法执行，这使得在非执行的核心繁忙间隔a1+a2=4期间实际的缓存占用。用这个值代替定理2中的$M\min_{\tau_i\in \tau} a_i$，我们得到rhs2=1.75=Ua。

**定义10.**设Kl表示在τL的非执行核心忙碌间隔期间占用的最小缓存分区数。

计算Kl。要计算Kl，需要从任务集τL(即，不包括τ/τL的任务集τ)中识别满足以下三个性质的任务子集τKl：

C1。子集恰好包含M个任务

C2。子集占用的缓存分区总数不超过A

C3。在满足属性C1和C2的所有子集中，由子集中的任务占用的高速缓存分区之和是最小的。

属性C1和C2确保任务子集τKl可以抢占所有M个处理器。如果占用的高速缓存分区数超过总的可用高速缓存分区A，这意味着τKl内的任务不能并行执行。属性C3保证子集τKl在τL的非执行核心忙碌间隔期间占用最小数量的高速缓存分区，从而将Kl建立为高速缓存分区的该最小和。应当注意，如果不存在任务子集τKl，则意味着该任务没有未执行的核心忙碌间隔，表示$\overline{E}$=0。

**引理3.**如果![image-20230904221554674](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042215881.png)，则在任务集τ/vτL内不存在子集τKl；否则：

![image-20230904221733469](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042217571.png)

其中ak表示任务τk在任务集τ/τL中占用的缓存分区数。

证据。设S‘为集合![image-20230904221910185](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042219278.png)中M个最小元素的子集。![image-20230904221951506](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042219603.png)是S`的元素之和，也就是占用缓存分区最少的M个任务的缓存需求总和。假设存在S的一个子集T，它也包含M个元素，其和![](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042220161.png)。

1)如果T的所有元素都包含在S`中，则T元素的和一定等于S'的元素的和，这与我们的假设相矛盾。2)如果T的某个元素不在S的元素中，则T一定包含一个大于S的元素的元素。为了使T和更小，它还必须包含一个比S’中所有其他元素都小的元素，这与我们的定义相矛盾，因为S‘包含S中的M个最小元素。

这两种情形都与假设或定义相矛盾，从而证明了![image-20230904221951506](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042219603.png)是S的任何M元子集的最小和。如果![image-20230904222343110](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042223212.png)，这意味着τ/τL的任何子集都不能满足性质C2。由于刚刚证明了没有一个子集能比S`占用更少的高速缓存分区，从而推论出如果![image-20230904222407692](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042224799.png)，那么在任务τL的非执行核心忙间隔期间占用的最小高速缓存分区数为![image-20230904222434226](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309042224332.png)。

**引理4**.如果不存在任务集τ/τL的子集τKl，则任务τL没有非执行的核心忙区间，$\overline{E}$=0。

证据。证据是通过矛盾来进行的。假设τ/τL内不存在子集τKk，但任务τL有一个非零的非执行核心忙区间，$\overline{E}$≠0。根据非执行核心忙碌间隔的定义，如果任务τL有这样的间隔，则存在任务τL挂起并且所有处理器被占用的时刻。这意味着在该间隔内存在并发执行的任务集τ‘Kl。根据挂起的定义，在此区间内执行的任务是τ/τL的子集。由于每个处理器在给定时刻只能执行一个任务，因此τ‘Kl包含M个任务，满足性质C1。由于A缓存分区的系统范围上限，τ‘K1占用的缓存分区数不超过A，满足C2。假设子集τ‘K1满足C_1和C_2，则τ/τL内必须至少存在一个满足C_3的子集。这与假设相矛盾，从而证明了引理。

另一方面，在第二个场景中，在非执行缓存繁忙间隔期间，由于缓存分区不足，任务无法执行，导致至少有A−ai+1个缓存分区被占用。与第一种情况一样，尽管该估计值是安全的，但当预先知道任务参数时，该估计值可能过于悲观，并且它还可能影响非执行高速缓存繁忙间隔期间的处理器利用率估计。我们用下面的例子来说明这一点。

**示例5**.考虑在具有10个缓存分区的四核处理器上执行由四个任务组成的任务集：τ1(e1=5，d1=10，p1=10，a1=3)，τ2(5，10，10，3)，τ3(4，10，10，4)，τ4(4，10，10，3)。CPU总使用率U=1.8，缓存总使用率UA=5.8。根据定理2，对于任务τ1，rhs1=1.5<1.8，rhs2=5.8<5.6，因此该任务集被认为是不可调度的。

在示例3中，很容易观察到任务集实际上是可调度的：通过使用抢占式EDF调度，并假定任务τ1和τ2的CPU利用率之和为1，τ1和τ2都可以在单个核上串行执行，并且仍然可以满足它们的最后期限。任务τ3和τ4可以在其他内核上执行，从而确保任务集是可调度的。对于任务1，我们使用定理2中的A−A1+1=10−3+1=8来估计繁忙的τ分区的数量。尽管安全，但这过于悲观了。实际上，要使τ1由于空闲缓存不足而无法执行，任务τ2、τ3和τ4必须同时执行，占用a2+a3+a4=10个缓存分区。用这个值替换定理2中的A−A1+1，结果是rhs2=6.5>5.6=UA。此外，定理2中对于在非执行高速缓存繁忙间隔期间必须占用的最小处理器数目的估计![image-20230905100032713](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051000819.png)也过于悲观。如上所述，在τ1‘S非执行高速缓存繁忙间隔期间，必须至少同时执行三个任务，这意味着B=3。

**定义11.**设KAL表示任务τL在非执行缓存忙期间占用的最小缓存分区数。

为了计算KaL，找出τ/τ的子集τKaL满足以下三个性质：

CA1。子集中的任务占用超过A−A1+1个并且少于A个高速缓存分区

CA2。任务数不超过M−1、

CA3。在满足属性CA1和CA2的所有子集中，由子集中的任务占用的高速缓存分区之和是最小的。

第一个和第二个属性确保由于空闲缓存分区不足而无法执行任务，从而满足非执行缓存繁忙间隔的标准。第三个属性最小化缓存分区计数KaL。如果不存在这样的子集，$\overline{E^a}$=0。对于KAL来说，求解本质上是求解子集和问题的一个变体，这是一个计算上的NP困难问题，可以通过动态规划来应用伪多项式时间算法。

**引理5**.如果不存在任务集τKaL的子集τ/τL，则任务τL没有非执行缓存忙区间，记$\overline{E^a}$=0。

证据。证据是通过矛盾来进行的。假设不存在τKaL的子集τ/τL，但τL有一个非零的非执行缓存忙间隔，$\overline{E} $=0。根据非执行高速缓存忙间隔的定义，如果τL具有这样的间隔，则在τL的挂起持续时间内必须存在至少一个时刻t，其中空闲高速缓存分区的数量不足以满足τL的高速缓存需求Al，同时至少有一个处理器保持空闲。也就是说，在时间t，至少A−al+1个高速缓存分区被占用，且至多M−1处理器被占用。让τ‘Ka L表示在这个时刻并发执行的任务集。挂起持续时间意味着在此时间间隔内执行的任务是τ/τL的子集。

假设此时至少有A−al+1个缓存分区被占用，并且缓存分区的上限为A，则τ‘Ka L占用的缓存分区不少于A个，但不超过A个，从而满足性质CA1。由于处理器在给定时刻只能处理一个任务，因此τ‘Ka L的大小不超过M−1，从而满足性质CA2。假设存在满足性质CA1和CA2的子集τ‘Ka L，则τ/τL内必须至少存在一个满足性质CA3的子集.这与最初的假设相矛盾，从而建立了引理.

![image-20230905104315311](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051043423.png)

**算法2计算Ka L**，这是任务τL在非执行缓存繁忙间隔期间占用的最小缓存分区数。该算法采用动态规划并在数组DP上操作，其中DP[j]表示占据j个高速缓存分区的任何子集中的最小任务数。通过将除DP[0]以外的所有条目设置为∞进行初始化(行1-2)，该算法迭代任务集τ/τL中的每个任务Ai。它更新DP数组以捕获在考虑任务Ai时占用j个高速缓存分区的最小任务数(行3-8)。该算法在满足性质CA1-CA3的范围A−al+1到A中搜索最小的Ka L(第9-14行)。根据引理4，如果不存在这样的KA L，则任务τL不存在非执行缓存忙区间。该算法运行在伪多项式时间内，复杂度为O(A×n)，其中A是系统的缓存分区数，n是任务集τ/τL的大小。

**定义12**.设BaL表示任务τL在其非执行缓存忙时间间隔内占用的最小处理器数。

计算BaL。为了计算BaL，需要识别满足以下三个性质的任务集τ/τL的子集τBaL：

P1。子集内的任务占用超过A−al+1个和少于A个缓存分区

P2。任务数不超过M−1和

P3。该子集中的任务数是满足属性P1和P2的所有子集中最小的。

类似于KAL的计算，第一和第二个性质确保任务由于空闲缓存分区不足而不能执行，从而满足非执行缓存忙区间的定义。第三个性质保证了子集τBaL的任务数是最小化的，相当于BaL。找到τBaL实质上转化为解决子集和问题的一个变体，该问题可通过伪多项式时间复杂度的算法来求解。需要注意的是，BaL并不一定等于τKa L的大小，因为后者可能不包含最低任务数量。

![image-20230905104958595](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051049694.png)

算法3利用与KAL算法中相同的动态规划方法，计算任务τL在其非执行高速缓存繁忙间隔期间占用的最小处理器数BAL。DP数组被相同地初始化(第1-10行)，其中DP[j]表示占用j个高速缓存分区的任何子集中的最小任务数。发散出现在第11-20行，其中该算法搜索范围A−al+1到A中的最小的BAL，同时坚持属性P1-P3。最后，该算法针对M−1验证BAL以确定其存在(第16-20行)。与算法2类似，该算法运行在伪多项式时间内，其复杂性为O(A×n)。

**引理6**.如果任务集τ在gEDFca调度下遇到错过截止期的情况，则存在一个任务τL使得τ(gedf L，t0，gEDF ca)>0，且该任务满足：

![image-20230905115312280](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051153381.png)

证据。我们的证明遵循与引理1的证明类似的推理。根据推论1，给定任务集τ在gEDFca调度下的不可调度性，存在任务τL使得lag(τL，t0，gEDFca)>0。

根据Def中对非执行间隔的定义。8、可见在gEDFCA调度下：$\overline{E} $的每个时刻，所有M处理器核都是忙的；根据BaL的定义，$\overline{E^a}$期间至少有BaL核忙，所以我们有：

![image-20230905130243654](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051302769.png)

根据RS调度的定义，将任务集τ在时间间隔[rhL，t0]内的执行率表示为U，可以表示为：

![image-20230905154527825](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051545927.png)

代之以等式。(12)和公式。(13)到上面的表达式中产生：

![image-20230905154559658](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051545754.png)

重新安排以获得：

![image-20230905163802526](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051638637.png)

$\overline{E^a}$=0，则

![image-20230905163821805](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051638901.png)

$\overline{E^a}$≠0,$0<\frac{\bar{E^a}}{\bar{E}+\bar{E^a}}\leq 1$. As $B^a_l \leq M-1 < M$

![image-20230905163927240](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051639323.png)

![image-20230905163941766](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051639855.png),则$U>\hat{B_l} (1-u_l)+u_l$。证据是完整的。

**引理7**.如果任务集τ在gEDFca调度下遇到错过截止期的情况，则存在任务τL使得laga(τL，t0，gEDFca)>0，且该任务满足：

![image-20230905164602068](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051646171.png)

![image-20230905164608194](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051646281.png)

证据。我们的证明遵循与引理2的证明类似的推理。根据推论1，给定任务集τ在gEDFca调度下的不可调度性，存在任务τL使得laga(τL，t0，gEDFca)>0。

根据Def中对非执行间隔的定义8和Kl和KaL的定义，我们有：至少Kl个缓存分区在非执行核心忙区$\overline{E}$ 被占用；至少KaL缓存分区在非执行缓存忙区 $\overline{E^a}$被占用；最后，至少所有al缓存分区在执行区间被τL占用。从前述分析中，我们推断：

![image-20230905164745813](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051647905.png)

代之以等式。(15)和等式(16)在上述表达式中，我们获得：

![image-20230905165858842](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051658959.png)

由于ul<1，将上述公式的两边乘以1−ul，我们得到：

![image-20230905170049732](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051700828.png)

重新安排以获得：

![image-20230905170238870](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309051702990.png)

否则，我们就会有$0<\frac{\bar{E^a}}{\bar{E}+\bar{E^a}}<1$ and $1-u_l>0$有两种情况1) $K^a_l \geq K_l$; 2) $K^a_l < K_l$. 

![image-20230905204059910](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309052041025.png)

因此，结合这两个案例，我们有：

![image-20230905204252329](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309052042431.png)

定理3.如果对任一任务集τ，所有任务τk满足：

![image-20230905205158149](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309052051291.png)

然后，任务集τ可以由gEDFca进行调度。

证据。下面的证明是基于矛盾的，遵循与定理2的证明相同的推理。假设定理不成立，这意味着对于所有任务∈τ存在满足公式的特定任务集τ，并且在gEDFca调度下至少有一个作业错过了它的最后期限。

假设任务集τ包含在GEDF调度下错过其最后期限的任务，基于推论1，存在任务τL使得τ(τL，t0，gEDF ca)>0和LAGA(L，t0，gEDF ca)>0。参考引理6，本任务τL满足等式(19)。此外，根据引理7，本任务τL也满足等式(20)。

因此，根据等式。(19)和(20)，当任务在GEDF调度下错过截止日期时，存在一个任务τL满足：

![image-20230905205504427](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309052055603.png)

这与等式相矛盾。(21)，从而证明了该定理。

## 六、评估

### A.实验装置

在本节中，我们使用一组随机生成的隐式截止日期任务，其参数设置与[6]中给出的参数设置一致。具体地说，表示为M的处理器核的数量被设置为6，并且表示为A的高速缓存分区的数量被设置为40。任务周期在范围[10，20]内均匀分布，截止日期等于它们各自的周期。最坏情况下的执行时间由任务利用率及其周期的乘积决定。在图5中，根据任务类型将任务利用率UI和缓存分区数ai分为三类，遵循[6]中的参数：在图5A中，UI均匀分布在[0.1，0.3]内，而AI均匀分布在[1，5]内；在图5B中，UI均匀分布在[0.1，0.6]内，而AI均匀分布在[1，5]内；在图5C中，UI均匀分布在[0.1，0.3]内，而AI均匀分布在[2，10]内。同样，图6中的任务也分为三种类型：图6A中，UI均匀分布在[0.1，0.3]内，而AI均匀分布在[5，20]内；图6B中，UI均匀分布在[0.1，0.6]内，而AI均匀分布在[5，20]内；图6C中，UI均匀分布在[0.1，0.3]内，而AI均匀分布在[20，35]内。

任务集是迭代生成的，每次迭代产生一个满足参数设置的随机任务，并将其添加到任务集，直到任务集的利用率之和(分别为缓存利用率)超过目标值。随后，降低最后任务的利用率(分别为高速缓存利用率)，以使集合中所有任务的利用率(分别为高速缓存利用率)之和等于目标值。我们为曲线上的每个点测试了1000个随机生成的任务集。这些实验是在一台笔记本电脑上进行的，该笔记本电脑配备了AMD Ryzen 7 5800H处理器(3.2 GHz)和16 GB的主内存。在实验中，我们使用开源工具Python-MIP[23]作为LP求解器来求解LP公式。

### B.实验结果

我们比较了不同方法的可调度性，其中gEDFca是基于滞后的方法；而gFPca[3]、nFPcaT1和nFPca-T2[6]是基于窗口的方法。图6和图5分别显示了当改变U和Ua时，在相应方法下的可调度任务集的比例。

![image-20230905211816248](https://gcore.jsdelivr.net/gh/wsm6636/pic/202309052118394.png)

从实验结果中，我们观察到基于LAG的方法在几乎所有情况下都表现出比基于窗口的方法更好的性能。特别是当任务利用率ui和所需高速缓存ai较低时，如图5A所示，基于滞后的方法表现出值得称赞的性能。这归因于公式中1−UI和A−ai+1的较高值。(18)当ui和ai较低时，这明显有助于增强的可调度性。然而，当任务利用率UI高时，如图5B所示，基于滞后的方法的性能经历了显著的下降。这是因为当UI较高时，1−UI会变小，如公式所示。(18)，这对任务集的可调度性有相当负面的影响。此外，我们观察到，当ai的分布范围上升到A/2以上时，由于方程中min(Ai)和max(Ai)的较高值，基于滞后的方法的性能有不直观的提高。(18)促进提高可调度性。

表二列出了不同方法所需的分析时间。实验结果表明，在我们的实验平台上处理包含1100个任务的任务集时，基于滞后的可调度性分析方法所需时间不到0.5秒，而基于LP的分析方法nFPcaT1和gFPca分别需要6800秒和2900秒以上。这是由于基于利用率的可调度性条件大大简化了分析过程。此外，nfpca-t2作为nfpca-t1的过度逼近，由于其较低的时间复杂度，所需的时间显著较短(小于0.8秒)。因此，与基于LP的分析方法相比，基于滞后的可调度性分析方法具有更高的效率。





***

# 笔记

## 相对于静态分配cache，动态的缓存划分有什么优势？

## 为什么要研究动态缓存划分?

## 相对于固定优先级，动态优先级有什么优势？



## 1 论文创新在于





## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 可学习的知识点

Referred in <a href="zotero://note/u/B6HGD6IA/?ignore=1&#x26;line=-1" class="internal-link" zhref="zotero://note/u/B6HGD6IA/?ignore=1&#x26;line=-1" ztype="znotelink" class="internal-link">LAG</a>
