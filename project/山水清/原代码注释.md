---
created: 2023-07-08T20:33
updated: 2024-03-26T23:33
tags:
  - 笔记
  - 笔记/项目
---
## 主程序 shanshuiqing-server.py

### async def main():

这段代码使用 asyncio 库启动了一个 TCP 服务器，监听本地 IP 地址 `0.0.0.0` 的 `56194` 端口，并在有新连接时调用 `handle_conn` 函数进行处理。其中，`asyncio.start_server()` 是用于创建一个 asyncio 服务器的方法，它会返回一个 `asyncio.Server` 对象，表示创建的服务器实例。

`async with server:` 语句用于在协程退出时自动关闭服务器。而 `await server.serve_forever()` 则是一个协程方法，用于开启服务器的事件循环，并持续监听新的连接请求。

最后，使用 `asyncio.run()` 方法来运行 `main()` 协程，从而启动整个服务器程序。当有客户端连接到服务器时，`handle_conn` 函数将被调用，用于处理连接请求并返回响应数据。在 `handle_conn` 函数中，可以使用 `asyncio.StreamReader` 和 `asyncio.StreamWriter` 对象来进行网络数据的读取和写入。

### handle_conn

这段代码定义了一个名为`handle_conn`的async函数，用于处理连接。它有两个参数，一个是`reader`，另一个是`writer`，它们分别代表用于读取数据和写入数据的异步流对象。

在函数内部，首先通过`writer.get_extra_info('peername')`获取客户端的地址信息，并输出日志。然后定义了一些变量，包括设备对象`device`，数据长度`total_len`和消息内容`msg`，以及时间戳`time_data`和`time_cmd`。

接下来进入一个无限循环，不断接收和解析客户端发送的数据。通过异步函数`reader.read(65536)`读取不超过65536字节的数据，并等待2秒钟超时。如果读取成功，则将接收到的数据添加到`msg`中，更新`total_len`和`time_data`的值。如果读取超时或者连接异常，则跳出循环。

在读取到数据后，通过解析第一个字节判断数据类型，并调用不同的处理函数进行解析，如`proc_login`、`proc_data_fb`和`proc_data_b1`。在处理完成之后，从`msg`中截取相应的字节，并更新`total_len`的值。

在每次循环中，还会检查是否需要发送命令给设备，以及是否超时未收到数据。如果超时，则断开连接并输出日志。

最后，关闭`writer`并输出日志，表示连接已关闭。

### async def proc_cmd(device):

这段代码是一个异步函数，用于处理设备的命令。首先，函数会调用 `device.mysql.get_cmd(device.id)` 方法获取设备的命令和参数，然后根据命令类型执行相应的操作。其中，如果命令类型为1，表示读取IP地址，会调用 `send_cmd_read_ip` 方法发送读取IP地址的命令，并将返回的结果存储到 buf 变量中；如果命令类型为2，表示设置IP地址和密码，会调用 `send_cmd_set_ip` 方法发送设置IP地址和密码的命令，并将返回的结果存储到 `buf` 变量中；如果命令类型为3，表示进行PLC控制，会调用 `send_plc_control` 方法发送PLC控制命令，并将返回的结果存储到 buf 变量中；如果命令类型为8到12之间，表示设置PLC的频率，会调用 `send_plc_data` 方法发送设置频率的命令，并将返回的结果存储到 `buf` 变量中；如果命令类型大于等于27，表示发送浮点数，会调用 `send_plc_data_float` 方法发送浮点数命令，并将返回的结果存储到 buf 变量中。执行完命令后，函数会调用 `device.mysql.set_cmd(device.id, 0, 0)` 方法将命令清空，再调用 `device.mysql.insert_cmd_log([(device.id, cmd, cmd_value)])` 方法将命令和参数记录到日志中。如果执行过程中出现异常，函数会记录异常信息到日志中。

