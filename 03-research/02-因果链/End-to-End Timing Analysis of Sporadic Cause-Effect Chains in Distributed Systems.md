---
created: 2023-07-21T12:27
updated: 2024-03-27T12:15
tags:
  - 笔记
  - 笔记/文献笔记
---

# End-to-End Timing Analysis of Sporadic Cause-Effect Chains in Distributed Systems

| Title                 | End-to-End Timing Analysis of Sporadic Cause-Effect Chains in Distributed Systems |
| --------------------- | --------------------------------------------------------------------------------- |
| Journal or Conference | ACM Transactions on Embedded Computing Systems                                    |
| Authors               | Marco Dürr; Georg Von Der Brüggen; Kuan-Hsun Chen; Jian-Jia Chen                  |
| Pub. date             | 2019-10-31                                                                        |
| DOI                   | [10/gsfbth](https://doi.org/10/gsfbth)                                            |
| Level                 |                                                                                   |

# End-to-End Timing Analysis of Sporadic Cause-Effect Chains in Distributed Systems

# 分布式系统中偶发因果链的端到端时序分析

## 摘要

<font color='green'>因果链用于定义数据依赖任务的逻辑顺序，与(周期性/偶发性)任务的作业执行顺序无关。</font>分析与因果链相关的最坏情况下的端到端时序行为是嵌入式控制系统中的一个重要问题。例如，现代汽车系统的详细时序特性在汽车电子开放式架构时序扩展中进行了规定。

本文针对分布式系统提出了一种**形式化的端到端时序分析方法**。我们考虑了两个最重要的端到端时序语义，即按键到动作的延迟（the button-to-action delay）(称为==最大反应时间==)和最坏情况下的数据新鲜度（the worst-case data freshness）(称为==最大数据年龄==)。由于考虑了工作激活的偶发行为，我们的贡献是显著的，而文献中的结果大多局限于周期性激活。**证明策略显示了反应时(数据年龄分别为)和即时前向(向后分别为)作业链之间的联系(之前未被探索)**。我们的分析结果在分布式系统中的零星任务激活中占据主导地位，并且评估显示了对合成任务系统以及真实的汽车基准设置的明显改进。

## 1 INTRODUCTION

由于在工业系统中，为了确保软件操作的稳定性和正确的功能性，往往需要时效性，因此端到端延迟等时序属性特别重要。特别是对于需要响应传感器读数的安全关键型任务，期望的控制行为必须在一定的时间间隔内完成/执行。为了对由原因触发的结果做出反应，这可能是外部活动或信息更新，需要循序地执行多个任务。因此，==**因果链**[ 2、3、18]被用来描述完成某一功能的因果过程所需的步骤序列==。因果链是一个线性、有向和无环图，其中每个节点是一个任务，边表示这些任务之间的数据依赖关系。1为了验证过程的时序要求，必须确定从一个原因到一个结果的时间间隔，即所谓的端到端时序分析。

处理因果链描述的数据依赖关系有两种正交的方法。主动方法，如[ 13、25、27]，控制链中后续任务中作业的释放，以确保数据被正确写入和读取。具体来说，廷德尔和Clark [ 27 ]将单处理器和通信系统的最坏情况时序分析相结合，用于分析消息的端到端延迟。或者，在被动方法中，例如[ 2、3、5、11、12、16、24]，因果链中描述的任务的依赖性仅仅解释了数据如何在因果链中的循环任务的作业(任务实例)之间合法地读取(消耗)和写入(产生)。这类返回性任务可以定义为时间触发执行[ 17 ]，分布式环境下的准同步时间触发执行[ 5 ] (即,局部时间触发但全局异步的)，或由经典的周期性或零星实时任务模拟的循环执行[20，21]。在因果链中定义的任务的依赖关系依赖于(分别独立于)周期性/零星任务的作业如何在主动(分别为被动)方法中执行和激活。因此，主动方法的执行依赖于原因的激活，而被动方法的执行是独立的。在本文中，我们考虑了被动方法和零星实时任务。

在分析因果链时，文献中主要考虑两种类型的端到端延迟语义：

==•反应时间==：假设外部活动在时间t更新寄存器。在t时刻开始的最大时间间隔长度是多少，**直到因果链中的每个任务都处理这个更新**?最大反应时间是人体电子学中分析<font color='green'>按键到动作延迟</font>的首选。

> 反应时间（response time）是指系统对请求或事件做出响应的时间，通常是**从请求或事件发生到系统完成处理并返回结果的时间。**在计算机系统中，反应时间通常是指用户与应用程序交互时应用程序响应用户请求所需要的时间。
> 反应时间通常被用来衡量系统的性能和响应速度。对于实时应用程序，例如交易系统、游戏和视频会议应用程序等，反应时间是一个非常重要的指标。较短的反应时间可以提高用户体验和满足实时性能的要求。
> 反应时间的影响因素很多，例如系统的处理能力、网络延迟、磁盘I/O延迟、数据库响应时间等。为了降低反应时间，可以通过提高系统硬件配置、优化系统软件和算法、增加系统缓存、使用负载均衡等方法来提高系统的性能和响应速度。

==•数据年龄==：因果链中**第一个任务读取数据**的时刻与因果链中最**后一个任务完成**处理数据的时刻之间的时间间隔长度?在<font color='green'>控制工程中计算时延</font>需要用到最大数据年龄。

> 数据年龄（data age）是指在计算机系统中数据的最新程度。简而言之，数据年龄就是**从数据产生到计算机系统使用它的时间差。**
> 数据年龄通常被用来评估系统的实时性能和数据的有效性。在实时应用程序中，<u>数据的年龄越小，说明数据越新鲜，系统的实时性能就越好。例如，如果一个传感器的数据年龄比较大，那么它可能已经过时，不能反映当前的状态。</u>在这种情况下，系统就需要更快地获取和处理传感器数据，以确保系统能够及时地响应。
> 数据年龄也可以用于评估数据流的实时性能。在流式数据处理中，数据流的年龄是指从数据流产生到计算机系统处理数据流的时间差。<u>如果数据流的年龄过大，说明系统的处理速度不能满足实时性能的要求。</u>因此，数据年龄是一个重要的指标，可以用于评估系统的实时性能和可靠性。

为保证合理的最坏情况行为，应安全分析最大反应时间和最大数据年龄。为此，2009年，法伊尔塔格等[ 11 ]基于数据的前向可达性和覆盖提出了不同的数据传播端到端延迟语义。他们定义了先到先路径，从先前未被改写的数据开始，直到第一个输出。最长First - to - First路径的间隔长度为最大反应时间。从最后一个非覆盖输入到最后一个输出(包括可能的重复)的路径标记为Last - to - Last。定义最长Last - to - Last路径的区间长度为最大数据年龄。

先到先( First-to-First )和最后到最后( Last-to-First )的数据传播语义概念后来在工业界和学术界得到了广泛的应用，也分别表示为FIFO和LILO，如[ 22、23]。具体而言，时序分析工具SymTA / S [ 26 ]由Luxoft提供了最大反应时间和最大数据年龄分析。对端到端分析的进一步探索包括形式化验证，如[ 24 ]；优化以减少延迟，如[ 2、3]；早期设计分析，如[ 4 ]；语言规范，如[ 12 ]。具体来说，Rajeev等[ 24 ]提出基于时间自动机的较弱形式Calendar Automata生成形式化模型，以验证周期性任务的最大数据年龄和最大反应时间。Kloda等人[ 16 ]针对多处理器平台提出了一种分析周期任务最大反应时间的形式化方法。Forget等[ 12 ]形式化地定义了一种语言来指定端到端约束，并提出了一种通过考虑同时到达的周期性任务的作业级依赖关系来验证其满足性的技术。Klaus等人[ 15 ]提出了一种考虑数据传播延迟的实时系统编译器( RTSC )的扩展。

==我们的贡献：==已知的关于最大数据年龄和最大反应时间的分析要么基于形式化验证，要么基于Davare等[ 9 ] (例如,在文献[ 2-4 ]中使用)的上界。我们考虑一个分**布式系统**，即多个通信电子控制单元( Electronic Control Units，ECUs )，它**执行给定的周期性或偶发性任务集**，并提供以下贡献：

·说明==反应时(数据年龄==分别为)与==即时前向(向后==分别为)==作业链==(在第3节中定义)的==关系==。文献中对数据传播的分析主要集中在<font color='green'>数据新鲜度</font>上，而我们的定义是基于通信语义的。我们认为这是一种自然的方式来定义因果链的时序性质. 

·在第5节中，我们考虑具有指定最小和最大到达时间间隔的零星实时任务，**分析因果链即时前向和后向作业链的最坏情况长度**，解析地支配了Davare等[ 9 ]的分析.这使得我们基于合成系统和真实汽车基准的广泛比较有了显著的改进[ 18 ]。

此外，在第6节中，我们证明了==最大反应时间的上界总是大于最大数据年龄的上界。==

## 2 BACKGROUND AND SYSTEM MODEL

### 2.1 系统模型

我们假设一组电子控制单元( ECU )通过广播总线连接，例如控制区域网络( CAN ) [ 7 ]。我们假设将**一组循环激活的任务T划分到ECU上**，使得**每个任务静态地分配给一个ECU**，所有的任务实例(称为作业)都在该ECU上执行。由于在分析中所有ECU都可以单独考虑，因此我们为单个ECU详细说明任务模型不会不必要地增加解释和符号的复杂性。否则，为了使符号精确，所有参数都需要一个额外的指标来表示相应的ECU。1

![image-20230225102557855](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211355105.png)

| notation                                  | Description                                                  |
| :---------------------------------------- | ------------------------------------------------------------ |
| ${\Gamma}$                                | 单个ECU的任务集合                                            |
| ${\tau_i=(C_i,T^{min}_i,T^{max}_i)}$      | 任务τ i、相关WCET和最小/最大到达间隔时间                     |
| ${T}$                                     | 所有ECU的任务集合                                            |
| $R_i$                                     | τ i的最坏响应时间                                            |
| $B_i$                                     | 最大阻塞时间，τ i被优先级较低的任务wcet阻塞                  |
| $S$                                       | 表示调度集                                                   |
| $E_j$                                     | 一个具体的因果链条                                           |
| $K_j$                                     | 返回Ej中的任务数，即因果链中最后一个任务的索引               |
| $J_{i,\ell}$                              | τ i的第${\ell}$个作业，其中作业是任务的实例                  |
| $a^{j,S,\ell}_i$                          | S中，因果链Ej中第i个任务的第${\ell}$个作业到达时间，即$J_{E_{j(i),\ell}}$ |
| $\delta_i^{j, S, \ell}$                   | S中，因果链Ej中第i个任务的第${\ell}$个作业开始时间，即$J_{E_{j(i),\ell}}$ |
| $f_i^{j, S, \ell}$                        | S中，因果链Ej中第i个任务的第${\ell}$个作业完成时间，即$J_{E_{j(i),\ell}}$ |
| $\overrightarrow{\varsigma^{j, S, \ell}}$ | 前向作业链，与调度集S中的Ej有关，从$\tau_{E_{j(1)}}$的作业$\ell$开始 |
| $\overleftarrow{\varsigma^{j, S, \ell}}$  | 前后作业链，与调度集S中的Ej有关，到$\tau_{E_{j(K_j)}}$的作业$\ell$结束 |

==单个ECU==：在每个ECU上，执行n个偶发(或周期性)任务的集合Γ，即Γ = { τ1，.. τn }。每个任务τ i表示一个可执行文件，该可执行文件循环释放无限数量的作业，由元组( Ci , Tmini , Tmaxi)描述。τ i的最坏情况执行时间( WCET )，即在没有抢占或中断的情况下，任务在分配的ECU上的最长运行时间，记为Ci。**任务τ i的最小和最大到达间隔时间分别用T min i和T max i表示**，其中0 < T min i≤T max i <∞。因此，如果τ i的一个实例在t时刻被释放，那么下一个实例不能在t + T min i时刻之前被释放，不能在t + T max i时刻之后被释放。我们说一个任务**当Tmin i < Tmax i时为偶发，当Tmin i = Tmax i时为周期**。调度器决定每个时刻就绪队列中的作业执行哪个作业。假设待调度任务在每个ECU上以固定优先级分配，其中，如果i < j，则τ i的优先级高于τ j的优先级，$i<j, \forall i, j \in\{1, \ldots, n\}$。该调度**可以是抢占式的也可以是非抢占式的**，由此得到的精确调度称为S。τ i的第$\ell^{t h}$个工件用$J_{i, \ell}$表示。**τ i的最坏响应时间( WCRT )，即所有任务实例到达和完成时间之间的最长时间间隔，用Ri表示**。<u>对于分区多处理器调度，一个任务的WCRT只取决于它分配给的ECU，而不取决于在另一个ECU上执行的作业。</u>

==单处理器WCRT分析==：在**固定优先级抢占式**调度下，任务的WCRT可以通过莱霍茨基等人[ 19 ]提出的**时间需求分析( Time Demand Analysis，TDA )来计算。根据TDA，任务τ i的WCRT是Ri的最小正值，下式成立：**

$R_i=C_i+\sum_{\tau_k \in h p(i)}\left\lceil\frac{R_i}{T_k^{\min }}\right\rceil C_k$

其中hp ( i )是优先级高于τ i的任务集合。TDA可以通过包含最大阻塞时间Bi扩展到非抢占情况，定义为max τ k∈lp ( i ) { Ck }，其中lp ( i )是优先级低于τ i的任务集合，从而得到以下充分检验[ 8 ]：

$R_i=C_i+B_i+\sum_{\tau_k \in h p(i)}\left\lceil\frac{R_i}{T_k^{\min }}\right\rceil C_k$

我们注意到( 2 )式的分析略显悲观，其他形式的WCRT分析也可以适用。详见文献[ 28 ]

![image-20230227093532825](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302270935951.png)

需要注意的是，式( 1 )和式( 2 )只适用于计算小于任务截止时间的WCRT，这里的WCRT为T min i。对于本文的其余部分，我们假设对于T中的**每个任务τ i，其WCRT不超过T min i** .

==通信语义学：==由于我们的目标是分析多个数据依赖作业之间的时序行为，因此需要了解具体的通信模式。==在汽车系统中，数据可以通过直接通信(没有进行一致性检验,即存在数据不一致的风险)、**隐式通信**(在作业开始时读,作业结束时写)== (如图1所示)或逻辑执行时间模型(在预定义的时间点读写,例如周期性任务释放的作业的释放时间) [ 14 ]在作业间传递。我们提出的方法可以通过**考虑具体的读写操作次数来调整以涵盖每个引入的通信语义**。为了简化表述，我们关注隐性沟通，数据总是在工作开始时读取，在工作结束时写入。

### 2.2 因果链

**因果链集Π描述了数据依赖任务执行的因果顺序**。集合Π的一个特定因果链记为Ej，即数据流从一个特定的开始到一个特定的结束任务。它可以描述为一个线性、有向、无环图( DAG )，其中每个节点是一个任务，边表示任务之间的数据依赖关系。记Kj为Ej中的任务数，其中Kj≥2。为了表示简单，我们假设链中没有两个任务是相同的。2函数Ej ( l )返回因果链Ej的第l个任务的索引。例如，令E1 = ( τ4→τ3→τ5)，则E1 ( 1 ) = 4，E1 ( 2 ) = 3，E1 ( 3 ) = 5。因果链受到汽车电子开放式架构时间扩展事件链的启发[ 1 ]，它代表了更一般的功能依赖链。

对于一个链Ej，后续的两个任务可能位于相同的ECU上，也可能位于不同的ECU上。假设分配给同一个ECU的两个任务通过共享内存/寄存器直接通信。如果两个任务被分配给不同的ECU，它们通过其中一个广播总线进行通信。为了方便起见，在我们现在的描述和分析中，我们假设系统只有一条广播总线。否则，只要明确不同ECU上两个给定任务之间的通信使用的是哪种总线，就可以很容易地扩展分析。

==如果链Ej中的两个后续任务位于不同的ECU上，我们将广播总线上的通信建模为总线上的循环通信任务，该任务插入到通信发生点的因果链中。==例如，对于一个链τ 1→τ 2，其中τ 1和τ 2位于不同的ECU上，我们插入一个通信任务τ c，导致因果链τ 1→τc→τ 2。这种通信任务的确切特征取决于广播总线。我们通过以下假设对这种通信进行了抽象：1 ) τ c被偶发地或周期性地释放，并传输所需的数据和可能的一些附加信息，例如，一个消息中可能传输多个值给一组任务；==2 )当τ 1的一个作业完成后，它将所需的值写入一个类似于一个核心中通信的缓冲区中，并且每个τ c的作业在初始化时读取当前值；==3 )当τ c的一个作业完成后，τ 2可以直接读取更新后的值，就像读取一个任务在同一处理器上产生的值一样。

这些抽象是为了简化分析的呈现，这里只需要通信任务的最小和最大到达间隔时间以及WCRT。然而，这些假设通常可以调整，以反映实际系统的通信行为，同时仍然保持被我们的方法分析的可能性。==例如，如果通信任务τ c被τ 1激活，则τ c的到达间隔时间直接取决于τ 1的最坏情况和最好情况响应时间以及τ 1的最小和最大到达间隔时间。==此外，注意到在其他考虑多处理器场景下端到端时序分析的工作中，通常也会采取类似的假设。

在插入所有通信任务后，我们隐含地假设调整Kj和包括通信任务在内的各个任务的指标，以反映更新的顺序。我们考虑广播总线上的==固定优先级非抢占式调度==，这是CAN总线的情况。若已知所有通信任务及其优先级，则可根据式( 2 )计算CAN总线上通信任务的WCRT。否则，可以应用合适的技术来计算WCRT。

### 2.3偶发任务情景

在考虑嵌入式控制系统中的因果链时，似乎可以合理地假设周期性释放的任务实例或基于因果链中先前作业创建的事件释放，即当任务的前一个作业在因果链中完成其执行时释放。然而，**如果释放是由不属于链本身的原因触发**的，那么任务可能会针对特定的因果链零星地释放它们的实例。一方面，**触发频率可能来自一个随时间或动态变化的外部参数**，例如基于曲轴旋转释放的角度同步任务[ 18 ]。另一方面，**一个任务可能是多个因果链的一部分**。在这种情况下，如果一个任务的实例是根据另一个链中一个作业的完成时间发布的，那么这个任务看起来是零星的(从链的角度进行分析)。我们注意到，**我们的分析可以直接应用于(过度)近似周期性任务的最坏情况下的端到端计时行为**，因为周期性任务集是偶发任务集的一个特例，其中所有任务的T min i = T max i。

## 3作业链

Ej的作业链是T中给定周期/偶发任务的特定调度S的数据依赖作业**序列**。注意到任务可能位于不同的ECU上，并且我们插入了通信任务，即S覆盖所有ECU以及广播总线。然而，各个ECU上的调度和广播总线上的调度是相互独立的。基于隐式通信语义S和Ej，我们**考虑两种类型的作业链，即前向和后向作业链**。对于论文的其余部分，我们逐一分析了系统中的每个因果链。为了简化记号，在上下文明确的情况下，我们(在大多数地方)隐式地删除与因果链j、调度S和th作业相关的索引。

> 啥是向前和向后啊

### 3.1.即时前向作业链 Immediate Forward Job Chain

从因果链Ej中第1个任务的第$\ell$个作业开始的即时前向作业链记为 $\overrightarrow{\varsigma^{j, S, \ell}}$，即从$J_{E_{j(1),\ell}}$开始。下面定义即时前向作业链$J_{E_{j(1),\ell}}$，由$J_{E_{j(1),\ell}}$迭代可得，

( 1 )即时前向作业链的第一项作业定义为$J_{E_{j(1),\ell}}$，对于作业$J_{E_{j(1),\ell}}$，我们定义$a_1^{j, S, \ell}$为其到达时间，$\delta_1^{j, S, \ell}$为其开始时间，$f_1^{j, S, \ell}$为其结束时间.

( 2 )对于每个i = 2，3，..，Kj，迭代定义即时前向作业链中的第i个作业。设$J_{E_{j(i),\ell}}$是调度S中$\tau_{E_{j(i)}}$中不早于$f^{j,S,\ell}_{i-1}$开始执行的第一个工件。定义$J_{E_{j(1),\ell}}$是调度S中的第一个工件，它使用因果链Ej中的处理结果。因此$J_{E_{j(i),\ell}}$为即时前向作业链$\overrightarrow{\varsigma^{j, S, \ell}}$中的第i个作业，对于作业$J_{E_{j(i),\ell}}$，定义$a^{j,S,\ell}_{i}$为其到达时间，$\delta_i^{j, S, \ell}$为其开始时间，$f_i^{j, S, \ell}$为其在计划S中的完成时间。

( 3 )定义即时前向作业链长度$\overrightarrow{\varsigma^{j, S, \ell}}$为$f_{K_j}^{j, S, \ell}-a_1^{j, S, \ell}$。

==定义3.1 (最坏情况前向作业链)== .通过考虑所有可能的调度S和所有可能的即时前向作业链，定义了因果链Ej的即时前向作业链( WCFCj )的最坏情况长度，即：

![image-20230225201930237](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211355216.png)

### 3.2即时后向作业链 Immediate Backward Job Chain

以因果链Ej中最后一个任务的第$\ell$个作业为结束点的即时后向作业链记为$\overleftarrow{\varsigma^{j, S, \ell}}$，即以$J_{E_{j(K_j),\ell}}$为结束点。下面定义即时后向作业链$\overleftarrow{\varsigma^{j, S, \ell}}$迭代自$J_{E_{j(K_j),\ell}}$

( 1 )即时后向作业链的最后一个作业定义为$J_{E_{j(K_j),\ell}}$，对于作业$J_{E_{j(K_j),\ell}}$，定义$a^{j,S,\ell}_{K_j}$为其到达时间，$\delta_{K_j}^{j, S, \ell}$为其开始时间，$f^{j,S,\ell}_{K_j}$为其结束时间。

( 2 )对于每个i = Kj-1，Kj-2，..，1，迭代地定义即时后向作业链中的第i个作业。设$J_{E_{j(i),\ell}}$，是$\tau_{E_{j(i)}}$的最后一个工件，它的执行不晚于调度S中后向作业链中下一个工件的开始时间 $\delta_{i+1}^{j, S, \ell}$ .这个工件$J_{E_{j(i),\ell}}$，定义为调度S中的最后一个工件，它为因果链Ej的下一个工件提供处理结果.因此，$J_{E_{j(i),\ell}}$，为即时后向作业链$\overleftarrow{\varsigma^{j, S, \ell}}$中的第i个作业对于作业$J_{E_{j(i),\ell}}$，定义$a^{j,S,\ell}_{i}$为其到达时间，$\delta_i^{j, S, \ell}$为其开始时间，$f_i^{j, S, \ell}$为其在计划S中的完成时间。

(3)定义即时后向作业链$\overleftarrow{\varsigma^{j, S, \ell}}$的长度为$f_{K_j}^{j, S, \ell}-a_1^{j, S, \ell}$。可能不存在以作业$J_{E_{j(K_j),\ell}}$结束的即时后向作业链，即无法定义$a^{j,S,\ell}_{1}$。由于我们感兴趣的是最坏情况下的长度，我们简单地将$a^{j,S,\ell}_{1}$设置为$f_{K_j}^{j, S, \ell}$，即作业链的长度设置为0。

==定义3.2（最坏情况下的反向作业链）==。因果链Ej的即时向后作业链（WCBCj）的最坏情况长度是通过考虑所有可能的调度S和所有可能的即时向后任务链（即。，

![image-20230225222452960](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302252224051.png)

### 3.3作业链示例

![image-20230225212807816](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302252128996.png)

图2 .调度S前向和后向作业链示例。链$\varsigma^{j, S, \ell}$的记号表示调度S中的因果链Ej，从作业$J_{i,\ell}$开始，即任务$\tau_{E_{j(1)}}$的第$\ell$个作业。

图2描述了直接向前和向后作业链的示例。显示的调度S由两个任务组成：τ1=（1，5，5）和τ2=（1，3，3）。假设因果链E1=（τ1→τ2）正在分析中，因此它显示了两个直接向前的工作链$\overrightarrow{\varsigma^{1, S, 1}}$=（J1,1，J2,2）和$\overrightarrow{\varsigma^{1, S, 2}}$=（J1,2，J2,3）。此外，准确地说，有三个直接向后的工作链$\overleftarrow{\varsigma^{1, S, 2}}$=（J1,1，J2.2），$\overleftarrow{\varsigma^{1, S, 3}}$=（J1,2，J2,3），和$\overleftarrow{\varsigma^{1, S, 4}}$=（J1,2，J2,4）。对于该计划，不可能构建以作业J2,1结束的直接向后作业链。这意味着作业J2,1不会为因果链E1产生任何有意义的输出，因此被忽略。

## 4问题定义：端到端延迟语义

我们分析==从原因到结果的最坏情况时间间隔，即从因果链中第一个任务开始执行的时刻到因果链中最后一个任务完成的时间点的时间间隔。==有必要对因果链进行端到端延迟分析，以确保最坏情况时间间隔的上限，并验证基础程序的端到端定时要求。两种端到端延迟语义特别有趣：Feiertag等人引入的最大数据年龄和最大反应时间[11]。

**==最大数据年限（Last to Last）==**是任务开始采样值的时刻到系统生成与该采样相关的输出的最后一个时间点之间的时间间隔。因此，控制工程师非常关注这种语义。==最坏情况下立即向后作业链WCBCj（定义3.2）的长度对应于最大数据年限。==

==定义4.1（最大数据年龄）==。调度S中因果链Ej的最大数据年龄小于或等于最坏情况下的立即向后作业链长度WCBCj。

在人体电子学中，==最长反应时间（也称为“先到先”）==很有意义。该语义是指系统对外部原因的第一次响应，例如按钮按下或寄存器的值更改。因此，需要分析原因的最坏情况发生与系统的第一个相应输出之间的时间间隔。为了确定因果链的最大反应时间，将最坏情况下的中间正向作业链长度延长因果链中第一个任务的最大到达时间。此扩展是必要的，因为原因可以在作业开始执行后立即到达，从而由任务的下一个作业处理原因。

==定义4.2（最大反应时间）==。表S中因果链Ej的反应时间小于或等于

![image-20230225225708024](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211355269.png)

> 向前作业链长度+因果链第一个任务的最大到达时间
>
> **为什么向前要考虑到达时间，向后不需要** 

![image-20230225223517182](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302252235319.png)

图3。不同语义的数据传播路径。

图3描述了各种端到端语义的示例。所示的精确时间表S包括三个任务，τ1、τ2和τ3，具有以下性质：Ci=0.5τi、T min 1,3=T max 1,3=2和T min 2=T max2=6。底部呈现的时间间隔的公式涉及覆盖效应，例如，

**Last to Last描述最后一个未覆盖的输入到最后产生的输出之间的时间间隔**，

**First to First与先前未覆盖的输入到第一个生成的输出有关。**

此外，最坏情况下的前向和后向工作链$\overrightarrow{\varsigma^{1, S, 2}}$和$\overleftarrow{\varsigma^{1, S, 3}}$标记在顶部。

最大数据年龄语义对应最坏情况的反向作业链$\overleftarrow{\varsigma^{1, S, 3}}$的定义。

最坏的未来工作链$\overrightarrow{\varsigma^{1, S, 2}}$表示因果链中第一个任务的第一个作业与第一个相应输出之间的时间间隔。因此，将最坏情况前向作业链扩展因果链中第一任务的最大到达时间，==导致先前未覆盖作业到第一相关输出之间的时间间隔？？？==，该时间间隔被定义为最大反应时间。

Davare等人[9]通过==对因果链中所有任务的最坏响应时间和周期求和，提供了最大数据年龄和最大反应时间的上限==，如等式（5）所示。

![image-20230226092918916](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302260929032.png)

我们注意到边界Davare可能是微不足道的，但它从未被正式证明过**。当（1）周期性任务τEj（i+1）的作业尽可能早地完成，但数据在作业开始后立即由任务τEj（i）更新/写入，以及（2）随后的τEj的作业（i+1）遭受其WCRT时，就会发生这种最坏情况。**这种分析端到端延迟的方法是悲观的，因为允许任务在最坏的情况下释放两个连续的作业。然而，如果任务集中的任务是严格周期性的，并且它们的第一个任务的发布时间固定（也称为阶段或偏移），则这可能是不可能的。

手动阀

> 最坏情况？？

表2显示了针对最大反应时间和最大数据年龄的与图3示例相关的端到端延迟分析的结果。我们将boundDavare与第5节中提出的分析边界以及图中所示的精确值进行了比较。这表明BoundDavre和Boundour之间存在显著差距。

![image-20230226095105774](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302260951871.png)

据我们所知，目前还没有正式的端到端时序分析来区分零星任务的最大数据年龄和最大反应时间。在下面的部分中，我们利用以前定义的作业链来明确分析这两种端到端语义。此外，还证明了分析方法的正确性，从而可以进行可理解的端到端分析。

## 5零星任务系统的因果链分析

在本节中，我们将解释多个零星任务系统的最大反应时间和最大数据年龄是如何上界的。这是通过考虑因果链Ej产生的作业链来实现的。请注意，对于本节的其余部分，$a_i^{j, S, \ell}$、$\delta_i^{j, S, \ell}$和$f_i^{j, S, \ell}$分别表示作业$J_{E_{j(i),\ell}}$的到达、开始和结束时间，这是因果链Ej（i）中的第i个作业。

### 5.1最长反应时间

通过查看因果链中的任意两个连续任务，得出最大反应时间的上限，其中相关作业的释放时间之间的差距在任何可能的前向作业链中都是有界的。我们从一个特定的ECU开始，并将结果扩展到多个通信ECU。为了便于理解所提供的证明，图4中显示了部分时间表。

![image-20230226165502077|525](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261655204.png)

图4。最大反应时间延迟分析中两种考虑情景的可视化。

==引理5.1 .==假设Γ在一个ECU上执行，在==单处理器抢占/非抢占固定优先级调度==下，任务τ k的Rk对Γ中的每个任务τ k不超过T min k。那么，对于任意产生的调度S，$\ell$= 1，2，..，且i = 1，2，..，Kj-1，

![image-20230226104408795](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261044906.png)

其中[Ej（i）>Ej（i+1）]是艾弗森括号，**当因果链Ej中的第i+1个任务具有比因果链中的第i个任务更高的优先级时，该括号为1，否则为0。**

​     

引理5.1允许因果链中的任务具有任意周期。具体地，考虑过采样和欠采样，并且对于因果链中的两个连续任务，第二任务可能具有比第一任务更高的优先级。

证明让$J_{E_{j(i),p}}$和$J_{E_{j(i+1),q}}$是直接向前作业链中的第i个和第i+1个作业$\overrightarrow{\varsigma^{j, S, \ell}}$在同一ECU上执行。有两种情况需要考虑：（1）$J_{E_{j(i+1),q}}$在$J_{E_{j(i),p}}$之前到达，在S中结束，和（2）$J_{E_{j(i+1),q}}$不在之前到达，在S中完成。由于j、S和$\ell$在引理的陈述中是固定的，为了表示简单，我们删除了这些索引，即ai和fi分别代表$a_i^{j, S, \ell}$和$f_i^{j, S, \ell}$

情况1:ai+1＜fi，即JEj（i+1），q在JEj（i），p完成之前到达。由于JEj（i），p的最坏响应时间最多为REji，≤T min Eji和ai+1 <fi，我们知道

![image-20230226162130775](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261621892.png)

情况2：ai+1≥fi，即JEj（i+1），q在JEj（i），p结束时或之后到达。通过我们假设REj（i+1）≤T min Ej（i+1），必须存在另一个作业JEj（i+1）q−1，该作业在作业JEj（i+1）q-1之前到达，即作业JEj（i+1）q−1存在。根据直接向前作业链的定义，作业JEj（i+1），q−1不能在JEj（i），p完成时或之后到达；否则，作业JEj（i+1），q−1应位于直接向前作业链$\overrightarrow{\varsigma^{j, S, \ell}}$代替作业JEj（i+1），q。设为作业JEj的到达时间（i+1），q−1。通过以上讨论，r<fi。此外，通过定义任务的最大到达时间，我们知道r≥ai+1−T max Ej（i+1）。通过这两个不等式，我们得到

![image-20230226162907222](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261629307.png)

当Ej（i）<Ej（i+1）时，等式（8）中的不等式可以得到改善，即任务τEj（i）的优先级高于任务τEj（i+1）。如果这种情况成立，则作业JEj（i+1），q−1的到达时间r必须小于作业JEj（i），p的到达时间，即r＜ai。否则，根据抢占式固定优先级调度策略，调度S中JEj（i+1），q−1的开始时间必须在fi之后，这与直接前向作业链的定义相矛盾。因此，通过r<ai和r≥ai+1−T max Ej（i+1），我们有

![image-20230226163116741](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261631808.png)

==引理5.2==。让JEj（i），p和JEj（i+1），q是直接向前作业链中的第i个和第i+1个作业在==不同的ECU上执行==。然后，需要扩展方程（6），使得：

![image-20230226163247751](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261632842.png)

![image-20230226163255907](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261632977.png)

**换言之，当因果链Ej中的第（i+1）个任务具有更高的优先级或在与因果链中的第i个任务不同的ECU上执行时，艾弗森括号[P]为1，否则为0。**

证据。这是从引理5.1开始的，因为方程(7)和(8)是成立的。方程(9)中的改进不能被应用，因此被扩展，使我们达到方程(10)中的不等式。

这允许限制WCFCj的长度。

定理5.3。假设对于Γ中的每个任务τk，任务τk的Rk不大于T min k。对于因果链Ej

![image-20230226163458970](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261634041.png)

![image-20230226163614760](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261636850.png)

这导致最大反应时间的上限。

定理5.4。假设对于Γ中的每个任务τk，任务τk的最坏响应时间Rk不大于T min k。因果链Ej的最大反应时间上限为

![image-20230226163642464](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261636542.png)

证据这是由于定义4.2、定理5.3以及观察到，τEj（1）的作业开始立即向前作业链的原因与释放时刻之间的间隔由T max Ej（1）限定。

注意，如果因果链中的任务以优先级递减的顺序出现并在同一ECU上执行，则艾弗森括号始终为0，这直接给出了以下推论
。

推论5.5。假设对于Γ中的每个任务τk，任务τk的最坏响应时间Rk不大于T min k。如果因果链中的任务按优先级降序排列并在同一ECU上执行，因果链Ej的最大反应时间上限为

![image-20230226163855619](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302261638694.png)

当艾弗森括号始终为1时，上述推论的反面实际上是Davare等人在方程（5）中的分析。[9]。

定理5.6。定理5.4中的分析在分析上主导了Davare等人的等式（5）中的分析。[9]。

证明。当[p]始终为1时j = 1，2，...，kj -1时，定理5.4中的上限正好是公式（5）的右侧。由于这是我们在定理5.4分析中最糟糕的情况，因此我们的分析逐渐占主导地位（5）。

### 5.2最大数据年龄

在确定了最坏情况下的反应时间之后，我们现在查看最大数据年龄，该年龄基于直接向后的作业链。同样，我们从任务在同一个ECU上的情况开始。为了便于理解所提供的证明，图5中显示了部分时间表。

![image-20230226203600923](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262036037.png)

图5。最大数据年龄时间延迟分析中两种考虑场景的可视化。

引理5.7 .假设Γ在一个ECU上执行，在单处理器抢占/非抢占固定优先级调度下，任务τ k的Rk对Γ中的每个任务τ k不超过T min k- 1，成立：

![image-20230226203543312](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262035428.png)

证据证明与引理5.1相似，但方向相反。为了简化表示，我们删除了j、S和-，即ai、δi和fi分别代表aj、S、-i、δj、S、-i和f j、S，-i。假设JEj（i），p和JEj（i+1），q是直接向后作业链中的第i个和第i+1个作业，在同一ECU上执行。有两种情况需要考虑：（1）JEj（i+1），q在JEj（i），p之前到达在计划S中完成，以及（2）JEj（i+1），q不在JEj，p之前到达在计划S完成。由于S、l和j在引理的陈述中是固定的，为了表示的简单，我们删除了这些索引。

情况1:ai+1＜fi，即JEj（i+1），q在JEj（i），p完成之前到达。因此，等式（7）成立

情况2：ai+1≥fi，即JEj（i+1）q在JEj（i）p结束时或之后到达。通过我们的假设，每个任务以有界的最大到达间隔时间释放其作业，即JEj（i）p+1存在之后，必须存在另一个作业JEjip+1。根据立即数的定义向后作业链，作业JEj（i）p+1不能在JEj（i+1）q开始执行之前完成；否则，作业JEj（i）p+1应位于直接向后作业链中代替作业JEj（i）p，因为JEj（i）p+1比JEj（i）p晚完成在JEj（i+1）q之前完成开始执行。设r为调度S中作业JEj（i）p+1的到达时间。通过以上讨论，r+REji≥δi+1≥ai+1，即作业JEjp+1的到达时间加上作业的最坏响应时间必须不小于δi+1≤ai+1。此外，通过最大到达时间的定义，我们知道r≤ai+T max Ej（i）。结合这两个不等式，我们得到

![image-20230226210609320](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262106403.png)

当Ej（i）<Ej（i+1）时，等式（14）中的不等式可以得到改善==，**即任务τEj（i）的优先级高于任务τEj（i+1）**。如果这成立，则作业JEj（i）p+1的到达时间必须晚于作业JEjq的到达时间，即r>ai+1；否则，根据抢占式固定优先级调度策略，调度S中JEj（i）p+1的完成时间必须早于δi，这与直接向后作业链的定义相矛盾。==因此，通过r＞ai+1且r≤ai+T max Ej（i），我们得到

![image-20230226210732268](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262107338.png)

这两种情况以及假设REj（i）≤T max Eji

![image-20230226210828547](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262108633.png)

<span style="background:#FFDBBB;">引理5.8。假设JEj（i）p和JEj（i+1）q是直接向后作业链中的第i个和第i+1个作业在不同的ECU上执行。然后，方程（13）需要扩展为：</span>

![image-20230226210901253](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262109328.png)

![image-20230226210907326](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262109393.png)

**换言之，当因果链Ej中的第（i+1）个任务具有更高的优先级或在与因果链中的第i个任务不同的ECU上执行时，艾弗森括号[P]为1，否则为0。**

证明。这是从引理5.7的，因为等式（7）和（14）保持。方程（15）的改进无法应用，因此可以扩展，从而使我们达到等式（17）中的不平等。

==即时向后作业链中两个作业的释放时间之间的差距导致即时向后作业链条（WCBCj）的最坏情况长度上限。==

定理5.9。对于Γ中的每个任务τk，任务τk的Rk不大于T min k。对于因果链Ej，

![image-20230226211125006](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262111077.png)

证据设JEj（Kj）l是τEj（Kj）的第一个作业，它可以在调度S中定义有效的立即向后作业链

![image-20230226211203534](https://cdn.jsdelivr.net/gh/wsm6636/pic/202302262112613.png)

其中≤是由于引理5.8.

定理5.10。假设对于Γ中的每个任务τk，任务τk的Rk不大于T min k。因果链Ej的最大数据年龄由等式（18）的右侧上限。证据这是由于定义4.1和定理5.9。

## 6反应时间与数据年龄的关系

在本节中，我们将更仔细地研究最大反应时间和最大数据年龄之间的关系。我们显示了最大数据年龄和最大响应时间之间的严格关系，即==**最大反应时间始终是最大数据年龄的上限**。==首先，我们认为这种关系适用于我们在第5节中提供的边界，然后我们考虑一般情况。

定理6.1。对于因果链Ej，定理5.4中的最大反应时间上限是定理5.10中的最大数据年龄上限的严格上限。

我们考虑从作业JEj（1）p+1开始的直接前向作业链j，S，p+1。我们声称，τEj（i）在直接向前作业链中的作业j，S，p+1必须在直接向后作业链j，S，l中任务τEj（i）的作业之后到达。如果这一点成立，则最大反应时间至少为T max Ej（1）加上直接向前作业链的长度j，S，p+1，严格大于f j，S、Kj−aj，S，1，即Ej的最大数据年龄。

我们现在用矛盾来证明上述主张。对于矛盾，假设索引k是最小整数，其中τEj（k）的作业在直接向前作业链中ςj，S，p+1不晚于直接向后作业链中任务τEj（k）的作业到达ςj，S，。回想第3节中对直接向后作业链的定义。立即向后作业链是基于迭代搜索链中先前任务的作业而构建的，这些任务在链中下一个任务的作业开始之前作为最后一个作业完成。因此←ςj，S，-对于i=k−1，k−2，。。。，1强制执行直接向后作业链←ςj，S，-中的作业τEj（i）不早于任务τEj（i）在直接向前作业链中的作业到达−−−−→ςj，S，p+1。也就是说，即时向后作业链将τEj（1）的作业定义为即时向后作业链条中的第一个作业，该作业不早于JEj1，p+1（即，晚于作业JEj1，p）到达。这与JEj（1）p是直接向后作业链中的第一个作业的条件相矛盾。因此，定理得到了证明。

## 7 EVALUATION

为了评估第5节中导出的方法，我们将最大反应时间和最大数据年龄的结果值与Davare等人的上限进行比较。[9]。注意，公式（5）主要针对[9]中的最大反应时间进行讨论，但也可用于计算最大数据年龄。我们报告了精度增益，定义为boundDavare−boundDavors boundDafare·100，其中boundDawars是最大反应时间的定理5.4或最大数据年龄的定理5.10，而boundDaware是公式（5）的结果。

在第7.1小节中，我们根据Kramer等人提供的真实世界汽车基准评估精度增益。[18]。该基准提出了一种生成具有真实世界汽车软件系统实际应用特性的任务集的方法。此外，在第7.2小节中，我们通过根据UUnifast方法评估随机任务集来评估更广泛的嵌入式实时系统[6]。

## 8结论

在本文中，我们分析了分布式系统中因果链数据传播的最大反应时间和最大数据年龄。我们的分析基于直接向前和向后的工作链，在我们看来，这比文献中的数据新鲜度观点更自然。我们的分析结果主导了Davare等人的最新技术。[9]，在我们的评估中可以观察到显著的改进





















***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考

Referred in <a href="zotero://note/u/HWG3PU5P/?ignore=1&#x26;line=-1" rel="noopener noreferrer nofollow" zhref="zotero://note/u/HWG3PU5P/?ignore=1&#x26;line=-1" ztype="znotelink" class="internal-link">cause-effect chain</a>
