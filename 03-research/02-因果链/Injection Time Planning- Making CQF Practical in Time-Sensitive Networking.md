---
created: 2023-07-21T12:27
updated: 2024-03-26T23:33
tags:
  - 笔记
  - 笔记/文献笔记
---

# Injection Time Planning: Making CQF Practical in Time-Sensitive Networking

| Title                 | Injection Time Planning: Making CQF Practical in Time-Sensitive Networking |
| --------------------- | -------------------------------------------------------------------------- |
| Journal or Conference | IEEE INFOCOM 2020 - IEEE Conference on Computer Communications             |
| Authors               | Jinli Yan; Wei Quan; Xuyan Jiang; Zhigang Sun                              |
| Pub. date             | 7/2020                                                                     |
| DOI                   | [10/ghkkxx](https://doi.org/10/ghkkxx)                                     |
| Level                 |                                                                            |

# Injection Time Planning: Making CQF Practical in Time-Sensitive Networking——注入时间规划：在时间敏感型网络中实现CQF

## 问题陈述

![image-20230405153300664](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401464.png)

### A.ITP中的资源视图

在基于CQF的数据平面的基础上，提取了资源视图，将算法设计与图4中的底层复杂实现分离。主要模块描述如下。

·拓扑学。它描述了所有节点，包括交换机、终端系统及其连接性。

·流量功能。给出了时间敏感流的基本属性，如来源、目的地、周期等。

·可分配资源。它显示由空间(交换机和端口)和时间(时隙)标识的每个队列资源块的状态。

·可配置资源。它表示将安装到数据平面中的配置信息。根据我们的观察，它主要包括单流喷射时隙和全局时隙大小。

·算法实例。基于ITP机制可以实现不同的算法实例。必须满足下一小节中的基本约束。此外，用户还可以添加与应用相关的约束。

整个工作流程如下所述。首先，将拓扑和流特征加载到算法中(步骤1)。然后，通过一个基于ITP的算法实例，对多约束条件下的每个流的喷射时隙进行了规划。在此过程中，一旦映射了流，则更新可分配资源的状态(步骤2)。最后，输出合成结果以更新可配置资源(步骤3)，并将这些配置发布到数据平面中的主机和交换机(步骤4)。

### B.问题形式化

我们将物理拓扑抽象为图G={V，E}。这里，V是一组顶点，包括分别表示为S和H的交换机和主机。E表示连接任意两个顶点的一组有向边。

由于交换机中的每个端口都有独占的CQF队列，因此路径信息应该包括每一跳中的输出端口。在本文中，由于所有可分配的队列资源都在交换机中，因此该路径仅用流所经过的交换节点来描述。(1)描绘了整个路径，其中S(1，0)和S(j，k)分别是第一个和最后一个交换机信息。**J和k分别为交换机(从1开始)和端口(从0开始)的序列号。**

![image-20230405153950364](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401290.png)

可分配资源由多个**队列资源块**组成。每个队列块的状态被描述为$Q^{T(t)}_{S(j，k)}(free，used)$，其中T(t)是时隙的序号，空闲和已用分别是当前空闲和已占用**缓冲器**的数目。

![image-20230405154206387](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401876.png)

这里F是时间触发流的集合，流的数量是n。每个流的特征由源主机、目的主机、数据包号、周期和截止期组成。**注入时隙的路径信息和可配置偏移量是每流粒度的**。因此，这两个因素被附加到流动特征中，如公式所示。(2)。

> 流=数据包？

### C.ITP中的核心约束

该机制在多个约束条件下对注入时隙进行约束，以保证映射的有效性。在这里，我们说明了与特定应用程序无关的四个基本约束。用户可以根据自己的要求添加额外的限制。

![image-20230405155901293](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401493.png)

由于时间敏感流是以周期性模式传输的，映射算法需要检查分配策略是否满足调度周期内的资源约束。在实际场景中，流的周期因应用程序的不同而不同。这里，**调度周期等于等式中所有流周期的最小公倍数**(3)。

==**1)偏移量约束：**==

偏移量约束要求**注塑时隙的偏移量小于流周期**。例如，流的第一个周期中的分组在第二个周期中生成的分组之前被转发。造成这种限制的原因有两个。首先，如果不满足这一约束，多个周期的报文将同时占用主机中有限的网卡(NIC)存储资源。其次，该约束将偏移量限制在合理的范围内，从而减小了每流偏移量的搜索空间。其中，**slotcycle是时隙的大小。**

![image-20230405160243535](https://cdn.jsdelivr.net/gh/wsm6636/pic/202304051602596.png)

==**2)时隙约束：**==

该约束主要描述时隙的上下界。在本文中，**偏移量的粒度是一个时隙**。这意味着所有的时间段都应该可以被预定义的时隙整除。因此，==最大时隙是公式中设置的周期的最大公约数。==(5)。

![image-20230405163151264](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401039.png)

==对于最小时隙，需要保证CQF队列中的所有分组在Eq(6)中的相同时隙内从上游节点传输到下游节点。。==

![image-20230405163239360](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401503.png)

其中，QueueSize是每个队列可以容纳的最大数据包量，MTU是最大数据包长度。B是链路带宽，HopDelay是交换机的内部处理延迟和传播延迟，syncprec是时钟同步精度。

==**3)接收窗口约束：**==

该约束是检查报文是否在正确的窗口内到达每个交换机。理论上，如果时隙大小不小于约束2中定义的最小时隙，则所有分组都满足该约束。**每一跳中每个分组的接收时隙**用公式表示。(7)。

![image-20230405164350461](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401613.png)

hop(Sj，fi)从0开始并且指示哪跳交换机j在流i的路径中。

> R，在第几个slot被接收，=发送的slot（从0 开始第几个，offset） +  跳数（从0开始）

如果该流被成功调度，则在Eq(8)中计算接收窗口的上界URW和下界LRW。

![image-20230405165401235](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401069.png)

**4)最后期限约束**：

在ITP中，**延迟流量的注入时隙会影响到达目的地的时间。**此约束对于限制每个流的所有数据包在指定的截止日期之前到达非常重要。其中Hopnum(Fi)是流i的路径中的开关的数目。

![image-20230405165743816](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401463.png)

**5)队列资源约束**：

将队列资源按照[Switch、Port、Slot]的组合拆分成多个队列资源块。每个队列资源块的使用量不应超过队列长度。

首先，我们建立了流和资源块之间的映射。这里，第t个时隙的第j个交换机的第k个端口中的资源块被表示为q T(T)S(j，k)。Sj.Pnum是第j个交换机中的端口数。如果流占用资源块，则映射值M(fi，qT(T)S(j，k))为1，如公式所示。(10)。否则，它为0。

其中m是图中的开关数量。由于调度周期是所有流周期中的最小公倍数，因此一个流可以从主机传输多次。α表示数据包所属的周期。用来计算流量在调度周期内所占的时隙。

在某些情况下，在第一个调度周期中转发的分组不能在第二个时隙周期开始之前到达目的主机。因此，第一个调度周期中的初始资源状态不同于第二个调度周期中的初始资源状态。为了解决这个问题，方程中的mod算子将分组在第一个调度周期中占用的时隙限制在调度周期内。(10)。

![image-20230405170516227](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401731.png)

基于所构造的映射，资源约束被形式化地表示为EQ。(11)。

![image-20230405170523990](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401201.png)

我们用C(I)来表示第i个流是否可以映射.如果流映射成功，则C(I)为1。否则，它为0。在本文中，我们的优化目标是最大化映射流的数量，其表示为：

![image-20230405171006591](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401842.png)

## 算法设计

在这一部分中，我们首先分析了问题的规模和搜索算法的选择。然后利用领域相关知识进行优化，在映射质量和搜索开销之间取得较好的折衷

将时间触发流映射到底层队列资源的计算等价于装箱问题，并且是NP难的[8]。搜索空间是∏n−1i=0fi周期时隙周期，其中n是流的数量。为了在得到近似最优解的同时降低算法的复杂度，我们选择了计算密集型启发式算法来解决这一问题。

***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考

Referred in <a href="zotero://note/u/HWG3PU5P/?ignore=1&#x26;line=-1" rel="noopener noreferrer nofollow" zhref="zotero://note/u/HWG3PU5P/?ignore=1&#x26;line=-1" ztype="znotelink" class="internal-link">cause-effect chain</a>
