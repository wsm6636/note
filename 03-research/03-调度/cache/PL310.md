---
created: 2023-07-08T20:33
updated: 2024-03-26T23:34
tags:
  - 笔记
  - 笔记/学习笔记
---

# PL310

## Lockdown by Master (LbM)

在每个任务τk完成作业或被抢占时刷新分配给它的分区[25]

 

保证了并发运行任务之间的缓存隔离（因为没有任务可以使用另一个任务的保留缓存分区

 

### rt_param

当前使用的分区集和以前使用的分区集

### Cpu_entry

preempting核心是否通过缓存被抢占

 

CP位图是指示缓存分区是否已锁定（即，为某些任务保留）的位图

 

### 锁：

一个用于释放队列；一个用于就绪队列、RT上下文和CP位图；一个用于CPtoTask映射和缓存控制器的寄存器。

 

### 任务调度或链接到cpu时：

##### Check_for_preemption

1. 下一步可以执行的最高优先级就绪任务、执行任务的核心、为任务保留的缓存分区以及要抢占的当前正在运行的任务。然后，调度程序继续执行下一个最高优先级的就绪任务，直到无法调度更多的就绪任务。

 

P1上的调度程序决定抢占当前在P0和P2上运行的任务（分别是τi和τj），并在P0上调度就绪任务（例如τk）。

 

2. 更新CP位图以反映新锁定的缓存分区，并更新抢占核心和将运行计划任务的核心的RT上下文。

 

 

在图1中，P1的调度程序通过取消标记分配给τi和τj的缓存分区，然后标记将保留给τk的分区来修改CP位图。此外，它将P0的链接任务（即下一步要执行的实时任务）更新为τk，P2的链接任务更新为NULL，P2的preempting更新为true（表示P2仅通过缓存被抢占）。

 

3. 将处理器间中断（IPI）发送到每个抢占核心和将运行计划任务的每个核心，以通知抢占核心抢占其当前运行的任务，并通知计划核心执行其链接的任务（例如，P0抢占τI和运行τk，P2抢占τj）。当核心接收到上述IPI时，将调用该核心上的调度程序，并将执行以下三个步骤：

 

4. 将链接任务（在步骤2中配置）移动到core，并将core的计划任务更新为链接任务。（如果链接的任务为空，调度程序将选择一个非实时任务在内核上执行。我们假设非实时任务不会干扰实时任务。）

 

5. 确定为链接任务保留的哪些缓存分区应该刷新（即，如果被其他任务使用），刷新这些分区，并更新CPtoTask映射以反映分区到任务的新映射。

 

6. 开始执行链接的任务。

 