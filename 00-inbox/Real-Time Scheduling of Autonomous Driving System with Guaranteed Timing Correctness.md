---
tags:
  - 笔记
  - 笔记/文献笔记
  - 待归档
created: 2024-03-27T18:55
updated: 2024-05-08T16:28
status:
  - ing
---
# Real-Time Scheduling of Autonomous Driving System with Guaranteed Timing Correctness

**TitleTranslation:** 保证时序正确性的自动驾驶系统实时调度
**Journal or Conference:** 2023 IEEE 29th Real-Time and Embedded Technology and Applications Symposium (RTAS)
**Authors:** JinghaoSun, KailuDuan, XishengLi, NanGuan, ZhishanGuo, QingxuDeng, GuozhenTan
**Pub.date:** 2023-05
**DOI:** 10.1109/RTAS58335.2023.00022
**tags:** 
**zoterolink:** [zotero](zotero://select/library/items/ZZ9936VR)

# 摘要

在自动驾驶（AD）系统中，不同激活率的任务之间存在复杂的数据依赖关系，使得分析系统的实时行为变得非常困难。本文将 AD 系统表述为多速率 DAG，并提出了一个集成框架来共同分析多速率 DAG 中各个任务的可调度性和任务链的端到端延迟。整数线性规划 (ILP) 技术的开发是为了指导如何删除冗余工作负载，以增加满足时序要求的机会。本文提出了一种分析框架，该框架实现了以迭代方式创建、分析和完善 AD 系统设计的自动化过程，即上一次迭代的分析结果为下一次迭代中重新设计 AD 系统提供了有价值的指导。进行实验来评估我们的分析方法的性能。


# 一、简介
在自动驾驶（AD）系统中，大量的安全和控制功能由不同供应商开发，并最终由制造商集成到同一目标平台上。这些功能通常以数据相关的周期性任务的形式实现，这些任务以不同的速率激活，并需要在给定的时序约束内相互同步。为了简化自动驾驶系统的开发，汽车工程标准放宽了数据相关任务之间的同步。放松是通过隐式寄存器通信（最后是最好的语义）完成的，其中任务从共享缓冲区空间（例如全局变量）读取最新数据并将其输出独立于其他任务写入缓冲区[1] - [3]。这种语义已经在许多现有系统中得到应用，例如 AUTOSAR [4] 的隐式通信模型和机器人操作系统（ROS）[5] 中的发布者-订阅者模型。

尽管宽松的数据同步机制简化了分布式开发，但它很少考虑现代汽车领域严格的时序要求。 AD系统中主要有两种类型的实时约束，如下所述。

为了适应传统的实时操作系统（RTOS），AD系统的每个任务都被设计有一个期限。 AD系统中所有任务的基本时序要求是在截止日期之前完成执行，在这种情况下，AD任务被称为可调度的。对于保证AD任务的可调度性至关重要，这样AD系统的网络部分才能始终正确工作而不会出现致命错误。

除了传统的截止日期约束之外，许多 AD 应用程序还通过一系列（周期性）任务对数据传播施加新型的端到端延迟约束，这些任务共同协作以实现特定的系统功能，称为任务链或任务链。因果链[6]。由于与物理世界的紧密联系，AD系统对整个任务链中使用的输入数据的“新鲜度”以及任务链的输入数据对该链的输出产生影响的时间高度敏感。

保证AD系统实时约束的一个重要工具，特别是如上所述的网络部分和物理部分，是时序分析，这是本文的主要关注点。

AD系统的时序分析不仅要保证每个单独任务的可调度性，还要限制关键因果链的端到端延迟，这并非小事。现有的调度和时序分析方法要么无法应用，要么效率低下。更具体地说，传统的实时技术是为可调度性分析而开发的，但即使所有任务都在截止日期前完成，它也无法限制端到端延迟。最近的工作提出了几种限制 AD 系统端到端延迟的方法，但所有这些方法都仅限于所有任务都满足其截止日期的强假设 [3]、[7]、[8]。在当前的分析方法下，AD任务的可调度性和端到端延迟约束的可满足性被视为两个独立的问题。因此，AD系统的网络部分和物理部分被迫分开设计和分析。<span style="color:black;background:#fff88f !important;">主要缺点是我们无法共同保证AD系统网络和物理部分的正确性</span>。一旦网络和物理部分之一无法满足其时序要求，AD系统就不安全，应该重新设计。这种设计分析过程将反复重复，直到 AD 系统的网络和物理部分都通过时序分析，这是耗时且乏味的。更不幸的是，（上一次迭代中）的分析结果并没有为下一次迭代中重新设计AD系统提供指导。现有的工作都没有为 AD 系统的迭代设计过程开发有效的方法。<span style="color:black;background:#fff88f !important;">如何共同分析网络部分和物理部分的正确性确实是AD领域的一个具有挑战性的问题。</span>

在本文中，我们重点关注自动驾驶系统网络部分和物理部分时序正确性的共同分析。如果 AD 系统中的所有任务在截止日期前完成执行，则网络部分的计时正确。如果AD系统能及时应对物理世界的紧急情况，即端到端的时延满足时序要求，则物理部分的时序是正确的。我们提出了一个有效的框架来共同保证任务的可调度性和AD系统的端到端延迟约束。我们通过采用复杂的任务模型（称为多速率有向无环图（DAG）[7]）来制定 AD 系统的时序行为，以捕获多个任务的并行激活以及现有系统中应用的隐式通信机制。在多速率 DAG 模型中，每个节点表示定期激活的单个任务。边代表任务之间的数据交换，遵循最后最好的语义并形成任务链。多速率DAG调度最具挑战性的问题是如何妥善处理计算密集型任务释放的繁重工作量与关键链严格的时序要求之间的冲突。可能不需要执行任务的所有激活实体（也称为“作业”）。这是因为某些作业产生的数据不能用于生成最终的控制命令。基于这一观察，我们可以<span style="color:black;background:#ff4d4f !important;">在不违反端到端延迟约束的情况下，删除每个任务中一些不必要的作业，以减少 AD 系统的工作负载。</span>

在时序分析过程中，我们提出了整数线性规划（ILP）模型来配置每个任务的执行模式，以确定应该删除哪些作业。<span style="color:black;background:#ff4d4f !important;">我们开发了一种迭代算法来有效地求解 ILP 模型。最初，我们仅使用基本约束来求解 ILP，以获得粗略的配置。在每次迭代中，我们检查任务集是否可调度，以及端到端延迟在当前配置下是否有很好的界限。如果情况并非如此，则 ILP 模型中会涉及额外的约束，以排除不可行的配置。通过求解放大的ILP模型，我们获得了AD系统的重构。</span>这个过程一直持续到我们成功设计出一个网络部分和物理部分都满足时序要求的自动驾驶系统。我们在不同的设置下进行实验，以将我们的分析方法的性能与最先进的分析方法进行比较。实验结果表明，我们的方法可以显着提高成功设计 AD 系统并保证时序正确性的能力。

本文的其余部分安排如下。我们首先在第 2 节中概述 AD 系统。 II，然后我们在第2节中介绍了多速率DAG的系统模型。三．我们在第 2 节中提出了多速率 DAG 的实时调度框架。四．在秒。 V，我们开发了多速率 DAG 调度的时序分析方法。实验结果在第 2 节中报告。六．相关工作在第 2 节中给出。七．结束语在第 2 节中作出。八．


# 二.AD系统概述
我们专注于数据流复杂、传感器输入多样化的AD系统。 2021 年 RTSS 行业挑战 [2] 中给出了 AD 领域的最新示例。图 1 显示了示例 AD 系统的简化处理图。从左侧开始，AD 系统从毫米波雷达、LiDAR、摄像头和 GNSS/IMU 接收原始传感数据（捕获事件）。传感器以不同的频率独立产生原始数据。 AD系统的数据处理、感知、融合、跟踪、轨迹规划和控制等模块以不同的激活速率激活，使用最新的输入数据进行计算，并定期向下游模块产生输出。下面详细介绍一下。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071129545.png)
**定期任务**。 AD 系统的每个模块都是作为在特定时期激活的单独任务来实现的。例如，“跟踪”任务以10Hz激活，其周期为100ms。我们将任务分为三类：（1）传感器任务是与传感器对应的任务。例如，在图1中，有四个传感器任务，分别对应毫米波雷达、LiDAR、Camera和GNSS/IMU。当传感器任务被激活时，它能够捕获传感器任务激活时间之前发生的事件。 (2)控制任务是产生控制命令的任务。图1中只有一个控制任务（模块）。 (3)计算任务。其余与传感器或控制模块不对应的任务都称为计算任务。

我们采用ROS2[9]的执行器，它维护一个就绪集来记录准备执行的作业。当一个作业被释放时，只有当同一任务的所有早期作业都完成后，它才能被放入就绪集；否则，该工作就应该被“放弃”。因此，一个任务释放的作业不能重叠或积压[10]，即同一时间点最多有一个作业正在执行或等待执行。为了简单起见，我们为每个作业分配一个明确的截止日期，确保它必须在后面的作业（同一任务）开始执行之前完成。

**数据通讯**。两个任务之间的数据依赖性由有向边表示，如图 1 所示。例如，跟踪任务产生的数据被预测任务消耗。两个任务之间的数据通信利用共享内存中的缓冲区，所有内核都可以访问该缓冲区。更具体地说，每对相邻任务（例如“跟踪”任务和“预测”任务）之间都有一个单位大小的缓冲区。上游（“跟踪”）任务通过输出端口将数据写入缓冲区。下游（“预测”）任务通过输入端口从缓冲区读取数据。缓冲区中的旧数据将被上游任务生成的新数据覆盖。<span style="color:black;background:#d3f8b6 !important;">我们采用AUTOSAR [4]中定义的隐式通信模型，它实现了双缓冲技术来解决相互执行问题。每个任务都遵守逻辑执行时间（LET）</span>，即任务数据的输入在任务激活时执行，输出在任务可用窗口结束时（例如截止日期）执行。抽象地说，LET 范式假设输入/输出操作在零时间内发生。

**计算平台**。 AD系统的任务在同构多核平台上执行。在本文中，我们假设任务被提前分配给核心。例如，我们假设有三个核心。<span style="color:black;background:#d3f8b6 !important;">我们将任务分为三个部分，并将每个部分分配给一个核心。</span>更具体地说，传感器数据（来自毫米波雷达、相机、LiDAR 和 GNSS/IMU）的处理过程在第一个核心上执行。感知（包括“2D感知”、“3D感知”和“感知融合”）和定位部署在第二核上。其他程序（包括“跟踪”、“预测”、“规划”和“控制”）部署在第三个核心上。

**时间限制**。我们的目标是安排 AD 系统以满足以下时序约束。 
  - 一旦作业开始执行，就必须在截止日期之前完成。 
  - 当事件发生时，其相关数据必须在一定的时限内被感知、处理并最终用于生成控制命令。这对应于第 2 节中描述的反应时间约束。 III-B。 
  - 控制命令必须基于足够新鲜的状态信息来执行。这对应于第 2 节中描述的数据年龄限制。 III-B。

第一个约束与AD任务的可调度性密切相关，这对于保证AD系统网络部分的正确性至关重要。第二个和第三个约束是与 AD 系统的物理部分密切相关的端到端延迟约束类型。在下一节中，我们将 AD 系统制定为多速率 DAG 模型，并更正式地阐述这些时序约束。

# 三．系统模型 
## A. 多速率 DAG 模型

我们将 AD 系统建模为多速率 DAG G = (V, E)，其中 V 是节点集，E 是节点之间的边集。 V 的每个节点对应一个周期性任务 τi，具有最坏情况执行时间 (WCET) ei 和周期 Pi。在本文的其余部分中，“节点”和“任务”这两个符号是同义词，我们将毫不混淆地使用这两者。两个任务 τi 和 τj 之间的数据依赖性被建模为 E 的有向边 (τi, τj)。如果没有边进入 τi，则任务 τi 称为 G 的源；如果有，则任务 τi 称为 G 的汇。没有从 τi 发出的边。通常，源对应于传感数据（预处理）处理任务，而接收器对应于控制任务。任务图G允许有多个源和多个汇。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071215251.png)


例1 图1 AD系统的多速率DAG G模型如图2所示。四个源节点τ1、τ2、τ3和τ4分别对应对来自GNSS/IMU、Lidar的传感数据的处理、摄像头和毫米波雷达。单个汇聚节点τ12对应于控制任务。任务的WCET和周期如上表所示。

**定义 1（任务链）**。 G 的任务链是一个任务序列 π = (τ1, τ2, ···, τh)，使得第 k 个任务 τk 到第 (k +1) 个任务 τk+1 之间存在一条边， ∀k = 1,···,h−1。

Def 1中定义的任务链。文献[6]中也被称为因果链。如果 π 以源点开始并以 G 的汇点结束，则任务链 π 是完整的。例如，π1 = {τ4, τ8, τ9} 且 π2 = {τ3, τ7, τ8, τ9, τ10, τ11, τ12}都是图2中G的任务链，只有π2是完整的链。我们用Π表示G中的关键链集合，Π中的每个元素都是G的一条完整链。

## B. 运行时模型


我们考虑一个多处理器平台 C，其中包括 ρ 个专用处理器，即 C = {C1, C2, ···, Cρ}。 G 的任务在平台 C 上执行，相应地，我们将任务集划分为 ρ 不相交子集，即 V = V1 ∪ V2∪, · · · , ∪Vρ。 Vι 的任务只能在处理器 Cι 上执行（ι = 1, 2, ......, ρ）。我们假设图1中有三个处理器，根据每个任务的功能，我们可以将任务系统分为三个子集。如图2所示，相同颜色的任务分配给同一个处理器。更具体地，任务τ1至τ4在C1上执行，任务τ5至τ8被分配给C2，其余任务（例如τ9至τ12）被部署在C3上。

每个任务 τi 以特定周期 Pi 周期性地释放作业，并且我们假设所有任务同时释放其第一个作业。当τi的一个作业被释放时，如果τi的其他作业正在执行或等待执行，则该作业已准备好。否则，该工作将被放弃。只需要执行 τi 的就绪作业。我们用R(τi)表示τi的就绪作业集合，即R(τi) = {Ji,1,···,Ji,x,···}，其中Ji,x表示第x个就绪作业τi 释放，用 ri,x、si,x 和 fi,x 分别表示 Ji,x 的释放时间、开始时间和结束时间。 G 的就绪作业集定义为R (G) = ∪τi∈VR (τi)。 G 的调度是执行 R(G) 的所有就绪作业，使得
- C 的每个处理器在一个时间点最多执行一项作业。 
- R(G) 的每个就绪作业Ji,x 必须在其专用处理器上执行。 
- R(G)的每个就绪作业Ji,x在其释放时间ri,x之后开始执行，即si,x ≥ ri,x。 
- R(G) 的每个就绪作业Ji,x 的执行是抢占式的。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071416206.png)


**示例 2**. 图 2 中 G 的调度部分如图 3 所示。G 的所有任务在时间 0 释放其第一个作业，调度在时间 0 开始。在时间间隔 [0, 66] 内，任务τ3 释放了两个作业，但只执行了其中一个作业，即 τ3 的第二个作业在时间 33 释放时被丢弃，因为当时有一个 τ3 的作业已经被释放并且正在执行。作业 J2,1 在时间 10 被抢占，并在时间 14 恢复。我们使用 J(1) 2,1 和 J(2) 2,1 来表示 J2,1 在不同时间间隔执行的两个部分， 分别。
> 为什么先是J4

需要强调的是，我们不打算详细说明为什么在上面的示例中作业会被抢占，因为本节没有提供调度算法的细节。在 IV（第二阶段），我们将介绍详细的调度算法。 G 的可行调度应满足如下定义的几个时序约束。

**截止日期约束**。R (G) 的每个作业 Ji,x 都与相对期限 Di,x 相关联，因此 Ji,x 的绝对期限 di,x 计算为 di,x = ri,x + Di,x。作业 Ji,x 需要在其绝对截止日期之前完成，即 fi,x ≤ di,x。定义2描述了AD系统的可调度性。

**定义2**. 如果存在 G 的调度，使得R (G) 的所有就绪作业必须在其截止日期前执行，则 G 的任务系统是可调度的，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071430737.png)

**端到端延迟限制**。除了截止时间约束之外，G的可行调度还应该满足更多的时序约束。下面，我们进一步定义两种类型的端到端延迟约束，在详细介绍之前，我们首先介绍一些有用的符号，如下所示。

对于 E 的任何边 (τi, τj)，我们考虑两个作业 Ji,x 和 Jj,y，它们分别是 τi 和 τj 的就绪作业，即 Ji,x ∈ R(τi) 和 Jj,y ∈R(τj ）。如果 Ji,x 是 R(τi) 中最后发布的作业，其截止日期不大于 Jj,y 的发布时间，则我们称 Ji,x 为 Jj,y 的数据生产者，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071436073.png)
在这种情况下，作业 Jj,y 称为 Ji,x 的数据使用者。

**定义 3（生产者-消费者（P-C）链）**。对于任何任务链 π = (τ1, τ2, · · · , τh)，作业序列 κ = (J1,a1 , J2,a2 , · · · , Jh,ah ) 是一个 π 的 P-C 链，如果 
- κ 的第 k 个作业 Jk,ak 是 π 的第 k 个任务 τk 释放的就绪作业，对于每个 k = 1, · · · , h。 
- 第 k 个作业 Jk,ak 是第 (k + 1) 个作业 Jk+1,ak+1 的数据生产者，对于每个 k = 1, · · · , h − 1。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071441280.png)
一般来说，PC链κ的第一个作业J1,a1由传感器任务τ1释放。我们让 J1,a1−1 为早于 J1,a1 发布的 τ1 的最新就绪作业。仅当 e 发生在 J1,a1 释放之前和 J1,a1−1 释放之后，事件 e 才会被 J1,a1 捕获，如图 4 所示。 另一方面，事件 e 的最后一个作业 Jh,ah P-C链κ由控制任务τh释放。当作业 Jh,ah 完成时，它会生成如图 4 所示的控制命令。
κ的数据年龄dte(κ)和反应时间rct(κ)分别定义如下。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071442719.png)

κ 的数据年龄 dte(κ) 表示数据通过 P-C 链 κ 传播的时间量。更具体地，它定义了从κ的第一个作业J1，a1的释放时间到κ的最后一个作业Jh，ah通过使用J1，a1的数据感测产生控制命令的时间的最大持续时间。 κ的反应时间rct(κ)包括事件被捕获以及数据通过P-C链κ传播的过程。它表示从κ的第一个作业J1,a1捕获事件e的时间到κ的最后一个作业Jh,ah生成其控制命令以对事件e做出反应的时间的最大持续时间。为了方便起见，我们用fst(κ)和lst(κ)来表示P-C链κ的第一个作业和最后一个作业，即fst(κ) = J1,a1和lst(κ) = Jh,ah。

我们用 θ(π) 表示任务链 π 的所有 P-C 链的集合，并将 θ(π) 分成几个不相交的子集，如下面的定义所示。

**定义4（P-C链的划分）**。路径 π 的 P-C 链集合 θ(π) 被划分为 θ(π) = θ1 ∪ θ2 · · · ，使得对于任意两条 P-C 链 κ 和 κ′， 
- fst(κ) = fst(κ′) ，如果 κ 和 κ′ 属于 θ(π) 的同一子集，即 κ, κ′ ∈ θk (∀k = 1, 2 · · · )。 
- fst(κ) = fst(κ′)，如果 κ 和 κ′ 属于 θ(π) 的不同子集，即 κ ∈ θk 且 κ′ ε θk′ (k = k′)。
对于 θ(π) 的每个子集 θk，我们分别将 θk 的数据年龄 dte(θk) 和反应时间 rct(θk) 表示为
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071447355.png)

数据年龄 π 表示从采样有效传感器数据到基于该数据输出的最后一个时间点的最长时间间隔的长度。 π反应时间定义为从外部原因发生到该外部原因最早得到完全处理的最长时间间隔的长度。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071453205.png)
例3 我们以任务链π = {τi, τj, τl}为例，图5说明了通过π进行的数据传输和接收。对于每个作业，我们只揭示其逻辑执行时间，即，我们使用向下箭头显示作业被释放并从输入端口读取数据的时间，并使用向上箭头标记作业的截止时间，并在此时作业将数据写入输出端口。边代表工作之间的生产者-消费者关系。作业Jj,2有一个数据生产者Ji,2，并且有三个数据消费者Jl,5、Jl,6和Jl,7。图 5 中 π 有 4 条 P-C 链，即 κ1 = (Ji,2, Jj,2, Jl,5)，κ2 = (Ji,2, Jj,2, Jl,6)，κ3 = (Ji ,2, Jj,2, Jl,7) 和 κ4 = (Ji,3, Jj,3, Jl,8)。 κ1 的第一个作业和最后一个作业分别为 Ji,2 和 Jl,5，即 fst(κ1) = Ji,2 和 lst(κ1) = Jl,5。 κ1和κ3的反应时间和数据年龄如图5所示。前三个P-C链共享相同的第一个作业Ji,2，最后一个P-C链有自己的第一个作业Ji,3。因此，我们记录 θ(π) 的两个子集，即 θ1 = {κ1, κ2, κ3} 和 θ2 = {κ4}。 θ1 的数据年龄等于 κ3 的数据年龄，因为根据（5），κ3 在 θ1 的所有 P-C 链中具有最大数据年龄。 θ1 的反应时间等于 κ1 的反应时间，因为根据（6），κ1 在 θ1 的所有 P-C 链中具有最小的反应时间。

对于每个关键链 π，我们定义数据年龄 (DA) 边界 Bdaπ 和反应时间 (RT) 边界 Brtπ。下面描述端到端延迟约束的可满足性。

**定义 5**. 如果所有关键链的数据年龄和反应时间分别受其 DA 边界和 RT 边界限制，则 G 的调度满足端到端延迟约束，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071524385.png)
上面定义的数据年龄约束和反应时间约束对应于第二章的第三和第二时序约束。如果 G 的调度满足 (1) 和 (9) 中的所有时序约束，则它是可行的。为了获得可行的调度，我们首先设计一个实时调度框架来调度G的任务系统，如第4节所示。然后我们开发了一种时序分析方法，并展示了如何在我们的调度框架下保证时序约束（参见第五节）。

# 四．实时调度框架

在本节中，我们提出了一种多速率 DAG G 的实时调度框架，其中包含如下所述的两个阶段。

## 第一阶段：确定任务的执行模式
正如第III节中提到的G的任务会定期释放作业，但并不是所有释放的作业都有机会执行，即强制删除部分作业，以避免作业重叠和积压。在调度 G 之前，不确定任务的哪些作业可以记录到就绪集R（G）中，这使得分析 AD 系统的时序行为变得困难。为了<span style="color:black;background:#ff4d4f !important;">开发一种更具确定性的调度方法，我们不会在运行时丢弃作业，而是在设计阶段预先定义每个任务的执行模式，并在调度开始之前提前决定应该丢弃哪些作业。</span>在详细介绍之前，我们首先介绍一些有用的符号，如下所示。
我们用 HP 来表示 G 的超周期，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071542075.png)
回想一下 Pi 是任务 τi 的周期，lcm 表示“最小公倍数”。对于每个任务τi，我们用Ti来表示τi的虚拟周期，它需要满足以下约束。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071542298.png)
其中“a|b”表示b可以除以a而没有余数。通过使用虚拟周期Ti，我们最终定义τi的执行模式如下。

**定义 6（执行模式）**。对于每个任务τi，其执行模式EMi可以表述如下：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071544220.png)
其中 Di = [Di,1, Di,2, · · · , Di,Ni ] 是相对截止日期的向量； Ti = [Ti,1, Ti,2,····, Ti,Ni ] 是任务 τi 的两个连续就绪作业之间的间隔向量； Ni是虚拟时间内τi释放的就绪作业数量。需满足以下条件：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071546538.png)
根据(11)，必须存在一个向量T i 使得上面的第一项和第二项成立。上面的第三项表明，τi 的作业必须在 τi 的下一个（就绪）作业发布之前完成，这符合第3节中描述的防止作业重叠和积压的要求。执行模式 EMi 可以看作是生成 τi 的就绪作业的“种子”。更具体地，对于每个 x = 1, 2, · · · ，R (τi) 的第 x 个作业 Ji,x 表示为 (ei, ri,x, di,x)，其中 ei 是 Ji 的 WCET， Ji,x的发布时间和绝对期限计算如下
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071552773.png)
其中 σ = rem(x, Ni) 是 x 除以 Ni 的余数。

对于给定的执行模式 EMi，任务 τi 可以被视为广义多帧任务（GMF）[11]：τi = (ei, Di, Ti)。我们将 τi 的密度（在 EMi 下）定义为 δi = eiNi/Ti 。例如，我们将图2中任务τ1的虚拟周期设置为T1 = 50ms，并将τ1的执行模式设计为​​EM1 = ([12, 18] , [20, 30])。 EM1下τ1释放的就绪作业如图6所示。τ1的密度为δ1 = 4/ 25 。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071612705.png)
## 第二阶段：EDF策略下的实时调度
我们根据最早截止日期优先 (EDF) 策略安排 R(G) 的作业 Ji,x。当作业 Ji,x 被释放时，我们将其分配给任务 τi 的专用处理器。更正式地说，对于任何处理器 Cι (ι = 1, 2, · · · , ρ)，我们维护一个就绪集 ι，并将 Ji,x 添加到 ι 中。当 Ji,x 完成后，将其从 ι 中删除。任何时候，Cι 总是选择 ι 中所有作业中截止日期最早的作业 J* 来执行。如果两个或多个作业的截止日期相同，则会随机选择一个作业来打破平局。

到目前为止，我们已经给出了一个两阶段调度框架来调度多速率DAG G的任务系统，但是本节中仍然没有解决一些关键的技术问题。最重要的问题之一是如何为每个任务确定合适的执行模式，这可能会极大地影响AD系统的可行性。一种直观的方法是，τi 的每个作业一发布就记录到就绪集（τi）中，并且要求 τi 的每个作业在 τi 发布新作业之前完成。这一要求转化为隐式截止时间 τi，它等于任务周期 Pi，因此，τi 的执行模式 EMi 定义为

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405072103684.png)
尽管（15）的执行模式在文献[7]中被广泛采用，但它并不是最佳选择。主要缺点列举如下。
- <span style="color:black;background:#fff88f !important;">执行模式为（15）的任务系统会生成最密集的就绪作业，其工作量太大而无法调度，</span>因此常常无法满足（1）中定义的截止时间约束。 
- <span style="color:black;background:#fff88f !important;">虽然（15）的执行模式生成的作业始终可以具有最小的端到端延迟，但有些作业产生的数据无法被控制作业使用，因此不需要执行。</span>在删除这些冗余作业后，也可以满足（9）中的端到端延迟约束。
总之，很难确定任务的执行模式，以在AD任务的可调度性和端到端延迟约束的可满足性之间进行权衡。我们可以放弃一些工作来保证AD系统的可行性。在另一个极端，如果我们放弃太多工作，关键链的反应时间和数据年龄可能无法安全限制。在V，我们提供了一种方法来决定需要删除哪些作业来满足（1）和（9）中的时间要求。

# 五、时序分析方法
本节我们重点解决以下两个问题。

<span style="color:black;background:#ff4d4f !important;">1）对于任何每个任务执行模式固定的AD系统，如何检查AD任务系统的可调度性，以及如何估计AD系统中每个关键链的端到端延迟？ </span>
<span style="color:black;background:#ff4d4f !important;">2）给定每个任务的几种执行模式候选，如何选择（执行模式的）精确组合以保证（1）和（9）的时序约束？</span>
在 V-A，我们提供了一些时序分析技术来解决第一个问题，并且在 V-B，我们提出了一种基于 ILP 的方法来解决第二个问题，其中第 2 节中提出的分析方法。 V-A 在问题解决过程中作为子例程被迭代调用。

## A. 固定执行模式的分析技术

对于每个任务 τi，我们假设其执行模式 EMi 是预先已知的。通过应用（13）和（14），我们可以准确地获得每个任务τi的就绪作业集R（τi），从而获得多速率DAG G的就绪作业集R（G）。我们分别开发了R (G) 的可调度性分析和 G 中关键链的延迟估计。
### 可调度性分析

对于每个处理器 Cι (ι = 1, 2, …, ρ)，我们检查 Vι 的任务（分配给 Cι）是否可调度。如果所有任务集V1,V2,···,Vρ都是可调度的，则整个图G的任务集是可调度的。如第  IV节所示，我们将Vι的任务视为独立任务，并通过EDF算法将它们调度到Cι上。我们应用组合框架[11]来分析任务集Vι的可调度性，即<span style="color:black;background:#d3f8b6 !important;">首先分析每个任务的时序特征，然后将每个任务的分析结果组合在一起来判断任务集Vι是否可调度。</span>我们的分析方法基于一种众所周知的符号，称为需求约束函数（DBF）[11]-[13]，如下所述。

**定义 7（需求约束函数）**。对于任何具有执行模式 EMi 的任务 τi，并且对于正整数 t，需求约束函数 dbfi(t) 表示执行模式 EMi 下 τi 的就绪作业在任意时间范围内都有发布时间和截止时间的最大累积执行要求。持续时间 t 的时间间隔。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081101717.png)
如第 IV节所述。将 EMi = (Di, Ti) 的任务 τi 建模为 GMF 任务 (ei, Di, Ti)。通过直接使用[11]中提出的方法，我们计算特定t的多项式时间内τi的DBF。 DBF计算过程中使用的一个重要概念称为“工作负载-间隔大小”有序对列表，它是由Alg构建的。 1. 最初，列表不包含有序对，如第 1 行所示。通过枚举两个虚拟周期内释放的就绪作业，我们不断生成有序对 (w, l)，如第 2 行至第 6 行所示，其中 l 表示区间大小，w表示τi在大小l的区间内需要执行的工作量。如第4行至第5行所示，l的计算使用参数di,x+Δ和ri,x，可以通过(13)和(14)计算。我们从列表中删除多余的有序对，如第 7 行到第 9 行所示。我们可以通过两个步骤来实现有序对删除。首先，我们将有序的列表对按间隔大小的升序排序到数组中（在间隔大小内按工作负载的降序排列）。然后，我们删除所有那些工作负载不严格大于排序数组中出现在它们之前的所有有序对的工作负载的有序对。

我们定义函数 get-from-list(t) 来展示如何使用 Alg1 构造的列表。对于任何间隔大小 t，函数 get-from-list(t) 返回 max{w | l ≤ t} 如果 t > min(Di)；否则，get-from-list(t) = 0，表示在大小为t的时间间隔内不需要执行τi释放的工作负载。通过查找列表，我们最终计算出 τi 的 DBF，如下所示。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081118586.png)
下面的定理展示了如何使用 G 的每个任务的 DBF 来检查 G 的可调度性。

**定理 1**. G 的任务集是可调度的当且仅当对于每个处理器 Cι (ι = 1, 2, · · · , ρ)，
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081119025.png)

是Cι上分配的任务总密度，要求严格小于1。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081139295.png)

根据上述定理，当且仅当对于从 1 到 tιf 的所有时间间隔大小 t，每个处理器 Cι 的工作负载需求都符合该间隔时，G 中的任务释放的所有就绪作业必须有一个可行的调度表。细节证明已经在之前的工作[11]中建立，我们在这里不再讨论。更正式地，G 的可调度性分析的伪代码在 Alg2 中给出。 

**引理 1.** G 的可调度性分析可以在 ...时间内完成，其中 N 表示任务在其虚拟内释放的最大作业数周期，即 N = maxτi∈V （Ni）。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081145008.png)
证明。 G的可调度性分析包含两个阶段。在第一阶段，我们为每个任务构建有序对的列表，并且列表构建过程的复杂度是 $O(N^2logN )$，如[11]中证明的。在第二阶段，我们计算分配给每个处理器 Cι 的任务的 DBF。对于每个任务 τi 和特定的间隔大小 t，我们通过查找列表来计算 dbfi(t)，其成本为 O(logN )。因此，DBF 计算的复杂度为 O(tιf |Vι|logN )，因为我们最多需要检查 Vl 中每个任务的 tιf 间隔大小。因此，所有处理器的DBF计算过程的总运行时间为O(Σρι=1  tιf|Vι|logN)，至此证明完毕。

### 端到端延迟估计
对于 Π 的每个关键链 π，我们打算估计 π 的数据年龄 dte(π) 和反应时间 rct(π)。不幸的是，直接计算(7)和(8)的dte(π)和rct(π)是很困难的，因为π的P-C链有无限个，因此不可能枚举P-C链的所有子集θk设置 θ(π)。接下来，我们开发了一种通过仅检查（有限数量）选定的 P-C 链来计算 dte(π) 和 rct(π) 的有效方法。在详细讨论之前，我们首先在下面提出一些有用的符号。

对于 τi 的任意作业 Ji,x 和非负整数 Z，我们令 Ji,x′ 为 τi 的作业，该作业恰好晚于 Ji,x 的释放 Z HP 时间单位，即 ri,x ′ = ri,x + Z HP。我们说 Ji,x′ 是从 Ji,x Z 个超周期前传输 ，可写为 Ji,x′ = Ji,x ⊕ Z HP 或同样地，Ji,x = Ji,x′⊖ Z HP。传输作业的属性由以下引理给出。

**引理2**. 对于任何作业 Ji,x 及其传输作业 Ji,x′ = Ji,x ⊕ Z HP，di,x′ = di,x + Z HP 且 ri,x′ = ri,x + Z HP。
证明。从平移运算“Ji,x ⊕ Z HP”的定义中导出这个引理是微不足道的。

**引理3**. 作业 Ji,x 是R (τi) 的就绪作业,当且仅当 Ji,x ⊕ Z HP 是 R(τi) 的就绪作业。
证明。不失一般性，我们假设 Ji,x ∈ R(τi)，并且我们将证明 Ji,x′ = Ji,x ⊕ Z HP 也属于 R(τi)。我们知道 ri,x′ − ri,x = Z HP 并且由于 Ti|HP 如 (11) 所示，Ji,x 和 Ji,x′ 释放之间的持续时间长度为 KTi，其中K=Z(HP/Ti）是整数。根据τi的虚拟周期Ti的定义，在就绪作业Ji,x释放后，每隔Ti时间单位释放一个就绪作业。因此，Ji,x′ 是 τi 的就绪工作。类似的道理，如果Ji,x′ ∈ (τi)，我们也可以证明Ji,x ∈ (τi)。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081223125.png)

对于任何作业链 κ，我们使用 κ′ = κ ⊕ ZHP 来表示作业链，使得 κ 和 κ′ 具有相同数量的作业，即 |κ′| = |κ|，并且对于每个 k = 1、···、|κ|，κ′ 的第 k 个作业是从 κ 的第 k 个作业 Ji,x 从 Z 个超周期前传输，即 Ji ,x′ = Ji,x ⊕Z HP，如图 7 所示。基于 Lem3、推导出传输作业链的性质。
**引理 4**. κ 是 π 的 P-C 链当且仅当 κ ⊕ ZHP 是 π 的 P-C 链。

证明。通过让 κ′ = κ ⊕ ZHP，我们假设 κ 是 π 的 P-C 链，并且我们将证明 κ′ 是 π 的 P-C 链。假设没有。 κ' 必须有一条边 (Ji,x' , Jj,y' )，使得 Ji,x' 不是 Jj,y' 的生成者。根据(2)，有两种情况

如果 di,x′ > rj,y′ ，则令 Ji,x = Ji,x′ ⊖Z HP 且 Jj,y = Jj,y′ ⊖Z HP。根据引理2的说法我们有 di,x > rj,y。此外，由于 κ = κ′ ⊖Z HP ，所以边 (Ji,x, Jj,y) 属于 κ。根据(2)，κ不是π的P-C链。

否则，di,x′ ≤ rj,y′ 。在这种情况下，存在 (τi) 的作业 Ji,z'，其截止日期 di,z' 在 (di,x' , rj,y' ] 中，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081405123.png)

根据引理3说法Ji,z = Ji,z′⊖ Z HP 也是 τi 的就绪工作。我们知道 Ji,z 在 ri,z′ − Z HP 处释放，然后我们有
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081414689.png)
由于 Ji,x = Ji,x′ ⊖Z HP 和 Jj,y = Jj,y′ ⊖Z HP, 我们有
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081416248.png)
结合(18)、(19)和(20)，我们知道di,z ≤ rj,y 且di,z > di,x。它表明 Ji,z 是 Jj,y 的生产者，但 Ji,x 不是。因此，κ 不是 π 的 P-C 链。
<span style="color:black;background:#d59e83 !important;">上述两种情况都与前提条件相矛盾，因此κ'是π的P-C链。类似的道理，如果κ′是π的P-C链，则可以证明κ是π的P-C链。</span>

基于引理 2、并利用类似技术进行引理3的证明，我们可以证明，作业链 κ 与其翻译后的作业链 κ' 之间存在精确整数个超周期，因此，κ 和 κ' 具有相同的反应时间和相同的数据年龄，如下所示推论。

**推论 1**. 对于任何作业链 κ 及其传输作业链 κ′ = κ ⊕ Z HP，dte(κ) = dte(κ′) 且 rct(κ) = rct(κ′)。
设τi为π的第一个任务，我们用JiHP表示τi在第一个超周期内执行模式EMi下释放的就绪作业集合，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081432064.png)
我们用<span style="color:black;background:#d3f8b6 !important;"> Hi 记录第一个超周期内 τi 释放的就绪作业数量，即 Hi = |JiHP|。我们用 θ'(π) 来表示 π 的 P-C 链 κ 的集合，使得 κ 的第一个工作属于 JiHP</span>，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081435446.png)


显然，θ'(π)包含有限数量的作业链，并且它可以精确地分为Hi不相交子集，如Def4所示即 <span style="color:black;background:#d3f8b6 !important;">θ'(π) = θ1 ∪ · · · ∪ θHi ，其中 θx 表示共享相同第一个作业 Ji,x 的作业链的第 x 个子集</span>（这里 Ji,x 是 JiHP 的第 x 个作业 ）。下面的定理表明，通过枚举 θ'(π) 的作业链来计算 dte(π) 和 rct(π) 就足够了。

**定理2**. 关键链 π 的反应时间和数据年龄的界限为
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081441320.png)

证明。我们用反证法证明这个定理。为了证明（23），我们假设数据年龄最大的 π 的 P-C 链 κ* 不属于 θ'(π)，即 dte(κ*) = dte(π) 且 κ* ∈ θ(π) /θ'(π)。令Ji,x* = fst(κ*)，根据θ'(π)的定义，可知Ji,x* ∈ JiHP。必须存在一个整数 Z，使得作业 Ji,x ∈ JiHP 是从 Ji,x* 向回翻译 Z 个超周期，即 Ji,x = Ji,x* ⊖Z HP。我们让 κ 为从 κ* 向回传输 Z 个超周期的作业链，即 κ = κ* ⊖ZHP。根据引理4的说法κ 是 π 的 P-C 链，有 κ ∈ θ(π)。不失一般性，我们假设 κ 属于 θ(π) 的子集 θk。由(5)和(7)可知dte(π) ≥ dte(κ)。此外，根据推论1，dte(κ) = dte(κ*)。因此，dte(π) ≥ dte(κ*)，这与假设相矛盾。
> fst第一个

为了证明(24)，我们假设rct(π)是由不属于θ(π)的P-C链κ* 实现的。使用与上述相同的技术，我们将 κ* 转换为 P-C 链 κ ∈ θ(π)。不失一般性，我们让 θk 为包含 κ 的 θ(π) 的子集。根据(6)，有rct(θk) ≤ rct(κ)，说明存在一条P-C链κ′ ∈ θk，其反应时间不大于κ的反应时间，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081508920.png)
我们令 κ′′ = κ′ ⊕ Z HP。此外，由于 κ, κ′ ε θk （即 κ 和 κ′ 有相同的第一份工作）且 κ* = κ ⊕ ZHP，我们知道 κ′′ 和 κ* 有相同的第一份工作，记作 κ′′ , κ* ∈ θk* 。根据推论 1，rct(κ*) = rct(κ) 且 rct(κ′′) = rct(κ′)，由 (25) 可知 rct(κ′′) ≤ rct(κ′)。由于我们已经证明κ* 和κ′′属于同一个子集θk*，并且根据(6)，我们有rct(θk*)≤rct(κ*)。这表明κ* 无法达到式(8)中π的反应时间。这与假设相矛盾。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081516694.png)
根据算法 2、我们应用端到端延迟估计，如 Alg 3所示对于 Π 的每个关键链 π，我们分两步计算其数据年龄和反应时间。首先，我们枚举 π 的所有 P-C 链，其第一个作业在第一个超周期内发布（参见第 2 行到第 11 行）。枚举从π的最后一个任务的作业开始（第2行），我们根据（2）构建每个作业链κ。如果第一个作业在第一个超周期内发布，我们将 κ 存储到 θ(π) 中（第 9 行）。否则，枚举过程终止（第 11 行）。在第二步中，我们通过 (23) 和 (24) 计算 dte(π) 和 rct(π)，如第 12 至 16 行所示。

**引理 5**. 算法3可以在O( Σ π∈Π |π||θ(π)|)时间内完成。
证明。对于 Π 的每条链 π，Alg 3 首先枚举 π 的 P-C 链（第 2 至 11 行），然后计算 π 的端到端延迟（参见第 12 至 16 行）。一方面，根据第8行到第11行，第2行到第11行的循环恰好迭代|θ(π)|特定 π 的时间。此外，根据第 4 行，最内层循环（第 5 行到第 7 行）最多迭代 |π|特定 π 和 Jh,z 的时间。因此，P-C链枚举可以由 Σ πεΠ |π||θ(π)| 完成次。另一方面，阿尔格. 3对特定π的θ(π)的每个作业链κ进行计算，因此，端到端延迟计算需要Σπ∈Π|θ(π)|。总而言之，Alg 3的复杂度是 Σ π Π |π||θ(π)|。

## B. 确定精确的执行模式

对于每个任务 τi，我们准备一组候选执行模式 Mi = {EMi,1, · · · , EMi,ni }，其中 EMi,k 是 τi 的第 k 个执行模式候选，ni 是Mi 中的执行模式候选者。<span style="color:black;background:#ff4d4f !important;">我们的目标是为每个任务 τi 找到精确的执行模式 EMi*（来自 Mi），使得由所选执行模式 EMi*（∀τi ∈ V）生成的就绪作业集R*（G）是可调度的，而且调度EDF策略下的R*(G)满足(9)的端到端延迟约束。</span>我们开发了一种 ILP 方法来导出精确的执行模式，如下所示。

### ILP配方
我们的 ILP 模型的目标是导出精确的执行模式，不仅保证（1）和（9）的时序约束，而且尽可能少地丢弃作业。在给出正式的目标函数之前，我们首先介绍如下基本常量和变量。对于每个任务 τi 和每个候选执行模式 EMi,k ∈ Mi，
- 密度：δ(i, k) 是表示执行模式EMi,k 下τi 的密度的常数。 
- 模式指示符：xi,k 是指示是否选择执行模式 EMi,k 作为 τi 的精确执行模式的变量，即如果 EMi* = EMi,k，则 xi,k = 1；否则，xi,k = 0。我们使用 X 来存储 ILP 模型的所有变量，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081528360.png)
通过使用上面的常量和变量，我们将 ILP 模型的目标函数定义如下。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081529252.png)
式(26)旨在<span style="color:black;background:#ffbbff !important;">最大化任务系统的总密度，表明每个任务的目标执行模式都尽量避免丢弃作业</span>，因为丢弃的作业越少，总密度就越高。以下约束确保为每个任务选择准确的一种候选执行模式。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081531872.png)
由我们的ILP模型导出的执行模式必须满足以下约束以保证AD系统的可行性。<span style="color:black;background:#ffbbff !important;">对于每个处理器 Cι，分配给 Cι 的任务总密度必须小于 1，即</span>
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081532174.png)
回想一下，Vι 代表分配给处理器 Cι 的任务集。约束(28)表示必要条件“δι < 1”，<span style="color:black;background:#ffbbff !important;">如算法1中所述 对于任意时间 t = 1, 2, ··· , tιf ，分配给特定处理器的任务的总 DBF 不得超过 t，即</span>
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081535451.png)

接下来，我们推导约束以保证有界的端到端延迟，如（9）中所述。对于每条关键链 π = (τ1, · · · , τh)，我们令 Mπ 为 π 中每个任务 τi 的执行模式向量，即 Mπ = {EM1,k1 , · · · , EMh,kh }，其中 EMi,ki 表示被选择加入 Mπ 的 Mi 的候选执行模式。如果 Mπ 生成的就绪作业违反了（9）的时序约束，我们将 Mπ 添加到 π 的违反集 M'π 中。通过枚举 M'π 的所有执行模式向量，我们完全排除了违反（9）的情况，如下所示。对于每个关键链 π ∈ Π，其中|π|表示任务链π中的任务数量。<span style="color:black;background:#ffbbff !important;">约束(30)确保Mπ中的任何执行模式向量都不能被选择作为ILP模型的解。</span>
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081540695.png)
> 看不懂
> 如果一个执行模式向量Mπ在 𝑀𝜋𝑣𝑖𝑜Mπ vio​  中，那么不可能所有 𝑥𝑖,𝑘x i,k​  都为1，从而阻止了这个违规的执行模式向量被ILP模型选择。

应该强调的是，每个任务 τi 的执行模式集 Mi 被视为 ILP 模型的输入，但在本节中，我们不会展示如何为每个任务构造候选执行模式的细节。在第六节，我们将给出执行模式构造方法，并评估我们的方法在不同配置下的性能。更重要的是，（29）和（30）中存在大量约束。我们在求解ILP模型时并不涉及所有这些约束，而是仅在确实有助于制定ILP模型的可行解时才添加（29）或（30）的约束。更具体地，求解方法描述如下。

### 迭代求解算法
我们开发了一种以迭代方式求解 ILP 模型（表示为 MODEL ILP）的方法，如 Alg4 所示。 

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081552580.png)

最初，我们仅通过添加目标函数（26）和基本约束（27）和（28）来求解MODEL ILP，如第1行至第2行所示，并且可以获得解X。为了方便起见，我们只记录X对应变量等于1的执行模式，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081554015.png)

我们<span style="color:black;background:#ffbbff !important;">调用 Alg2、检查执行模式设置为M的任务系统是否可调度（如第5、11、12行）。如果具有M的任务系统是不可调度的，我们令t为发生溢出的时间点。然后我们将约束（29）（针对特定时间 t）添加到 MODEL ILP 中。否则，具有M的任务系统是可调度的。在这种情况下，我们通过调用 Alg 3进一步验证 (9) 中端到端延迟约束的可满足性。 如果每个关键链的数据年龄和反应时间都有界，则无需添加约束。否则，我们会涉及额外的约束来细化关键链的端到端延迟。</span>在详细介绍之前，我们首先介绍一些有用的符号，如下所示。

对于任意任务链 π = (τ1, · · · , τh)，我们令 κ = (J1,a1 , · · · , Jh,ah ) 为 π 的 P-C 链，其中 Ji,ai 为任务链释放的作业π 的第 i 个任务 τi。对于 κ 的任意作业 Ji,ai ，我们考虑在 ri,ai 处释放就绪作业的执行模式 EMi,k ，有两种情况：
- 如果 EMi,k 不释放截止日期在 (di,ai ,   ri+1,ai+1 ) 范围内的就绪作业，则 EMi,k 遵循 κ 的右规则（写为 EMi,k= =κ），如图所示8(a)。 
- 如果 EMi,k 不释放截止时间在 (di−1,ai−1 ,   ri,ai ) 范围内的就绪作业，则遵守 κ 的左规则（写为 Mπ= =κ ），如图 8 所示(b).

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081611393.png)
基于这些符号，我们通过考虑以下两种情况来涉及每个关键链 π 的约束。

- π 的数据年龄 dte(π) 大于边界 Bπda，如第 7 行所示。我们令 κda 为 π 的 P-C 链，其数据年龄等于 dte(π)。对于 π 的每个任务 τi，我们用 M^i 表示遵守 κda 右规则的 τi 执行模式的集合，即：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081612955.png)
我们用 Jp,ap 表示 κda 的第一个违规作业，其截止日期（减去 κ 的第一个作业 J1,a1 的发布时间）大于数据年龄界限，即：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081616678.png)
设M^p i = {EMi,k|EMi,k ∈ M^i ∧ i ≤ p}，则 P-C 链 κda 引发的违规约束如下。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081619422.png)
- π 的反应时间 rct(π) 大于边界 Bπrt（第 9 行）。我们令κrt为π的P-C链，其反应时间等于rct(π)。对于 π 的每个任务 τi，我们用 M'i 表示 τi 的执行模式，同时遵守 κrt 的右规则和左规则，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081621724.png)
我们让 Jq,aq 为 κrt 的第一个违规作业，其截止时间（减去作业 J1,a1−1 的释放时间 r1,a1−1）大于预定义的反应时间界限，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081621180.png)
设 M'qi = {EMi,k|EMi,k ∈ M'i ∧ i ≤ q}，则 P-C 链 κrt 引起的违反约束如下。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081622491.png)
约束条件(31)和(32)分别排除了不可行的P-C链κda和κrt。这些约束比 (30) 中的约束更有效，因为 M^pi ⊂ M^i 和 M'qi ⊂ M'i。

通过重复第 3 行到第 12 行，我们迭代求解 ILP 模型并在每一轮中添加新的约束。当没有向 ILP 模型添加约束时，过程终止并返回执行模式集 M 。这表明最终求解的M可以生成满足（1）和（9）中所有时序约束的可行任务系统。

**引理 6**. 算法4 可以终止在步骤![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405081624791.png)
证明。根据第 3 行，Alg4如果 ILP 模型中没有添加新的约束，则将终止。在每次迭代中，模型中至少包含一个新约束（29）和（30），并且根据第 8 行、第 10 行和第 12 行，这些新约束从未添加到原始 ILP 中。在最坏的情况下，添加(29)和(30)中的所有约束。 (29)的约束数量为ρtιf，因为对于每个处理器Cι(ι=1,···,ρ)，在间隔[1,tιf]期间的任意时间点都可能发生溢出。此外，(30) 最多有 Σ π∈Π,∏τi∈π  ni 个约束，因为我们知道，在 Π 的关键链 π 中，每个任务 τi 最多有 ni 个执行模式候选。因此，算法 4 次最多运行...次迭代。这样就完成了证明。

ILP模型的规模与Alg4添加的(29)和(30)中的约束数量有关。 尽管根据 Lem6 的说法，(29) 和 (30) 中存在大量约束。 我们的评估结果表明Alg4在终止前并没有添加那么多约束。请参阅下一节中的更多详细信息。

























***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考
