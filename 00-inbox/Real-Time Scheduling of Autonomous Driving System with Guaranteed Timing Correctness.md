---
tags:
  - 笔记
  - 笔记/文献笔记
  - 待归档
created: 2024-03-27T18:55
updated: 2024-05-07T21:28
status:
  - ing
---
# Real-Time Scheduling of Autonomous Driving System with Guaranteed Timing Correctness

**TitleTranslation:** 保证时序正确性的自动驾驶系统实时调度
**Journal or Conference:** 2023 IEEE 29th Real-Time and Embedded Technology and Applications Symposium (RTAS)
**Authors:** JinghaoSun, KailuDuan, XishengLi, NanGuan, ZhishanGuo, QingxuDeng, GuozhenTan
**Pub.date:** 2023-05
**DOI:** 10.1109/RTAS58335.2023.00022
**tags:** 
**zoterolink:** [zotero](zotero://select/library/items/ZZ9936VR)

# 摘要

在自动驾驶（AD）系统中，不同激活率的任务之间存在复杂的数据依赖关系，使得分析系统的实时行为变得非常困难。本文将 AD 系统表述为多速率 DAG，并提出了一个集成框架来共同分析多速率 DAG 中各个任务的可调度性和任务链的端到端延迟。整数线性规划 (ILP) 技术的开发是为了指导如何删除冗余工作负载，以增加满足时序要求的机会。本文提出了一种分析框架，该框架实现了以迭代方式创建、分析和完善 AD 系统设计的自动化过程，即上一次迭代的分析结果为下一次迭代中重新设计 AD 系统提供了有价值的指导。进行实验来评估我们的分析方法的性能。


# 一、简介
在自动驾驶（AD）系统中，大量的安全和控制功能由不同供应商开发，并最终由制造商集成到同一目标平台上。这些功能通常以数据相关的周期性任务的形式实现，这些任务以不同的速率激活，并需要在给定的时序约束内相互同步。为了简化自动驾驶系统的开发，汽车工程标准放宽了数据相关任务之间的同步。放松是通过隐式寄存器通信（最后是最好的语义）完成的，其中任务从共享缓冲区空间（例如全局变量）读取最新数据并将其输出独立于其他任务写入缓冲区[1] - [3]。这种语义已经在许多现有系统中得到应用，例如 AUTOSAR [4] 的隐式通信模型和机器人操作系统（ROS）[5] 中的发布者-订阅者模型。

尽管宽松的数据同步机制简化了分布式开发，但它很少考虑现代汽车领域严格的时序要求。 AD系统中主要有两种类型的实时约束，如下所述。

为了适应传统的实时操作系统（RTOS），AD系统的每个任务都被设计有一个期限。 AD系统中所有任务的基本时序要求是在截止日期之前完成执行，在这种情况下，AD任务被称为可调度的。对于保证AD任务的可调度性至关重要，这样AD系统的网络部分才能始终正确工作而不会出现致命错误。

除了传统的截止日期约束之外，许多 AD 应用程序还通过一系列（周期性）任务对数据传播施加新型的端到端延迟约束，这些任务共同协作以实现特定的系统功能，称为任务链或任务链。因果链[6]。由于与物理世界的紧密联系，AD系统对整个任务链中使用的输入数据的“新鲜度”以及任务链的输入数据对该链的输出产生影响的时间高度敏感。

保证AD系统实时约束的一个重要工具，特别是如上所述的网络部分和物理部分，是时序分析，这是本文的主要关注点。

AD系统的时序分析不仅要保证每个单独任务的可调度性，还要限制关键因果链的端到端延迟，这并非小事。现有的调度和时序分析方法要么无法应用，要么效率低下。更具体地说，传统的实时技术是为可调度性分析而开发的，但即使所有任务都在截止日期前完成，它也无法限制端到端延迟。最近的工作提出了几种限制 AD 系统端到端延迟的方法，但所有这些方法都仅限于所有任务都满足其截止日期的强假设 [3]、[7]、[8]。在当前的分析方法下，AD任务的可调度性和端到端延迟约束的可满足性被视为两个独立的问题。因此，AD系统的网络部分和物理部分被迫分开设计和分析。<span style="color:black;background:#fff88f !important;">主要缺点是我们无法共同保证AD系统网络和物理部分的正确性</span>。一旦网络和物理部分之一无法满足其时序要求，AD系统就不安全，应该重新设计。这种设计分析过程将反复重复，直到 AD 系统的网络和物理部分都通过时序分析，这是耗时且乏味的。更不幸的是，（上一次迭代中）的分析结果并没有为下一次迭代中重新设计AD系统提供指导。现有的工作都没有为 AD 系统的迭代设计过程开发有效的方法。<span style="color:black;background:#fff88f !important;">如何共同分析网络部分和物理部分的正确性确实是AD领域的一个具有挑战性的问题。</span>

在本文中，我们重点关注自动驾驶系统网络部分和物理部分时序正确性的共同分析。如果 AD 系统中的所有任务在截止日期前完成执行，则网络部分的计时正确。如果AD系统能及时应对物理世界的紧急情况，即端到端的时延满足时序要求，则物理部分的时序是正确的。我们提出了一个有效的框架来共同保证任务的可调度性和AD系统的端到端延迟约束。我们通过采用复杂的任务模型（称为多速率有向无环图（DAG）[7]）来制定 AD 系统的时序行为，以捕获多个任务的并行激活以及现有系统中应用的隐式通信机制。在多速率 DAG 模型中，每个节点表示定期激活的单个任务。边代表任务之间的数据交换，遵循最后最好的语义并形成任务链。多速率DAG调度最具挑战性的问题是如何妥善处理计算密集型任务释放的繁重工作量与关键链严格的时序要求之间的冲突。可能不需要执行任务的所有激活实体（也称为“作业”）。这是因为某些作业产生的数据不能用于生成最终的控制命令。基于这一观察，我们可以在不违反端到端延迟约束的情况下，删除每个任务中一些不必要的作业，以减少 AD 系统的工作负载。

在时序分析过程中，我们提出了整数线性规划（ILP）模型来配置每个任务的执行模式，以确定应该删除哪些作业。我们开发了一种迭代算法来有效地求解 ILP 模型。最初，我们仅使用基本约束来求解 ILP，以获得粗略的配置。在每次迭代中，我们检查任务集是否可调度，以及端到端延迟在当前配置下是否有很好的界限。如果情况并非如此，则 ILP 模型中会涉及额外的约束，以排除不可行的配置。通过求解放大的ILP模型，我们获得了AD系统的重构。这个过程一直持续到我们成功设计出一个网络部分和物理部分都满足时序要求的自动驾驶系统。我们在不同的设置下进行实验，以将我们的分析方法的性能与最先进的分析方法进行比较。实验结果表明，我们的方法可以显着提高成功设计 AD 系统并保证时序正确性的能力。

本文的其余部分安排如下。我们首先在第 2 节中概述 AD 系统。 II，然后我们在第2节中介绍了多速率DAG的系统模型。三．我们在第 2 节中提出了多速率 DAG 的实时调度框架。四．在秒。 V，我们开发了多速率 DAG 调度的时序分析方法。实验结果在第 2 节中报告。六．相关工作在第 2 节中给出。七．结束语在第 2 节中作出。八．


# 二.AD系统概述
我们专注于数据流复杂、传感器输入多样化的AD系统。 2021 年 RTSS 行业挑战 [2] 中给出了 AD 领域的最新示例。图 1 显示了示例 AD 系统的简化处理图。从左侧开始，AD 系统从毫米波雷达、LiDAR、摄像头和 GNSS/IMU 接收原始传感数据（捕获事件）。传感器以不同的频率独立产生原始数据。 AD系统的数据处理、感知、融合、跟踪、轨迹规划和控制等模块以不同的激活速率激活，使用最新的输入数据进行计算，并定期向下游模块产生输出。下面详细介绍一下。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071129545.png)
**定期任务**。 AD 系统的每个模块都是作为在特定时期激活的单独任务来实现的。例如，“跟踪”任务以10Hz激活，其周期为100ms。我们将任务分为三类：（1）传感器任务是与传感器对应的任务。例如，在图1中，有四个传感器任务，分别对应毫米波雷达、LiDAR、Camera和GNSS/IMU。当传感器任务被激活时，它能够捕获传感器任务激活时间之前发生的事件。 (2)控制任务是产生控制命令的任务。图1中只有一个控制任务（模块）。 (3)计算任务。其余与传感器或控制模块不对应的任务都称为计算任务。

我们采用ROS2[9]的执行器，它维护一个就绪集来记录准备执行的作业。当一个作业被释放时，只有当同一任务的所有早期作业都完成后，它才能被放入就绪集；否则，该工作就应该被“放弃”。因此，一个任务释放的作业不能重叠或积压[10]，即同一时间点最多有一个作业正在执行或等待执行。为了简单起见，我们为每个作业分配一个明确的截止日期，确保它必须在后面的作业（同一任务）开始执行之前完成。

**数据通讯**。两个任务之间的数据依赖性由有向边表示，如图 1 所示。例如，跟踪任务产生的数据被预测任务消耗。两个任务之间的数据通信利用共享内存中的缓冲区，所有内核都可以访问该缓冲区。更具体地说，每对相邻任务（例如“跟踪”任务和“预测”任务）之间都有一个单位大小的缓冲区。上游（“跟踪”）任务通过输出端口将数据写入缓冲区。下游（“预测”）任务通过输入端口从缓冲区读取数据。缓冲区中的旧数据将被上游任务生成的新数据覆盖。<span style="color:black;background:#d3f8b6 !important;">我们采用AUTOSAR [4]中定义的隐式通信模型，它实现了双缓冲技术来解决相互执行问题。每个任务都遵守逻辑执行时间（LET）</span>，即任务数据的输入在任务激活时执行，输出在任务可用窗口结束时（例如截止日期）执行。抽象地说，LET 范式假设输入/输出操作在零时间内发生。

**计算平台**。 AD系统的任务在同构多核平台上执行。在本文中，我们假设任务被提前分配给核心。例如，我们假设有三个核心。<span style="color:black;background:#d3f8b6 !important;">我们将任务分为三个部分，并将每个部分分配给一个核心。</span>更具体地说，传感器数据（来自毫米波雷达、相机、LiDAR 和 GNSS/IMU）的处理过程在第一个核心上执行。感知（包括“2D感知”、“3D感知”和“感知融合”）和定位部署在第二核上。其他程序（包括“跟踪”、“预测”、“规划”和“控制”）部署在第三个核心上。

**时间限制**。我们的目标是安排 AD 系统以满足以下时序约束。 
  - 一旦作业开始执行，就必须在截止日期之前完成。 
  - 当事件发生时，其相关数据必须在一定的时限内被感知、处理并最终用于生成控制命令。这对应于第 2 节中描述的反应时间约束。 III-B。 
  - 控制命令必须基于足够新鲜的状态信息来执行。这对应于第 2 节中描述的数据年龄限制。 III-B。

第一个约束与AD任务的可调度性密切相关，这对于保证AD系统网络部分的正确性至关重要。第二个和第三个约束是与 AD 系统的物理部分密切相关的端到端延迟约束类型。在下一节中，我们将 AD 系统制定为多速率 DAG 模型，并更正式地阐述这些时序约束。

# 三．系统模型 
## A. 多速率 DAG 模型

我们将 AD 系统建模为多速率 DAG G = (V, E)，其中 V 是节点集，E 是节点之间的边集。 V 的每个节点对应一个周期性任务 τi，具有最坏情况执行时间 (WCET) ei 和周期 Pi。在本文的其余部分中，“节点”和“任务”这两个符号是同义词，我们将毫不混淆地使用这两者。两个任务 τi 和 τj 之间的数据依赖性被建模为 E 的有向边 (τi, τj)。如果没有边进入 τi，则任务 τi 称为 G 的源；如果有，则任务 τi 称为 G 的汇。没有从 τi 发出的边。通常，源对应于传感数据（预处理）处理任务，而接收器对应于控制任务。任务图G允许有多个源和多个汇。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071215251.png)


例1 图1 AD系统的多速率DAG G模型如图2所示。四个源节点τ1、τ2、τ3和τ4分别对应对来自GNSS/IMU、Lidar的传感数据的处理、摄像头和毫米波雷达。单个汇聚节点τ12对应于控制任务。任务的WCET和周期如上表所示。

**定义 1（任务链）**。 G 的任务链是一个任务序列 π = (τ1, τ2, ···, τh)，使得第 k 个任务 τk 到第 (k +1) 个任务 τk+1 之间存在一条边， ∀k = 1,···,h−1。

Def 1中定义的任务链。文献[6]中也被称为因果链。如果 π 以源点开始并以 G 的汇点结束，则任务链 π 是完整的。例如，π1 = {τ4, τ8, τ9} 且 π2 = {τ3, τ7, τ8, τ9, τ10, τ11, τ12}都是图2中G的任务链，只有π2是完整的链。我们用Π表示G中的关键链集合，Π中的每个元素都是G的一条完整链。

## B. 运行时模型


我们考虑一个多处理器平台 C，其中包括 ρ 个专用处理器，即 C = {C1, C2, ···, Cρ}。 G 的任务在平台 C 上执行，相应地，我们将任务集划分为 ρ 不相交子集，即 V = V1 ∪ V2∪, · · · , ∪Vρ。 Vι 的任务只能在处理器 Cι 上执行（ι = 1, 2, ......, ρ）。我们假设图1中有三个处理器，根据每个任务的功能，我们可以将任务系统分为三个子集。如图2所示，相同颜色的任务分配给同一个处理器。更具体地，任务τ1至τ4在C1上执行，任务τ5至τ8被分配给C2，其余任务（例如τ9至τ12）被部署在C3上。

每个任务 τi 以特定周期 Pi 周期性地释放作业，并且我们假设所有任务同时释放其第一个作业。当τi的一个作业被释放时，如果τi的其他作业正在执行或等待执行，则该作业已准备好。否则，该工作将被放弃。只需要执行 τi 的就绪作业。我们用R(τi)表示τi的就绪作业集合，即R(τi) = {Ji,1,···,Ji,x,···}，其中Ji,x表示第x个就绪作业τi 释放，用 ri,x、si,x 和 fi,x 分别表示 Ji,x 的释放时间、开始时间和结束时间。 G 的就绪作业集定义为R (G) = ∪τi∈VR (τi)。 G 的调度是执行 R(G) 的所有就绪作业，使得
- C 的每个处理器在一个时间点最多执行一项作业。 
- R(G) 的每个就绪作业Ji,x 必须在其专用处理器上执行。 
- R(G)的每个就绪作业Ji,x在其释放时间ri,x之后开始执行，即si,x ≥ ri,x。 
- R(G) 的每个就绪作业Ji,x 的执行是抢占式的。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071416206.png)


**示例 2**. 图 2 中 G 的调度部分如图 3 所示。G 的所有任务在时间 0 释放其第一个作业，调度在时间 0 开始。在时间间隔 [0, 66] 内，任务τ3 释放了两个作业，但只执行了其中一个作业，即 τ3 的第二个作业在时间 33 释放时被丢弃，因为当时有一个 τ3 的作业已经被释放并且正在执行。作业 J2,1 在时间 10 被抢占，并在时间 14 恢复。我们使用 J(1) 2,1 和 J(2) 2,1 来表示 J2,1 在不同时间间隔执行的两个部分， 分别。
> 为什么先是J4

需要强调的是，我们不打算详细说明为什么在上面的示例中作业会被抢占，因为本节没有提供调度算法的细节。在 IV（第二阶段），我们将介绍详细的调度算法。 G 的可行调度应满足如下定义的几个时序约束。

**截止日期约束**。R (G) 的每个作业 Ji,x 都与相对期限 Di,x 相关联，因此 Ji,x 的绝对期限 di,x 计算为 di,x = ri,x + Di,x。作业 Ji,x 需要在其绝对截止日期之前完成，即 fi,x ≤ di,x。定义2描述了AD系统的可调度性。

**定义2**. 如果存在 G 的调度，使得R (G) 的所有就绪作业必须在其截止日期前执行，则 G 的任务系统是可调度的，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071430737.png)

**端到端延迟限制**。除了截止时间约束之外，G的可行调度还应该满足更多的时序约束。下面，我们进一步定义两种类型的端到端延迟约束，在详细介绍之前，我们首先介绍一些有用的符号，如下所示。

对于 E 的任何边 (τi, τj)，我们考虑两个作业 Ji,x 和 Jj,y，它们分别是 τi 和 τj 的就绪作业，即 Ji,x ∈ R(τi) 和 Jj,y ∈R(τj ）。如果 Ji,x 是 R(τi) 中最后发布的作业，其截止日期不大于 Jj,y 的发布时间，则我们称 Ji,x 为 Jj,y 的数据生产者，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071436073.png)
在这种情况下，作业 Jj,y 称为 Ji,x 的数据使用者。

**定义 3（生产者-消费者（P-C）链）**。对于任何任务链 π = (τ1, τ2, · · · , τh)，作业序列 κ = (J1,a1 , J2,a2 , · · · , Jh,ah ) 是一个 π 的 P-C 链，如果 
- κ 的第 k 个作业 Jk,ak 是 π 的第 k 个任务 τk 释放的就绪作业，对于每个 k = 1, · · · , h。 
- 第 k 个作业 Jk,ak 是第 (k + 1) 个作业 Jk+1,ak+1 的数据生产者，对于每个 k = 1, · · · , h − 1。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071441280.png)
一般来说，PC链κ的第一个作业J1,a1由传感器任务τ1释放。我们让 J1,a1−1 为早于 J1,a1 发布的 τ1 的最新就绪作业。仅当 e 发生在 J1,a1 释放之前和 J1,a1−1 释放之后，事件 e 才会被 J1,a1 捕获，如图 4 所示。 另一方面，事件 e 的最后一个作业 Jh,ah P-C链κ由控制任务τh释放。当作业 Jh,ah 完成时，它会生成如图 4 所示的控制命令。
κ的数据年龄dte(κ)和反应时间rct(κ)分别定义如下。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071442719.png)

κ 的数据年龄 dte(κ) 表示数据通过 P-C 链 κ 传播的时间量。更具体地，它定义了从κ的第一个作业J1，a1的释放时间到κ的最后一个作业Jh，ah通过使用J1，a1的数据感测产生控制命令的时间的最大持续时间。 κ的反应时间rct(κ)包括事件被捕获以及数据通过P-C链κ传播的过程。它表示从κ的第一个作业J1,a1捕获事件e的时间到κ的最后一个作业Jh,ah生成其控制命令以对事件e做出反应的时间的最大持续时间。为了方便起见，我们用fst(κ)和lst(κ)来表示P-C链κ的第一个作业和最后一个作业，即fst(κ) = J1,a1和lst(κ) = Jh,ah。

我们用 θ(π) 表示任务链 π 的所有 P-C 链的集合，并将 θ(π) 分成几个不相交的子集，如下面的定义所示。

**定义4（P-C链的划分）**。路径 π 的 P-C 链集合 θ(π) 被划分为 θ(π) = θ1 ∪ θ2 · · · ，使得对于任意两条 P-C 链 κ 和 κ′， 
- fst(κ) = fst(κ′) ，如果 κ 和 κ′ 属于 θ(π) 的同一子集，即 κ, κ′ ∈ θk (∀k = 1, 2 · · · )。 
- fst(κ) = fst(κ′)，如果 κ 和 κ′ 属于 θ(π) 的不同子集，即 κ ∈ θk 且 κ′ ε θk′ (k = k′)。
对于 θ(π) 的每个子集 θk，我们分别将 θk 的数据年龄 dte(θk) 和反应时间 rct(θk) 表示为
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071447355.png)

数据年龄 π 表示从采样有效传感器数据到基于该数据输出的最后一个时间点的最长时间间隔的长度。 π反应时间定义为从外部原因发生到该外部原因最早得到完全处理的最长时间间隔的长度。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071453205.png)
例3 我们以任务链π = {τi, τj, τl}为例，图5说明了通过π进行的数据传输和接收。对于每个作业，我们只揭示其逻辑执行时间，即，我们使用向下箭头显示作业被释放并从输入端口读取数据的时间，并使用向上箭头标记作业的截止时间，并在此时作业将数据写入输出端口。边代表工作之间的生产者-消费者关系。作业Jj,2有一个数据生产者Ji,2，并且有三个数据消费者Jl,5、Jl,6和Jl,7。图 5 中 π 有 4 条 P-C 链，即 κ1 = (Ji,2, Jj,2, Jl,5)，κ2 = (Ji,2, Jj,2, Jl,6)，κ3 = (Ji ,2, Jj,2, Jl,7) 和 κ4 = (Ji,3, Jj,3, Jl,8)。 κ1 的第一个作业和最后一个作业分别为 Ji,2 和 Jl,5，即 fst(κ1) = Ji,2 和 lst(κ1) = Jl,5。 κ1和κ3的反应时间和数据年龄如图5所示。前三个P-C链共享相同的第一个作业Ji,2，最后一个P-C链有自己的第一个作业Ji,3。因此，我们记录 θ(π) 的两个子集，即 θ1 = {κ1, κ2, κ3} 和 θ2 = {κ4}。 θ1 的数据年龄等于 κ3 的数据年龄，因为根据（5），κ3 在 θ1 的所有 P-C 链中具有最大数据年龄。 θ1 的反应时间等于 κ1 的反应时间，因为根据（6），κ1 在 θ1 的所有 P-C 链中具有最小的反应时间。

对于每个关键链 π，我们定义数据年龄 (DA) 边界 Bdaπ 和反应时间 (RT) 边界 Brtπ。下面描述端到端延迟约束的可满足性。

**定义 5**. 如果所有关键链的数据年龄和反应时间分别受其 DA 边界和 RT 边界限制，则 G 的调度满足端到端延迟约束，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071524385.png)
上面定义的数据年龄约束和反应时间约束对应于第二章的第三和第二时序约束。如果 G 的调度满足 (1) 和 (9) 中的所有时序约束，则它是可行的。为了获得可行的调度，我们首先设计一个实时调度框架来调度G的任务系统，如第4节所示。然后我们开发了一种时序分析方法，并展示了如何在我们的调度框架下保证时序约束（参见第五节）。

# 四．实时调度框架

在本节中，我们提出了一种多速率 DAG G 的实时调度框架，其中包含如下所述的两个阶段。

## 第一阶段：确定任务的执行模式
正如第III节中提到的G的任务会定期释放作业，但并不是所有释放的作业都有机会执行，即强制删除部分作业，以避免作业重叠和积压。在调度 G 之前，不确定任务的哪些作业可以记录到就绪集R（G）中，这使得分析 AD 系统的时序行为变得困难。为了开发一种更具确定性的调度方法，我们不会在运行时丢弃作业，而是在设计阶段预先定义每个任务的执行模式，并在调度开始之前提前决定应该丢弃哪些作业。在详细介绍之前，我们首先介绍一些有用的符号，如下所示。
我们用 HP 来表示 G 的超周期，即
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071542075.png)
回想一下 Pi 是任务 τi 的周期，lcm 表示“最小公倍数”。对于每个任务τi，我们用Ti来表示τi的虚拟周期，它需要满足以下约束。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071542298.png)
其中“a|b”表示b可以除以a而没有余数。通过使用虚拟周期Ti，我们最终定义τi的执行模式如下。

**定义 6（执行模式）**。对于每个任务τi，其执行模式EMi可以表述如下：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071544220.png)
其中 Di = [Di,1, Di,2, · · · , Di,Ni ] 是相对截止日期的向量； Ti = [Ti,1, Ti,2,····, Ti,Ni ] 是任务 τi 的两个连续就绪作业之间的间隔向量； Ni是虚拟时间内τi释放的就绪作业数量。需满足以下条件：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071546538.png)
根据(11)，必须存在一个向量T i 使得上面的第一项和第二项成立。上面的第三项表明，τi 的作业必须在 τi 的下一个（就绪）作业发布之前完成，这符合第3节中描述的防止作业重叠和积压的要求。执行模式 EMi 可以看作是生成 τi 的就绪作业的“种子”。更具体地，对于每个 x = 1, 2, · · · ，R (τi) 的第 x 个作业 Ji,x 表示为 (ei, ri,x, di,x)，其中 ei 是 Ji 的 WCET， Ji,x的发布时间和绝对期限计算如下
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071552773.png)
其中 σ = rem(x, Ni) 是 x 除以 Ni 的余数。

对于给定的执行模式 EMi，任务 τi 可以被视为广义多帧任务（GMF）[11]：τi = (ei, Di, Ti)。我们将 τi 的密度（在 EMi 下）定义为 δi = eiNi/Ti 。例如，我们将图2中任务τ1的虚拟周期设置为T1 = 50ms，并将τ1的执行模式设计为​​EM1 = ([12, 18] , [20, 30])。 EM1下τ1释放的就绪作业如图6所示。τ1的密度为δ1 = 4/ 25 。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405071612705.png)
## 第二阶段：EDF策略下的实时调度
我们根据最早截止日期优先 (EDF) 策略安排 R(G) 的作业 Ji,x。当作业 Ji,x 被释放时，我们将其分配给任务 τi 的专用处理器。更正式地说，对于任何处理器 Cι (ι = 1, 2, · · · , ρ)，我们维护一个就绪集 ι，并将 Ji,x 添加到 ι 中。当 Ji,x 完成后，将其从 ι 中删除。任何时候，Cι 总是选择 ι 中所有作业中截止日期最早的作业 J* 来执行。如果两个或多个作业的截止日期相同，则会随机选择一个作业来打破平局。

到目前为止，我们已经给出了一个两阶段调度框架来调度多速率DAG G的任务系统，但是本节中仍然没有解决一些关键的技术问题。最重要的问题之一是如何为每个任务确定合适的执行模式，这可能会极大地影响AD系统的可行性。一种直观的方法是，τi 的每个作业一发布就记录到就绪集（τi）中，并且要求 τi 的每个作业在 τi 发布新作业之前完成。这一要求转化为隐式截止时间 τi，它等于任务周期 Pi，因此，τi 的执行模式 EMi 定义为

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405072103684.png)
尽管（15）的执行模式在文献[7]中被广泛采用，但它并不是最佳选择。主要缺点列举如下。
- <span style="color:black;background:#fff88f !important;">执行模式为（15）的任务系统会生成最密集的就绪作业，其工作量太大而无法调度，</span>因此常常无法满足（1）中定义的截止时间约束。 
- <span style="color:black;background:#fff88f !important;">虽然（15）的执行模式生成的作业始终可以具有最小的端到端延迟，但有些作业产生的数据无法被控制作业使用，因此不需要执行。</span>在删除这些冗余作业后，也可以满足（9）中的端到端延迟约束。


















***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考
