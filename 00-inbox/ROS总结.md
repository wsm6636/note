---
tags:
  - 笔记
  - 待归档
created: 2024-04-07T16:29
updated: 2024-05-17T14:56
status:
  - todo
---
# 背景



# 架构
ROS2 可以分为四个层次，自顶向下依次为应用层、客户端层、中间件层和操作系统层。
![image.png](https://raw.githubusercontent.com/wsm6636/pic/main/202405161457570.png)


从逻辑角度来看，ROS 应用程序由节点组成，节点是最小的独立行为单元。这些节点使用发布-订阅范例进行通信：节点发布有关主题的消息，这些消息将消息广播到订阅该主题的所有节点。节点通过激活回调来处理每条消息来对传入消息做出反应。由于这些回调本身可能会发布消息，因此可以将复杂的行为实现为主题和回调的网络。 ROS 还允许回调通过使用连续传递样式的服务机制来调用远程过程调用。具体来说，回调可以向服务回调发起非阻塞服务请求，并指定一旦响应可用就调用第三个客户端回调。

一个 ROS2 应用程序一般包含一个或多个节点，每个节点负责完成某个相对独立的子功能（例如，物体检测、定位），不同的节点通过 ROS2 的通信机制进行数据传输。一个节点（即 C++中的一个类）可以包含一个或多个回调。每个回调是一个函数，包含实现节点部分功能的代码。

将每个回调视为一个任务，一个或多个节点映射到操作系统中的一个进程。执行器负责协调和调度进程中的各个回调，正如图 2.3描述的 ROS2 应用程序结构
![image.png](https://raw.githubusercontent.com/wsm6636/pic/main/202405161534887.png)


要部署 ROS 应用程序，必须将各个节点分发到主机，然后映射到操作系统进程。 ROS 对此映射不施加任何限制。进程通过运行执行器来实现ROS执行模型，执行器接收来自rcl的消息并调用相应的回调。 ROS 提供了两种内置执行器：一种是在单个线程中执行回调的顺序执行器，另一种是在多个线程之间分配待处理回调的处理。此外，ROS 支持多个用户定义的执行器的任意复杂设置。

（1）单线程执行器：使用单个线程调度进程中所有实体的回调函数。如图2.4 所示的单线程执行器处理流程，该流程由两个主要循环构成。在左侧循环中，执行器负责收集 DDS 中就绪的实体，并将它们的回调函数加入到就绪集合中。如果就绪集合在一段时间内始终未发生变化，执行器将转变为阻塞状态。在右侧循环中，首先检查定时器是否已经到达设定时间，若超时，则执行相应的回调函数；若未超时，则继续进行后续的检查流程。对于处于就绪集中的实体，执行器将依次执行对应的回调函数，并在执行完毕后将其从集合中移除。每完成一个回调函数的执行，右侧循环便会重新启动。当就绪集中所有回调函数处理完毕，执行器将退出右侧循环并开始下一轮的处理流程。在单线程执行器中，回调函数是顺序执行的。若回调函数之间存在不合理的相互等待，可能会导致死锁的发生
![image.png|500](https://raw.githubusercontent.com/wsm6636/pic/main/202405161552001.png)



## 5. ROS2的调度模型（单线程执行器）

单线程执行器（Single Thread Executor）根据回调函数的优先级来决定它们的执行顺序。 回调函数的优先级取决于： 回调的类型和注册顺序（Registration Order）。

回调的类型（按照优先级降序排列）：

1. 定时器回调 𝐶𝑡𝑚𝑟 ：由系统定时器触发，一般是<font color="#ff0000">周期性触发</font>。一个回调链由多个回调组成。而<font color="#ff0000">第一个回调通常是定时器回调</font>。 它在 4 种回调类型中具有最高优先级。

2. 订阅型回调 𝐶𝑠𝑢𝑏 ：基于Publish-Subscribe这种通信机制。优先级排第二。

3. 服务型回调 𝐶𝑠𝑟𝑣 : 基于Service-Client和Actions这两种通信机制中的Service.优先级排第三。

4. 客户型回调 𝐶𝑐𝑙𝑡 ：基于Service-Client和Actions这两种通信机制中的Client. 最低优先级。

<span style="background:#40a9ff">为什么没有发布者回调？这是因为在一个回调链中，第一个回调通常是定时器回调，它向后发送数据，而后面的订阅者回调同时也扮演着发布者的角色。</span>

为什么优先级如此排 ？这是因为在这三种通信机制中，Publish-Subscribe最为常见，其次是Service-Client和Actions.

如何比较两个回调的优先级？<span style="background:#d3f8b6">如果两个回调的类型不同，则比较它们的类型。如果它们的类型相同，则比较他们的注册顺序。先注册的优先级更高。</span>

![image.png|675](https://raw.githubusercontent.com/wsm6636/pic/main/202405171054057.png)

首先，如果Readyset 为空，那么执行器将所有就绪（ready）的常规回调放入Readyset。常规回调是除了定时器回调之外的回调。

**Readyset 更新的时间点称为轮询点**。<span style="background:#40a9ff">两个相邻轮询点之间的时间间隔称为处理窗口(Processing Window)。定时器回调不需要等待轮询点。</span>

图的下半部分显示了不同类型回调的执行顺序。我们总是首先执行 定时器回调，然后是订阅型回调，然后是服务型，最后是客户型。

如果某些回调具有相同的类型，我们将根据它们的注册顺序执行它们。更早在执行器上注册的回调则具有更高的优先级。如果回调有多个实例，则只有第一个实例可以执行。

<span style="background:#40a9ff">如果 Readyset 中所有回调的第一个实例都执行了，也就是说ReadySet 是空集，那我们就到达下一个轮询点，新的处理窗口将开始。</span>

需要注意的是：

- 在每个处理窗口中，每个回调只有第一个实例可以执行。
- 常规回调只能在轮询点加入到ReadySet中。
- 定时器回调不受轮询点的约束。

