---
tags:
  - 笔记
  - 待归档
  - 笔记/学习笔记
created: 2024-04-07T16:29
updated: 2024-05-24T10:10
status:
  - ing
---
# 背景



# 架构
ROS2 可以分为四个层次，自顶向下依次为应用层、客户端层、中间件层和操作系统层。
![image.png|450](https://raw.githubusercontent.com/wsm6636/pic/main/202405161457570.png)


从逻辑角度来看，ROS 应用程序由节点组成，节点是最小的独立行为单元。这些节点使用发布-订阅范例进行通信：节点发布有关主题的消息，这些消息将消息广播到订阅该主题的所有节点。节点通过激活回调来处理每条消息来对传入消息做出反应。由于这些回调本身可能会发布消息，因此可以将复杂的行为实现为主题和回调的网络。 ROS 还允许回调通过使用连续传递样式的服务机制来调用远程过程调用。具体来说，回调可以向服务回调发起非阻塞服务请求，并指定一旦响应可用就调用第三个客户端回调。

一个 ROS2 应用程序一般包含一个或多个节点，每个节点负责完成某个相对独立的子功能（例如，物体检测、定位），不同的节点通过 ROS2 的通信机制进行数据传输。一个节点（即 C++中的一个类）可以包含一个或多个回调。每个回调是一个函数，包含实现节点部分功能的代码。

将每个回调视为一个任务，一个或多个节点映射到操作系统中的一个进程。执行器负责协调和调度进程中的各个回调，正如图 2.3描述的 ROS2 应用程序结构
![image.png|475](https://raw.githubusercontent.com/wsm6636/pic/main/202405161534887.png)


要部署 ROS 应用程序，必须将各个节点分发到主机，然后映射到操作系统进程。 ROS 对此映射不施加任何限制。进程通过运行执行器来实现ROS执行模型，执行器接收来自rcl的消息并调用相应的回调。 ROS 提供了两种内置执行器：一种是在单个线程中执行回调的顺序执行器，另一种是在多个线程之间分配待处理回调的处理。此外，ROS 支持多个用户定义的执行器的任意复杂设置。

（1）单线程执行器：使用单个线程调度进程中所有实体的回调函数。如图2.4 所示的单线程执行器处理流程，该流程由两个主要循环构成。在左侧循环中，执行器负责收集 DDS 中就绪的实体，并将它们的回调函数加入到就绪集合中。如果就绪集合在一段时间内始终未发生变化，执行器将转变为阻塞状态。在右侧循环中，首先检查定时器是否已经到达设定时间，若超时，则执行相应的回调函数；若未超时，则继续进行后续的检查流程。对于处于就绪集中的实体，执行器将依次执行对应的回调函数，并在执行完毕后将其从集合中移除。每完成一个回调函数的执行，右侧循环便会重新启动。当就绪集中所有回调函数处理完毕，执行器将退出右侧循环并开始下一轮的处理流程。在单线程执行器中，回调函数是顺序执行的。若回调函数之间存在不合理的相互等待，可能会导致死锁的发生
![image.png|500](https://raw.githubusercontent.com/wsm6636/pic/main/202405161552001.png)



## 5. ROS2的调度模型（单线程执行器）

单线程执行器（Single Thread Executor）根据回调函数的优先级来决定它们的执行顺序。 回调函数的优先级取决于： 回调的类型和注册顺序（Registration Order）。

回调的类型（按照优先级降序排列）：

1. 定时器回调 𝐶𝑡𝑚𝑟 ：由系统定时器触发，一般是<font color="#ff0000">周期性触发</font>。一个回调链由多个回调组成。而<font color="#ff0000">第一个回调通常是定时器回调</font>。 它在 4 种回调类型中具有最高优先级。

2. 订阅型回调 𝐶𝑠𝑢𝑏 ：基于Publish-Subscribe这种通信机制。优先级排第二。

3. 服务型回调 𝐶𝑠𝑟𝑣 : 基于Service-Client和Actions这两种通信机制中的Service.优先级排第三。

4. 客户型回调 𝐶𝑐𝑙𝑡 ：基于Service-Client和Actions这两种通信机制中的Client. 最低优先级。

<span style="background:#40a9ff">为什么没有发布者回调？这是因为在一个回调链中，第一个回调通常是定时器回调，它向后发送数据，而后面的订阅者回调同时也扮演着发布者的角色。</span>

为什么优先级如此排 ？这是因为在这三种通信机制中，Publish-Subscribe最为常见，其次是Service-Client和Actions.

如何比较两个回调的优先级？<span style="background:#d3f8b6">如果两个回调的类型不同，则比较它们的类型。如果它们的类型相同，则比较他们的注册顺序。先注册的优先级更高。</span>

![image.png|675](https://raw.githubusercontent.com/wsm6636/pic/main/202405171054057.png)

首先，如果Readyset 为空，那么执行器将所有就绪（ready）的常规回调放入Readyset。常规回调是除了定时器回调之外的回调。

**Readyset 更新的时间点称为轮询点**。<span style="background:#40a9ff">两个相邻轮询点之间的时间间隔称为处理窗口(Processing Window)。定时器回调不需要等待轮询点。</span>

图的下半部分显示了不同类型回调的执行顺序。我们总是首先执行 定时器回调，然后是订阅型回调，然后是服务型，最后是客户型。

如果某些回调具有相同的类型，我们将根据它们的注册顺序执行它们。更早在执行器上注册的回调则具有更高的优先级。如果回调有多个实例，则只有第一个实例可以执行。

<span style="background:#40a9ff">如果 Readyset 中所有回调的第一个实例都执行了，也就是说ReadySet 是空集，那我们就到达下一个轮询点，新的处理窗口将开始。</span>

需要注意的是：

- 在每个处理窗口中，每个回调只有第一个实例可以执行。
- 常规回调只能在轮询点加入到ReadySet中。
- 定时器回调不受轮询点的约束。

值得强调的是，ROS 回调调度程序与文献中常见的调度程序有何不同。首先，它按类型对回调进行优先级排序：计时器本质上优先于订阅，订阅优先于服务处理程序，而服务处理程序又优先于客户端。其次，它并不认为所有挂起的回调都有资格执行。相反，轮询回调仅在激活后的第一个轮询点才符合资格。第三，执行器在每个处理窗口中最多执行每个轮询回调的一个实例，无论排队激活的数量是多少。

- **轮询点（Polling Point）**：执行器在需要选择下一个要执行的实例但当前没有可用实例时会到达轮询点。

# 同步
ROS2中使用`ApproximateTime`策略来同步具有近似时间戳的多个话题的消息，这对于处理来自不同传感器的数据流非常有用，尤其是在传感器数据采集时间不完全同步的情况下。通过这种方式，可以确保数据的一致性和准确性，从而提高机器人系统的性能和可靠性

采用一个同步节点订阅来自多个其他节点的消息，在同步节点采用同步器（策略）融合来自不同话题（传感器、程序。。。）的数据，整合后输出给其他需要的节点

# 流程
当然，让我们通过文字描述来详细了解从`time_01_node`和`time_02_node`节点开始，经过同步节点`sync_node`，到输出后续节点的整个流程。

### 步骤 1: 初始化`time_01_node`和`time_02_node`节点

这两个节点分别负责从不同的传感器获取数据，并发布到ROS2系统中。

- `time_01_node`节点初始化，订阅传感器数据（例如，相机图像），创建一个ROS2发布者，并将图像数据发布到`/camera/image_raw`话题。
- `time_02_node`节点初始化，订阅另一个传感器的数据（例如，激光雷达的点云），创建一个ROS2发布者，并将点云数据发布到`/lidar/point_cloud`话题。

### 步骤 2: 创建同步节点`sync_node`

`sync_node`节点的目的是同步来自`time_01_node`和`time_02_node`的图像和点云数据。

- `sync_node`节点初始化，并创建两个订阅者，分别订阅`/camera/image_raw`和`/lidar/point_cloud`话题。
- 使用`message_filters`包中的`ApproximateTime`同步策略和同步器，将这两个订阅者的消息同步。
- 设置同步器的队列大小，以确定在找到匹配的消息对之前，每个话题可以存储多少条消息。

### 步骤 3: 定义同步回调函数

- 在`sync_node`中定义一个回调函数，该函数将在同步器接收到匹配的消息对时被调用。
- 回调函数将执行图像和点云数据的融合操作，例如，将点云数据投影到图像上，或者将图像数据与点云数据结合，以获得更丰富的环境信息。

### 步骤 4: 注册回调函数并启动同步

- 将回调函数注册到同步器上，以便在接收到同步消息时自动调用。
- 使用`rclcpp::spin`或`rclcpp::spin_some`启动`sync_node`节点，使其保持运行状态并响应同步事件。

### 步骤 5: 同步后的数据输出

- 在回调函数中，处理和融合图像与点云数据后，创建一个新的消息类型（例如，`sensor_msgs::msg::ImagePointCloud`），将融合后的数据封装在新消息中。
- 创建一个新的发布者，将融合后的消息发布到新的话题，如`/synced/image_pointcloud`。

### 步骤 6: 后续节点处理

- 其他节点（例如，处理节点或决策节点）订阅`/synced/image_pointcloud`话题。
- 当这些节点接收到融合后的消息时，它们可以执行进一步的处理，如物体识别、场景重建或导航决策。

### 步骤 7: 维护和监控

- 在整个过程中，`sync_node`和其他相关节点可能需要监控和日志记录，以确保数据同步和处理按预期进行。
- 如果出现同步问题或数据质量问题，可能需要调整同步策略或参数。

这个例子展示了如何在ROS2中使用`ApproximateTime`同步策略来同步来自不同传感器的数据流，并通过一个同步节点将它们融合，然后输出到系统中的其他节点进行进一步的处理。


# 事件触发，伪回调
在文章中提到的 "伪回调"（pseudo-callbacks）是指模拟ROS中回调行为的构造，这些并不是实际的回调函数，但用于模拟或表示那些不是由ROS系统内部生成，而是由外部事件触发的行为。伪回调用于将外部事件（例如传感器输入、网络数据包或用户操作）集成到ROS系统中。

在ROS中，回调通常是指当某个事件发生时（比如接收到消息、服务请求完成等），系统自动执行的函数。这些回调函数是ROS节点响应外部事件的方式。然而，<font color="#ff0000">外部事件源（event sources）并不直接以ROS回调的形式存在，但它们可以通过发布消息到ROS主题来触发一系列ROS回调。</font>

伪回调的作用包括：
- **接口或入口点**：作为外部事件进入ROS系统的接口或入口点。
- **模拟外部触发**：模拟那些不是由ROS调度，而是由外部事件动态触发的行为。
- **数据驱动激活**：在数据到达时触发相应的ROS回调，从而实现数据驱动的激活语义。

伪回调在建模和分析ROS系统时非常有用，因为它们允许研究者和开发者考虑和集成那些来自系统外部的、可能影响系统行为的事件。在进行实时性能分析时，伪回调帮助分析人员理解和预测这些外部事件如何影响系统的响应时间和调度特性。

# 相关工作
卡西尼等人。提出了 ROS 2 处理链的第一个响应时间分析 [3]。唐等人。 [4]随后对独立线性处理链的特殊情况提供了更精确的分析，但代价是适用性更有限（即<span style="background:#fdbfff">每个回调只能属于一个链</span>）。因此，Tang 等人的分析 [4] 不适用于第 2 节中考虑的工作负载，其中包含分支处理链。
> 属于多个链就相当于那个干扰的问题


在更远相关的工作中，唐等人。 [18] 最近开发了一种针对 ROS 启发的调度程序的分析，该调度程序也表现出类似循环的属性。由于他们的分析仅考虑独立任务的系统，因此它不容易转移到本文考虑的通用 ROS 系统。此外，其他基于图形的框架（例如 OpenMP [19, 20] 和 Tensorflow [21]）的先前时序分析具有相似的目标和本文研究的一些挑战。除了提供分析保证之外，研究人员还通过许多其他方式探索了 ROS 2 中的实时要求，包括对延迟效应的实证研究 [22]–[26]。

在另一项工作中，Choi 等人。 [5] 和 Staschulat 等人。 [27] 探索了具有改进的时间可预测性的替代 ROS 执行器设计。相比之下，我们的重点是主线 ROS，因为当今大多数 ROS 用户都部署了它。 Blass 等人还针对未修改的主线 ROS 部署。 [6]提出了一种基于内省的自动化方法，用于在基于预留的调度下配置 ROS 执行器。

# 多回调
在处理多个回调函数时，ROS按照接收消息的顺序依次执行它们。这样可以确保消息按照它们到达的顺序被处理，不会出现乱序的情况。这种机制允许节点同时处理来自不同话题的消息，提高了系统的并发处理能力。

接下来，我们来探讨ROS中的消息队列。在ROS中，消息队列是一个用于缓存消息的机制。当订阅者接收到消息时，它不会立即处理这些消息，而是将其放入一个队列中等待处理。这样可以避免由于回调函数的执行速度过慢而导致的数据丢失问题。

消息队列的作用是在回调函数来不及处理信息时，将这些信息及时缓存起来。这样即使回调函数的执行速度较慢，也不会导致数据的丢失。通过合理设置消息队列的长度，可以平衡系统的实时性和数据处理能力。如果需要快速响应，可以将队列长度设置为较小值；如果对数据处理能力有更高要求，则可以设置较大的队列长度。

在实际应用中，对于需要处理大量数据或对实时性要求较高的


在ROS 2中，默认情况下，节点发布到多个话题的消息是并发处理的，也就是说，并没有内置的机制来保证消息的发布顺序。每个发布者（Publisher）是独立运行的，它们可以同时发布消息，而ROS 2的底层通信机制（如DDS或Fast RTPS）负责将这些消息传递给相应的订阅者（Subscriber）。