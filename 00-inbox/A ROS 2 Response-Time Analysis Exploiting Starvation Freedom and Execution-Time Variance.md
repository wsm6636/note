---
created: 2024-03-27T18:55
updated: 2024-05-22T15:56
tags:
  - 笔记
  - 笔记/文献笔记
  - 待归档
status:
  - ing
---
# A ROS 2 Response-Time Analysis Exploiting Starvation Freedom and Execution-Time Variance
 

**TitleTranslation:**  利用饥饿自由和执行时间方差的 ROS 2 响应时间分析
**Journal or Conference:**   2021 IEEE Real-Time Systems Symposium (RTSS)  
**Authors:**  TobiasBlaß, DanielCasini, SergeyBozhko, Björn B.Brandenburg
**Pub.date:**  2021-12
**DOI:**  10.1109/RTSS52674.2021.00016
**tags:** #/ing, schedule
**zoterolink:**  [zotero](zotero://select/library/items/T3SKYEYK)

# 摘要

机器人通常受到实时限制。为了确保满足这些限制，最近的工作分析了 ROS 2（一种流行的机器人框架）下处理链的响应时间。然而，先前的工作仅支持标量最坏情况执行时间界限，并且没有利用 ROS 2 调度机制的无饥饿性。

本文提出了一种针对 ROS 2 处理链的新颖响应时间分析，该分析既考虑了机器人工作负载中通常遇到的高执行时间方差，又考虑了默认 ROS 2 回调调度程序的饥饿自由度。综合回调图和真实 ROS 2 工作负载的实验结果从经验上表明，所提出的分析要准确得多（通常是 2 倍或更多）。

# 1引言
在常用的机器人编程框架中，ROS[1]无疑是应用最广泛的框架之一：根据2020年7月发布的ROS社区指标[2]，它有数千名用户使用，用户数量增长了33% 2019 年以来，其受欢迎的原因包括灵活的通信基础设施、较低的进入门槛，以及最重要的一个充满活力的生态系统，它允许开发人员快速集成经过广泛测试的组件，而不是从头开始重新实现常见功能。

计时正确性是此类系统的主要挑战。近年来，实时社区已经开始通过开发 ROS 2 系统的响应时间分析来解决这个问题 [3]-[5]。与传统的实时系统相比，ROS1 系统带来了两个额外的挑战。首先，ROS 系统并不由独立的任务组成，而是由交互回调的网络组成。分析必须处理回调之间的依赖性，并且必须限制整个回调链的响应时间。其次，回调被复用到共享执行器线程上，这些执行器线程使用与常见实时调度程序显着不同的自定义调度策略来执行回调。因此，分析不仅要考虑操作系统对执行程序线程的调度，还要考虑执行程序内的回调排序。

在本文中，我们从三个维度改进了 ROS 的先前分析：<span style="background:#ff4d4f">处理器需求的精炼模型</span>、不太悲观的回调激活模型以及利用 ROS 执行器回调调度算法中的饥饿自由度的改进响应时间分析。

改进的处理器需求模型解决了先前的分析仅支持标量最坏情况执行时间（WCET）的问题，这意味着任何回调激活的处理器需求都具有单一的、通常是悲观的界限。相比之下，ROS 回调通常表现出高度可变的执行时间 [6]，这很难用单个标量来表示。这种执行时间最好被描述为执行时间曲线。首先由 Quinton 等人提出。与 ET + 函数 [7] 一样，执行时间曲线是描述多个连续实例的累积处理器需求的通用方法。在本文中，我们使用执行时间曲线对回调的处理器需求进行建模。然而，利用更丰富的描述给分析带来了重大挑战（第 IV-D 节）。

在正交方向上，我们改进了回调激活模型，以更好地考虑分配给同一执行器的回调之间的激活。因此，我们获得了执行程序内激活的更准确的界限（第五节），而无需对回调图施加额外的约束。

最后，我们开发了一种新的分析来利用 ROS 执行器中调度机制的一个关键属性，即它提供饥饿自由：<span style="background:#ff4d4f">执行器以循环方式执行回调，防止任何单独的回调占用执行器。</span>之前已经认识到，这使得正确确定回调的优先级变得困难，甚至不可能 [3, 5]。然而，这种设计还可以通过限制竞争回调的干扰来减少最坏情况的响应时间，特别是在突发激活竞争回调的情况下，但之前的分析未能捕捉到这一积极方面。在本文中，我们提出了一种新的响应时间分析，该分析利用了循环属性的优势（第四节）。

我们在合成回调图和广泛使用的 ROS 包上评估了所提出的分析。实证结果表明，这三项改进中的每一项都会导致更严格的响应时间界限，并且它们共同产生更准确的总体界限。它还表明，新的循环分析和传统的繁忙窗口方法在不同的情况下是最有效的，因此两者的组合产生最佳的响应时间界限（第六节）。

# 二.背景
ROS 框架由一堆层组成，如图 1 所示。ROS 用户和开发人员与顶部的特定于语言的层进行交互，这些层提供了特定于语言的 API 来定义 ROS 应用程序。在这项工作中，我们重点关注 C++ 接口，我们认为它是目前最适合时间敏感应用程序的选择。
![image.png|650](https://raw.githubusercontent.com/wsm6636/pic/main/202405221233329.png)

从逻辑的角度来看，ROS应用程序由回调和主题组成。通信遵循发布订阅范例：回调将消息发布到主题，其中每条消息都会触发订阅该主题的回调。或者，回调也可以由计时器触发。交互回调和主题的结果图（如图 1 的上半部分所示）实现了机器人的复杂动态行为。

ROS还通过服务以及相关的服务处理程序和客户端回调提供异步远程过程调用（RPC）设施。从 ROS 调度程序的角度来看，这些回调的行为与常规订阅回调相同。因此，我们在<span style="background:#ff4d4f">本文中不区分主题和服务；我们的分析同样适用于两者。</span>

在特定语言层之下，rcl 库实现了 ROS 的核心功能。这保证了不同编程语言之间的一致行为并提供了通用的系统模型。 rcl 层位于 rmw 层之上，它为底层通信中间件（通常是 DDS [8]）提供通用 API。

ROS 调度策略和执行模型由执行器实现，执行器选择待处理回调的执行顺序。虽然 ROS 原则上支持任意用户定义的执行器，但它提供了两种常用的内置实现，一种是单线程的，一种是多线程的。本文仅关注 ROS 提供的单线程执行器（默认解决方案）。

执行器通过按顺序考虑每一类回调来选择下一个要运行的回调：首先是计时器，然后是订阅、服务处理程序，最后是客户端。在每个类中，回调按注册顺序考虑，即在进程启动时向运行时系统注册的顺序。总体而言，回调类型和注册时间的组合唯一地确定了每个回调的优先级。<span style="background:#d3f8b6">一旦选择，所选回调必须运行完成，然后执行器才能选择下一个要运行的回调。</span>

ROS 调度程序的一个特点是，在每次调度决策之前，就绪实例列表不会更新。对于大多数回调类，每个回调的就绪状态仅从底层不规则地轮询并缓存在 rclcpp 层中。我们将此类回调称为轮询回调。相反，一类特权回调的准备状态在每次调度决策之前更新。

回调是轮询还是特权由 ROS 实现决定。在 ROS 2“Dashing”之前的版本中，计时器具有特权，但所有其他类都会被轮询 [3]。在更高版本中，计时器也是轮询回调[9]。

执行器按照上述顺序运行回调。完成后，轮询的回调​​将从缓存中删除。仅当所有回调都被删除时，即当缓存变空时，执行器才会轮询就绪回调列表以刷新缓存，然后重新开始处理缓存的回调。我们将执行器的挂起回调缓存刷新的时间点称为轮询点，并将两个连续轮询点之间的间隔称为处理窗口。缓存的一个重要属性是它一次最多存储每个回调的一个就绪实例。因此，执行器在每个处理窗口中最多运行每个轮询回调的一个实例。

值得强调的是，ROS 回调调度程序与文献中常见的调度程序有何不同。首先，它按类型对回调进行优先级排序：计时器本质上优先于订阅，订阅优先于服务处理程序，而服务处理程序又优先于客户端。其次，它并不认为所有挂起的回调都有资格执行。相反，轮询回调仅在激活后的第一个轮询点才符合资格。第三，执行器在每个处理窗口中最多执行每个轮询回调的一个实例，无论排队激活的数量是多少。

# 三．系统模型
根据之前的工作 [3]，我们将系统建模为一组回调 C，每个回调都会激活潜在的无限实例序列。每个回调 ci ∈ C 被静态分配给 k 个单线程执行器 E1,... , Ek之一;为了符号方便，我们让 ei 表示回调 ci 的指定执行器。我们假设一个稳态系统（即，回调在运行时既不离开也不加入系统）和离散时间模型，其中所有时间参数都是基本时间单位 1（例如，处理器周期）的整数倍。

ROS系统的一些输入通常来自回调系统外部，例如设备。这通常是通过将外部刺激转换为 ROS 发布的外部驱动程序线程来实现的。为了保持一致性，我们将此类线程建模为具有单个伪回调的执行器。这个回调，我们称之为事件源，代表驱动程序线程的计算需求和通信行为。

我们按类型划分所有回调的集合，并让 Ctmr、Cevt、Csub、Csrv 和 Cclt 分别表示所有计时器、事件源、订阅者、服务和客户端的集合。最后三类统称为消息驱动回调集 C msg =C sub ∪C srv ∪C clt 。我们进一步让 C k 表示分配给执行器 E k 的所有回调的子集，以便 C tmr k 表示分配给执行器 E k 的所有计时器的子集，等等。最后， lp k (ci ) 和 hp k (ci ) 表示C k 中的所有回调的优先级分别低于或高于 c i 。

我们区分轮询回调集 C pol 和特权回调集 C prv ，其中 C pol ∪C prv = C。在“Dashing”之前的 ROS 版本中，仅轮询消息驱动的回调：C pol C msg 。<span style="background:#d3f8b6">在更高版本中，计时器也会被轮询：C pol C msg ∪C tmr 。事件源始终具有特权。</span>

每个回调 c i 由激活曲线 η i (Δ) 描述，该曲线限制长度为 Δ [10]–[12] 的任何时间窗口内激活数量的上限（如果 Δ ≤ 0，则 η i (Δ) = 0） 。对于计时器回调和事件源，激活曲线作为问题规范的一部分给出。对于消息驱动的回调，激活曲线是通过分析得出的（第五节）。
[Response Time Analysis and Priority Assignment of Processing Chains on ROS2 Executors](Response%20Time%20Analysis%20and%20Priority%20Assignment%20of%20Processing%20Chains%20on%20ROS2%20Executors.md)

**实例生命周期**。每当发生类型相关事件时，每个回调都会激活一个实例：事件源的外部刺激、计时器的新周期或消息驱动回调的传入消息。我们将回调 c i 的第 k 个实例称为 c k i 。每个回调实例都会经历几个阶段，如图 2 所示。

![image.png](https://raw.githubusercontent.com/wsm6636/pic/main/202405221556254.png)














***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考
