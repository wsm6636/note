---
created: 2024-03-27T18:55
updated: 2024-05-21T23:26
tags:
  - 笔记
  - 笔记/文献笔记
  - 待归档
status:
  - todo
---
# PiCAS: New Design of Priority-Driven Chain-Aware Scheduling for ROS2
 



**TitleTranslation:**  PiCAS：ROS2 优先级驱动链感知调度的新设计
**Journal or Conference:**   2021 IEEE 27th Real-Time and Embedded Technology and Applications Symposium (RTAS)  
**Authors:**  HyunjongChoi, YechengXiang, HyoseungKim
**Pub.date:**  2021-05
**DOI:**  10.1109/RTAS52030.2021.00028
**tags:** 
**zoterolink:**  [zotero](zotero://select/library/items/6BQDM4K6)

# 摘要

在ROS（机器人操作系统）中，时间和安全关键领域的大多数应用程序都是以具有数据依赖性的回调链的形式构建的。由于ROS在实时支持方面的缺陷，无法提供强有力的时序保证，可能会导致灾难性的结果。尽管ROS2声称增强了实时能力，但确保可预测的端到端链延迟仍然是一个具有挑战性的问题。在本文中，我们为 ROS2 框架提出了<span style="background:#ff4d4f">一种新的优先级驱动的链感知调度程序</span>，并为所提出的调度程序提供了端到端延迟分析。使用我们的调度程序，<span style="background:#ff4d4f">根据相应链的给定时序要求对回调进行优先级排序，以便可以在可预测的范围内改善关键链的端到端延迟</span>。所提出的调度设计包括考虑所有 ROS2 调度相关抽象（例如回调、节点和执行器）的优先级分配和资源分配。据我们所知，这是第一个通过提出新的调度器设计来解决 ROS2 在端到端延迟方面的固有局限性的工作。我们已经在 NVIDIA Xavier NX 上运行的 ROS2 中实现了调度程序。我们进行了案例研究和可调度性实验。结果表明，与默认的 ROS2 调度程序和现实场景中的最新工作相比，所提出的调度程序在端到端延迟方面有了显着的改善。
# 一、简介
ROS（机器人操作系统）[4]是最流行的机器人应用开源中间件框架之一。 ROS 的出现彻底改变了工业界和学术界的开发者社区，提供了大量工具、机器人系统和构建新应用程序的最佳实践 [3]。在短时间内取得如此高效的机器人软件开发成就的背后，软件的模块化和可组合性发挥了重要作用。然而，几十年来，ROS 在对计时和安全关键型应用程序的实时支持方面暴露出了缺陷。这激励了社区第二代 ROS ROS2 的开发。

ROS2[6]自2017年开始开发，主要考虑提高实时能力。尽管大多数概念继承自原始ROS框架，但ROS2采用了独特的功能，包括通过数据分发服务（DDS）进行节点间通信，这是实时数据分发的行业标准[2]。 ROS2的新架构旨在更好地支持实时机器人软件。然而，它仍然不能保证严格的时序约束，系统设计人员需要凭经验调整时序相关参数。

保证 ROS2 中安全关键应用程序的时序约束是一项至关重要的功能，因为违反这些约束可能会导致灾难性后果，例如，ROS 导航包对自动驾驶车辆的路径跟踪控制的延迟响应可能会导致追尾事故。此外，由于以下原因，提供此类时序保证也具有挑战性。首先，此类应用程序通常形成一条链，该链由一组具有数据依赖性的回调组成。因此，系统设计者需要知道链的端到端延迟的安全上限。其次，虽然许多先前的研究提出了端到端链延迟的分析技术[7,9,12,21]，但由于其独特的调度行为（由执行器和执行器等各种抽象引起），它们不能直接应用于ROS2框架。节点（详见第 III-B 节）。

据我们所知，最近唯一正式分析实时保证的 ROS2 调度架构的工作是 Casini 等人所做的研究。 [11]。他们特别专注于分析执行器内的回调链，这是 ROS2 的核心调度实体之一。它是 ROS2 实时工作的开创性成果，为研究界提供了分析基础。然而，还有许多未解决的问题，例如，它只关注执行器内的调度行为，而没有考虑多核系统中调度实体对执行器和CPU核的分配。此外，端到端延迟分析受到 ROS2 调度架构的限制，这激发了新调度器设计的开发。

在本文中，我们提出了 PiCAS，这是一种多核环境中用于 ROS2 的优先级驱动的链感知调度器。我们工作的目标是根据链的关键性和时序要求优先执行链回调，从而最大限度地减少端到端链延迟。我们在 ROS2“Eloquent Elusor”版本中实现了 PiCAS，并在真实的嵌入式平台上评估了其性能。本文的主要贡献如下： 
- 我们提出了PiCAS 的设计，包括回调的优先级分配以及多核平台中执行器的节点分配以及CPU 核的执行器分配。 PiCAS 使回调和执行器执行，同时尊重链的端到端时序要求。 
- 我们在提议的PiCAS 框架下对链的端到端延迟进行了上限分析。该分析提供了链的端到端延迟的安全界限。
- 我们使用嵌入式平台上的实际场景进行了案例研究，并使用随机工作负载进行了可调度性实验。实验结果表明，与默认的 ROS2 调度程序和最新的分析工作相比，我们提出的调度程序在端到端延迟方面有了显着的改善。

# 二.相关工作
ROS 的大多数工作都集中在提高实时功能 [26,27,29]。在[26]中，Saito 等人。提出了一种基于优先级的消息传输机制，允许发布者根据其优先级发送数据。魏等人。 [29]提出了一种混合操作系统平台，通过运行两个操作系统分别执行实时ROS节点（在Nuttx上）和非实时ROS节点（在Linux上）。在[27]中，ROSCH-G是一个可加载的内核框架，被提议作为具有CPU/GPU协调机制的ROS的实时扩展。然而，这些研究没有提供保证实时时序约束的分析方法，或者仅应用于第一代ROS。

对于 ROS2，Maruyama 等人。 [23]在不同供应商特定的 DDS 实现下对各种 QoS 配置进行了实证评估。在[16]中，测量了两个节点之间最坏情况的延迟，并在修补了 PREEMPT-RT 的 Linux 内核系统中观察了截止时间错过行为。这两项研究都使用基于测量的方法评估了 ROS2 的性能，但没有提供正式的建模或分析。

已经进行了许多研究来分析发布者-订阅者模型或读取执行-写入语义中的端到端链延迟。帕伦西亚等人。提出了分析多核系统中具有优先级约束的任务的方法 [24, 25]。在[15, 28]中，基于最坏情况的响应时间提出了捕获任务端到端延迟上限的方法。克洛达等人。 [21]，阿卜杜拉等人。 [7]和贝克尔等人。 [9]提出了在固定优先级调度下限制链的端到端延迟的分析方法。 Choi 等人的最新作品。 [12]提出了基于链的固定优先级调度来改善链的端到端延迟。然而，由于调度模型的差异，这些分析方法都不能直接应用于ROS2。

关于 ROS2 处理链延迟的文献非常有限。据我们所知，[11] 是唯一对 ROS2 调度程序进行建模并提供链响应时间分析的工作。该论文的作者研究了执行程序内的回调调度行为，并使用资源预留来模拟给定执行程序的资源可用性。分析链的端到端延迟时，首先计算由执行器内的回调组成的每个子链的响应时间，然后根据组合性能分析添加跨执行器的子链的响应时间（注册会计师）[18]。他们的方法为分析默认 ROS2 调度程序奠定了基础。然而，如<span style="background:#fff88f">何分配资源并进一步改善关键链的端到端延迟仍然是一个悬而未决的问题</span>

# 三．背景及系统模型
## A.ROS2架构
ROS2 是多层抽象的统一实现，如图 1 所示。应用程序由特定语言的客户端库（例如官方的 C++ 和 Python 以及来自 ROS 社区的许多其他编程语言）支持。 ROS 客户端库 (rcl) 提供 API 以确保用不同语言编写的程序之间的行为一致。 ROS 中间件库 (rmw) 是 rcl 和数据分发服务 (DDS) 之间的通信接口，并且是特定于 DDS 供应商实现的。 DDS是ROS2中新添加的行业标准实时通信系统，用于在节点的发布者和订阅者之间交换消息。

## B. 调度相关的抽象
ROS2 与调度相关的基本抽象包括回调、节点和执行器。
**回调**是ROS2中最小的可调度实体。 ROS2 [11]中有 5 种回调类型：计时器、订阅、服务、客户端和**可等待回调**。计时器回调定期以其自己的速率到达，即**时间触发**的。其他的则由外部事件触发，即事件触发。基本上，发布者和订阅者之间的消息传输可以通过在ROS2中实现回调函数来实现。

**节点**是回调函数的集合，由应用程序程序员组织以实现功能的模块化和逻辑分区。每个节点同时也是执行者的最小分配单元；因此，同一节点内的所有回调都由同一个执行器执行，并且不能将它们分配给两个或多个执行器。一般来说，每个应用程序由多个节点组成，每个节点有多个回调。

**执行器**是运行在CPU核心上的操作系统级可调度实体，即**线程**，并执行分配给它的回调。回调到执行器的分配是通过节点抽象完成的。<span style="background:#40a9ff">一旦节点被分配给执行器，这些节点的所有回调都将由执行器处理，无论回调的来源如何。</span>正如[11]中所报告的，执行器内的回调调度与传统的基于优先级的实时任务调度有很大不同。执行器在回调调度中具有两种独特的行为。首先，**回调的优先级由其类型决定。计时器回调始终具有最高优先级，而其他回调则按照前面介绍的顺序获得次高优先级。所有回调都是非抢占式执行的。** 其次，执行器通过与图1所示的通信中间件层（rmw）交互来更新各自队列中非定时器回调的就绪状态。这种更新发生在所有队列为空（称为轮询点）时，并且这样回调准备状态的延迟更新使得非定时器回调的优先级分配无效[11]，并让链以类似循环的方式运行。

**链**。在 ROS2 与调度相关的抽象之上，应用程序开发人员可以构建链。链是一种语义抽象，由一个或多个节点的**回调之间的消息交换定义**。 ROS2没有定义链上的任何属性，并且执行器在回调调度中没有考虑链的时间和资源需求。然而，由于链的端到端延迟对安全关键实时系统的性能有重大影响，因此本文重点关注链的调度、资源分配和分析。

**超载处理**。 ROS2 具有过载处理机制，以防计时器回调错过一个或多个周期。过载处理机制发生在定时器回调执行开始时（通过运行rcl层中的rcl_timer_call函数）。首先，通过将计时器回调的周期添加到其当前值来更新 next_call_time 变量，以便新值指示触发下一个计时器回调的时间。然后，<span style="background:#40a9ff">如果 next_call_time 晚于当前时间，则重复第一步，使其指向最早的未来时间。因此，由于过载而错过的计时器作业将被自然跳过，并且计时器回调可以在下一个未来周期执行</span>。在发生过载时，时间触发链的端到端延迟的最大延迟最多为计时器回调的一个周期，无论过去跳过了多少个计时器作业。这是因为链实例的释放时间实际上是由执行计时器回调作业并启动该链实例的周期的开始时间决定的。我们将利用此行为来捕获第 4 节引理 4 中先前链实例的最大阻塞延迟。六．请注意，这种机制类似于文献中针对错过截止日期的工作的跳过工作方法 [13,14,17,22]

## C、系统模型
<span style="background:#d3f8b6">本文考虑多核系统，其中所有 CPU 核心都以相同的固定时钟频率运行</span>。下面我们介绍回调、节点和执行器的模型。

1）回调模型：系统有M个实时回调，每个回调要么是定时器回调，由周期性定时器触发，要么是常规回调，由另一个回调的事件触发（链中先前回调的完成）。每个回调都有一个与其关联的链。回调 τi 的特征如下：
τi := (Ci, Di, Ti, πi)
- Ci：τi 作业的最坏情况执行时间。 
- Di：回调τi 的相对截止时间，等于其关联链的截止时间。 
- Ti：回调τi 的周期，等于其关联链的周期(Di ≤ Ti)。 
- πi：回调 τi 在其执行器中的<span style="background:#d3f8b6">优先级</span>

2）节点模型：我们用N表示一组节点，如下：
N =: {n1, ..., nj, ..., nN }
每个节点 nj 的利用率由下式给出：
![image.png](https://raw.githubusercontent.com/wsm6636/pic/main/202405211124359.png)
值得注意的是，<span style="background:#d3f8b6">节点没有优先级，因为它们不是可调度的实体。</span>它们仅对回调到执行器的分配施加限制，例如同一节点中的回调不能单独分配给两个或多个执行器。

3）执行器模型：我们表示一组执行器，如下所示：
E =：{e1，...，ej，...，eE}
第 j 个执行器的优先级用 πej 表示，E 按优先级降序排列，即 πej > πej+1 。从实时角度来看，操作系统对执行器的调度对回调的计时行为有很大影响。<span style="background:#d3f8b6">在这项工作中，我们将每个执行器分配给一个CPU核，并使用SCHED_FIFO来调度每个核的执行器</span>，SCHED_FIFO是Linux中的固定优先级抢占式实时调度策略，优先级范围为1到99。因此，最大具有唯一优先级 E 的执行器数量限制为 99。

4）链模型：每条链由一个或多个回调组成。链 Γc 表示如下：
τc := [τs, τm1, τm2, ..., τe]
- τs：开始回调链Γc。 
- τm*：链Гc 的中间回调。 
- τe：链Тc 的结束回调。
链 Гc 的优先级用 πГc 表示，上标 c 是链 Гc 的标识符。该模型在之前的工作中已被广泛用于分析具有任务之间相互依赖关系的链的端到端延迟。遵循[11]中使用的时间触发的ROS2链模型，假设<span style="background:#d3f8b6">链的启动回调是计时器回调，其他回调是常规回调</span>。<span style="background:#d3f8b6">在事件触发链的情况下，如[11]中所讨论的，可以将链的第一个常规回调（由外部事件触发）建模为具有事件到达周期的计时器回调。</span>请注意，传统任务模型中的周期性实时任务可以表示为我们模型中的单个计时器回调链。
我们使用 CГc 来表示链 Гc 的总 WCET（最坏情况执行时间）：
![image.png](https://raw.githubusercontent.com/wsm6636/pic/main/202405211551496.png)
链优先级的影响。我们假设<span style="background:#d3f8b6">链的优先级 πιc 是由系统设计者根据其在系统中的关键性或重要性给出的。我们称之为语义优先级，因为它不是原始 ROS2 框架的一部分</span>，但应该管理回调和执行器的优先级分配，以满足应用程序级别的需求。

# 四．挑战
在本节中，我们根据我们在使用嵌入式平台的实验中观察到的调度行为，详细阐述了当前 ROS2 框架的挑战。实验是使用在 NVIDIA Xavier NX 上运行的 ROS2“Eloquent Elusor”版本进行的。如表 I 所示，使用由 10 个回调组成的两条安全关键链。我们假设链 1 比链 2 更关键，即 π 1 > π 2 。 τ1 和 τ4 是定时器回调，周期为 1 秒，其他回调均为常规回调。假设<span style="background:#d3f8b6">单处理器系统</span>，执行以下两种情况：（1）所有回调都在单个执行器中，（2）每个链的回调被分配给单独的执行器，即每个链一个执行器。
现在，我们讨论从我们的实验中观察到的以下两个主要挑战。

**挑战 1. 执行者内部基于公平的调度**。第 2 节中讨论的执行器的独特调度行为。 III-B 是它总是首先调度计时器回调，并使其他常规回调的优先级分配无效。此外，由于 ROS2 调度程序不按链区分回调，因此所有回调的调度都没有考虑链级时序要求的概念。图 2a 显示了当两个链一起运行时单个执行器内回调的调度时间线。正如我们所观察到的，随着时间的推移，ROS2 为两条链提供了公平的进度，这种基于公平的调度可能会危及安全关键链的及时性，导致极高的延迟，如表 II 所示。

**挑战2. 执行者的优先级分配**。默认情况下，执行器由 Linux 内核的完全公平调度程序 (CFS) [30] 进行调度。在这个调度程序下，很难对正在运行关键链回调的执行器进行优先级排序。幸运的是，系统开发人员可以手动为执行器分配操作系统级别的优先级，尽管 ROS2 没有提供官方接口来配置它。然而，对于 ROS2 执行器的优先级分配，并没有通用的指导方针。最直观的方法是将最高优先级分配给运行最关键链的执行器，就像我们在图 2b 中所做的那样。这里，包含链 1 的所有回调的执行器的实时优先级为 99（采用 SCHED_FIFO 策略），而链 2 的另一个执行器的实时优先级为 98。但是，此方法并不能解决链 2 的高延迟问题，如图所示在表II中，这是由于链2本身的实例之间的自干扰而发生的。

<span style="background:#fff88f">请注意，如果来自具有不同关键性的链的回调混合在单个节点中，则执行器的优先级分配将变得更具挑战性，因为此类回调无法单独分配给不同的执行器。</span>
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405212235231.png)

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405212253953.png)
> 应该达到图四的效果
# V. 优先级驱动的链感知调度
本节介绍我们的 ROS2 优先级驱动链感知调度框架，称为 PiCAS。为了改善链的端到端延迟，可以重新设计当前的 ROS2 调度架构，考虑以下因素：<span style="background:#fff88f">（1）高优先级链应该比低优先级链更早执行（图 2a），并且（ 2）对于每个链，如果它们被调度在同一个CPU上，则该链的先前实例应该在新释放的实例开始执行之前完成其执行（图2b）。</span>后者是为了减少同一链的实例之间的自干扰，从而防止不必要的延迟增加。基于上述考虑，我们在以下引理中陈述了调度程序所需的属性。

<font color="#ff0000">**引理 1**. 对于回调在同一 CPU 上的链 Γc := [τ1, ...τi, ..., τj, ..., τN ]，保证先前的链实例在新的链实例之前完成其执行。如果满足以下条件，实例将开始执行：(1) τj 的回调优先级高于 τi (j > i)，并且 (2) τj 运行在与 τi 的执行器优先级相同或更高的执行器上。</font>
>我悟了，说的是整个链的下一个实例
>所以第一条链上的回调的优先级要比下一条链上的回调优先级高
>优先级是错开的

证明：可以用反证法来证明。假设一个新的链实例在其先前实例完成之前开始执行，即 τ1 在同一 CPU 上的 τj (1 < j ≤ N ) 完成之前执行。这种行为发生在以下情况下：(1) 当它们位于同一执行器上时，τ1 比 τj 具有更高的优先级，(2) τ1 的优先级比 τj 低，但被分配给比 τj 优先级更高的执行器，并且 ( 3) τ1 比 τj 具有更高的优先级，并且属于比 τj 更高优先级的执行器。这些至少与其中一个条件相矛盾。至此，证明完成。

请注意，<span style="background:#fff88f">如果给定链 Γc 的回调分布在多个 CPU 核心上，则该链的新实例可能有机会早于其先前实例的完成而启动。</span>然而，引理 1 仍然适用于分配给一个 CPU 核心的 Γc 的连续子集。引理的条件确保相应的实例子集按照其到达顺序执行，因此， Γc 的任何实例都不会受到其未来实例的干扰。

基于引理 1，本节的其余部分首先概述我们的调度策略，考虑两个方面：在执行器内运行的链（第 V-A 节）和跨执行器（第 V-B 节）运行。然后提出了所提出的回调优先级分配（第 V-C 节）和链感知节点分配（第 V-D 节）算法，这些算法具体化了这些策略。

![image.png](https://raw.githubusercontent.com/wsm6636/pic/main/202405211651272.png)

## A. 在执行器中运行的链的策略 
我们首先描述在执行器中运行的链的策略。这些策略会影响执行器中此类链的回调的调度方式，它们源自我们对图 3 中所示的链和回调的分类，每个策略映射到其中一个类别。值得注意的是，回调调度与节点配置（由程序代码给出）和节点到执行器分配（由我们在第 V-D 节中的算法确定）正交。这是因为，一旦将节点的回调分配给执行器，每个执行器都会处理分配的回调，而不管其原始节点如何。

**策略一、单链定期回调**。如果执行器只有来自单链的常规回调 Γc =: [τ1, ..., τi, ..., τj, ..., τN ]，则这些<span style="background:#d3f8b6">回调的优先级应按照其优先级的相反顺序分配链中的序列</span>，即 τj (j > i) 获得比 τi 更高的优先级，以满足引理 1 的第一个条件。

**策略二。来自单个链的计时器和常规回调**。如果执行器同时包含单链 Гc 的计时器和常规回调，则<span style="background:#d3f8b6">应为常规回调赋予比计时器回调更高的优先级</span>，以满足引理 1 的第一个条件（因为计时器放置在链中所有其他常规回调之前） 。定期回调的安排应遵循策略一。

**策略三。来自多个链的定期回调**。考虑两条链 Гc 和 Гc′ ，其中 πГc < πГc′ （即 Гc′ 比 Гc 具有更高的语义优先级）。如果执行器包含来自 Гc 和 Гc' 的常规回调，<span style="background:#d3f8b6">则 Гc' 的所有回调应被分配比 Гc 更高的优先级</span>。另外，每个链的回调优先级分配应分别遵循策略一。

**策略四。来自多个链的计时器和定期回调**。如果一个执行器同时包含来自多个链的定时器和常规回调（例如， Гc 和 Гc′，其中 πЧc < πГc′ ），则来自较高语义优先级链（Гc′ ）的定时器回调应具有比来自更高语义优先级链的定时器回调更高的优先级。较低语义优先级链（Гc）。由于计时器回调是每个链实例的起点，因此这种优先级可确保更关键的链实例先于不太关键的链实例。然后，每个链应该单独遵循策略 II 以符合引理 1。

# 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

## B. 跨执行者链运行的策略
接下来我们讨论跨多个执行器运行的链的调度策略。由于每个执行器都分配给一个 CPU 核心并由操作系统的抢占式固定优先级调度程序进行调度，因此我们需要考虑在每个可能分配有多个执行器的 CPU 上进行链式调度。以下两种策略将作为我们在第 2 节中的分配算法的基础。 V-D。请注意，此处假设执行者遵循第 V-A 节中给出的策略 I 至 IV。

**策略五：一个CPU上的单链**。假设 CPU 仅具有来自单链 Γc 的回调。在这种情况下，包含 Гc 的较低索引回调 τi 的执行器应具有与同一 CPU 上执行 Гc 的较高索引回调 τj (j > i) 的其他执行器相同或更低的优先级。这是为了满足引理1的第二个条件。

**策略六。一个 CPU 上有多个链**。假设一个 CPU 具有来自多个链的回调（例如，同一 CPU 上的 Гc 和 Гc′ ，其中 πГc < πГc′ ）。在这种情况下，包含 Гc' 回调的执行器应该至少具有与包含 Гc 回调的执行器相同或更高的优先级，以尊重链的语义优先级。

## C. 回调的优先级分配
为了实现上述调度策略，我们首先在本节中提出回调优先级分配算法。我们的算法允许每个执行器内的回调来实现策略 I 到 IV，并在 Alg1 中给出。 

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405212239130.png)
所提出的算法采用分层方法为回调分配优先级，首先考虑其源链的语义优先级，然后考虑每个链内的相对优先级顺序。在算法1 所示，链按其语义优先级的升序排序（第 1 行），外循环从最低语义优先级链开始迭代（第 3 行）。根据我们在第二节中的链模型。 III-C，每条链的回调已经从开始（低指数）回调到结束（高指数）回调排列。因此，内部循环为每个链 Гc（第 4 行到第 7 行）的索引较低的回调分配较低的优先级，即计时器回调在链中获得最低优先级，而结束回调获得最高优先级。

## D. 链感知节点分配方案
本小节介绍我们的 ROS2 链感知节点分配方案。所提出的方案将给定节点分配给执行器，然后将这些执行器映射到可用的 CPU 核心，同时遵循前面提到的调度策略。该方案还尝试通过尽可能将与一条链关联的所有节点分配给同一 CPU 核心来最大程度地减少链之间的干扰。<span style="background:#d3f8b6">分配方案是离线完成的，不会引入运行时开销</span>。值得注意的是，<span style="background:#d3f8b6">节点不能通过资源分配算法任意分割，因为节点是由程序员组成的</span>，用于ROS2.1中功能的模块化和逻辑分区。此外，<span style="background:#d3f8b6">节点之间的数据依赖关系不受节点分配的影响</span>，因为通信节点之间的交互是通过消息显式完成的，并且无论它们使用哪个执行器都不会改变。

图5说明了所提出的节点分配方案的流程图。该方案将要使用的最大执行器数量 (M)、可用 CPU 核心数量 (P) 和要分配的节点集 (N ) 作为输入。它首先按照每个节点包含的最高优先级回调的降序对 N 中的节点进行排序。这意味着与较高语义优先级链关联的节点首先由该方案分配。让我们用 Γc 来表示尚未分配的最高语义优先级链（因此其关联节点在 N 中）。该方案通过每次从 N 中获取节点来选择节点的子集 N，直到获取与 Γc 关联的所有节点或 N 的利用率超过 1。然后该方案检查是否存在空执行器 ee 并继续前进到实际分配阶段由三部分组成。 A 部分将 N 分配给 ee，并将 ee 分配给可行的 CPU 核心。 B部分是ee不存在的情况；它找到一个对 N 可行的非空执行器 em。C 部分处理前两部分未分配给执行器的所有剩余节点。下面给出了每个部分的详细信息。

**A 部分**。当执行者 ee 为空时，该部分开始。它将N分配给ee，并找到所有可行的CPU核心Pk，其利用率包括ee在内不超过1，即Uee + UPk ≤ 1。如果没有找到这样的CPU核心，则该方案删除包含最低的节点n。从N优先回调，将n发送回N（以便可以重新考虑），并再次为N寻找可行的CPU，直到N中只剩下一个节点。如果N只有一个节点并且没有找到可行的CPU，则发送否则，在找到的所有可行CPU中，N被分配给利用率最低且满足策略V和VI的CPU。如果没有一个满足这些策略，则 N 将被处理 C 部分。请注意，在 SCHED_FIFO 策略下，每个执行器都有一个唯一的操作系统级实时优先级，范围为 1 到 99，我们首先使用优先级最高的空执行器。 

**B部分**。在这部分中，N被分配给已经分配给CPU核Pk的非空执行器em，即ee ∈ Pk。与A部分类似，该方案找到所有可行的非空执行器em，其中UN + UPk ≤ 1。如果不存在可行的执行器，则该方案从N中提取节点n并迭代搜索可用的执行器，直到N中只剩下一个节点。如果N只有一个节点并且找不到任何可行的执行器，则该节点将由C部分处理。N被分配给利用率最低且满足策略I至VI的执行器。当没有执行器满足策略时，N将由C部分处理。

**C部分**。处理A和B部分无法分配给执行器或CPU的N。N无法分配的原因有两个。首先，找到了可行的CPU核心Pk，但策略V和VI不满足。在这种情况下，该方案将 Pk 上的所有执行器合并为一个执行器，从而轻松满足这两个策略。其次，所有CPU核心的利用率都高于1。由于ROS2可以根据第2节中描述的机制处理过载情况。 III-B，我们确实将N分配给利用率最低的CPU核心。我们将在第 7 节中评估 PiCAS 和默认 ROS2 调度程序在过载情况下的调度性能。
## E. 优先级驱动的链感知调度示例
回想一下表 I 中的链集，它会在 ROS2 的默认调度下导致较高的端到端延迟，如第 III 节中所述。现在，我们在提议的 PiCAS 框架下重新运行链集。如图 4 所示，我们的调度程序首先执行较高语义优先级链的回调。此外，根据引理1，在单处理器环境中，每个链的先前链实例在开始执行其新链实例之前完成执行。表III描述了以下两种情况的端到端延迟：(1)所有回调都在单个执行器中，(2)每个链的回调被分配给单独的执行器。对于这两种情况，我们观察到 PiCAS 显着改善了两条链的延迟。






***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考
