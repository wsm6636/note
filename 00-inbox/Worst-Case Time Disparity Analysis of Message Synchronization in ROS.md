---
created: 2024-03-27T18:55
updated: 2024-05-22T09:28
tags:
  - 笔记
  - 笔记/文献笔记
  - 待归档
status:
  - done
---
# Worst-Case Time Disparity Analysis of Message Synchronization in ROS
 



**TitleTranslation:**  ROS中消息同步最坏情况时间差异分析
**Journal or Conference:**   2022 IEEE Real-Time Systems Symposium (RTSS)  
**Authors:**  RuoxiangLi, NanGuan, XuJiang, ZhishanGuo, ZhengDong, MingsongLv
**Pub.date:**  2022-12
**DOI:**  10.1109/RTSS55097.2022.00014
**tags:** 
**zoterolink:**  [zotero](zotero://select/library/items/3U3LGGY9)

# 摘要

多传感器数据融合对于自主系统中支持准确感知和智能决策至关重要。为了进行有意义的数据融合，来自不同传感器的输入数据必须在彼此接近的时间点进行采样，否则结果无法准确反映物理环境的状态。 ROS（机器人操作系统）是一种流行的自主系统软件框架，它提供消息同步机制来解决上述问题，通过缓冲携带来自不同传感器的数据的消息并对具有相似时间戳的消息进行分组。虽然消息同步广泛应用于基于ROS开发的应用中，但对其实际行为和性能知之甚少，因此很难保证数据融合的质量。在本文中，我们对 ROS 中的消息同步策略进行建模，并正式分析其最坏情况的时间差异（分组到同一输出集中的消息的时间戳之间的最大差异）。我们进行实验来评估所提出的时间差异上限相对于实际执行中最大观察到的时间差异的精度，并将其与 Apollo Cyber​​ RT（另一种流行的自动驾驶系统软件框架）中的同步策略进行比较。实验结果表明，我们的分析具有良好的精度，并且 ROS 在观察到的最坏情况时间差异和理论界限方面均优于 Apollo Cyber​​ RT。

# 1 引言
现代自主系统，例如自动驾驶汽车、机器人和无人机，严重依赖多传感器数据融合来准确感知周围的物理环境并做出智能决策[1]，[2]。通常，融合算法是在同时采样来自不同传感器的输入数据的假设下开发的。然而，由于固有的硬件特性（例如，不同的传感器可能具有不同的采样频率，并且不同传感器之间存在时钟漂移）和软件引起的延迟（例如，由于数据的预处理和传输），这种假设在现实中很少成立。传感器数据）。在本文中，我们使用时间差异（将在第二节中正式定义）来描述来自不同传感器源的输入数据的时间不一致。如果时间差异太大，融合结果的用处就会大大降低，甚至完全没有意义。例如，在自动驾驶汽车中，对外部环境的感知通常依赖于多个传感器独立测量值的融合。如果两个传感器（例如相机和激光雷达）的测量发生在两个截然不同的时间点，那么它们的信息融合将无助于重建周围环境的准确视图[3]。

ROS（机器人操作系统）[4]是一种用于开发机器人系统的流行软件框架。 ROS 已被数十万开发人员用来为大量不同类型的机器人和其他自主系统提供支持。 ROS 提供了消息同步器 [5] 来减少融合算法数据输入的时间差异。如图1所示，消息同步器从多个通道接收输入消息。每条消息都携带来自某个传感器的数据，并具有指示数据采样时间的时间戳。消息同步器从每个输入通道中选择一条消息形成输出消息集，并将其发送到后续的数据融合组件。消息同步器广泛应用于基于 ROS 的应用程序中。例如，<span style="background:#40a9ff">基于ROS的自动驾驶系统开源软件框架Autoware[6]、[7]，使用消息同步器来同步相机数据和3D LiDAR数据，然后将它们发送到数据融合节点。</span>然而，尽管 ROS 被广泛使用，但它很少提供有关其消息同步器实际工作原理的公开信息，特别是用于选择输入消息以形成输出消息集的确切策略是什么。因此，大多数开发者不得不将其作为黑盒使用，依靠测试来检验其输出的时间差是否能够满足融合算法的要求。

在本文中，我们对<span style="background:#ff4d4f"> ROS 消息同步器进行建模</span>，并正式导出其输出消息集的最坏情况时间差异的严格上限。与测试仅涵盖所有可能的系统行为的有限部分，因此通常无法捕获最坏情况的时间差异不同，我们的形式分析为运行时任何情况下输出消息集的最大时间差异提供了绝对保证时间。因此，只要导出的界限落在融合算法的可容忍范围内，就可以确保融合算法在运行时始终提供预期的质量。这种保证对于任务关键型和安全关键型系统的设计尤其重要，在这些系统中（偶尔）低质量的输出可能会导致严重后果。

<span style="background:#ff4d4f">我们的形式分析对于不太关键的系统也很有用，并且可以容忍融合算法偶尔的低质量输出（因此可以容忍偶尔违反预期的时间差异范围）。</span>这是因为我们的分析结果为有效指导系统设计提供了有用的信息。在测试中，当观察到的时间差异太大时，没有关于如何修改系统设计的指导信息。通常的做法是逐步调整系统参数并重做测试，迭代直至观察到的时间差异令人满意。相比之下，本文推导的最坏情况时间差异界限与传感器数据流的定时参数具有封闭形式的关系，通过它我们可以快速找到这些参数的适当范围以满足要求。这比基于测试的方法要有效得多。

我们通过实验来评估本文开发的时间差异上限与 ROS 中各种参数设置下实际执行中最大观察到的时间差异的精度。实验结果表明我们的分析具有良好的精度。我们还将 ROS 中的同步策略与 Apollo Cyber​​ RT [8]（另一种流行的自动驾驶系统开源软件框架）中使用的（简单）策略进行了比较。实验结果表明，ROS 中的同步策略在观察到的最坏情况时间差异和理论界限方面均优于 Apollo Cyber​​ RT。

# 二.问题模型
在本节中，我们介绍系统模型和本文要解决的问题。该系统接收来自多个传感器的输入，每个传感器重复生成携带传感器数据的消息。每条消息都与一个时间戳相关联，该时间戳表示对其携带的传感器数据进行采样的时间。每条消息在到达消息同步器之前可能会经历一些延迟（例如由于预处理或数据传输）。消息同步器根据某种同步策略，决定如何选择来自不同传感器的到达消息，形成输出消息集并发布。我们将在第三节介绍ROS消息同步器中使用的同步策略。我们的目标是分析最坏情况的时间差异，即消息同步器发布的输出消息集中所有消息的时间戳之间的最大差异。接下来，我们将引入符号来描述系统的相关方面，然后正式定义最坏情况的时间差异度量。

<span style="background:#d3f8b6">消息同步器有N个输入通道。每个通道都有一个缓冲队列Q i 来临时存储到达该通道的消息。此时，我们假设每个队列 Q i 足够长，因此不会发生溢出。稍后在第五节中，我们将通过提供所需队列大小的上限来摆脱这个假设。</span>为了简单起见，当上下文明确时，我们还使用 Q i 来指代消息同步器的第 i 个输入通道。

我们使用 m k i 来表示队列 Q i 中当前的第 k 条消息。为了简单起见，<span style="background:#d3f8b6">有时当不需要指定具体是哪条消息时，我们也使用 m i 来表示队列 Q i 中的消息。</span>每个消息m k i 都有一个时间戳，记为t(m k i )，<span style="background:#d3f8b6">表示m k i 携带的传感器数据被采样的时间。</span> Q i 中两个连续消息的时间戳之差至少为 T B i 且最多为 T W i （T B i 和 T W i 均严格大于 0）。对于传感器周期性生成消息的特殊情况，T B i =T W i 。我们假设同一队列 Q i 中的消息按照与其时间戳相同的顺序到达，即 ∀k : t(m k i ) < t(m k+1 i )。

消息在到达消息同步器之前可能会经历一些延迟。因此，消息的时间戳通常与消息到达消息同步器的时间不同。我们用 D B i 和 D W i 分别表示 Q i 中的消息所经历的最好情况和最坏情况延迟，并用 a(m k i ) 表示消息 m k i 到达消息同步器的时间，因此我们有
![image.png|500](https://raw.githubusercontent.com/wsm6636/pic/main/202405201118376.png)
消息同步器从每个队列Q i 中选择一条消息形成输出消息集并发布。如果消息集 S 有 N 个元素并且 S 中的每个元素来自不同的队列，则我们称消息集 S 是常规消息集。消息同步器发布的输出消息集必须是常规消息集。一组消息的时间差定义为：
**定义 1（时间差异）**。令 S = {m 1 , ..., m N } 为一组消息。 S 的时间差异用 Δ(S) 表示，是 S 中消息最早和最晚时间戳之间的最大差异：
![image.png|500](https://raw.githubusercontent.com/wsm6636/pic/main/202405201120168.png)
例如，在图2中，常规消息集合{m 3 1 ,m 3 2 ,m 1 3 }的时间差为24 − 22 = 2，常规消息集合{m 2 1 ,m 2 的时间差2 ,m 1 3 } 为 22 − 16 = 6。
本文要解决的问题是分析最坏情况的时间差异，即消息同步器产生的输出消息集的最大时间差异。

# 三． ROS消息同步策略
ROS消息同步器有两种同步策略：ExactTime策略[9]和ApproximateTime策略[10]。 ExactTime策略很简单：它只选择来自不同输入通道的具有完全相同时间戳的消息来形成输出集，并丢弃无法找到精确匹配的消息。在 ExactTime 策略下发布的任何输出消息集的时间差几乎都是 0。然而，实际上要求来自不同传感器的数据具有完全相同的时间戳的限制太大，因此 ExactTime 策略在实践中很少使用。因此，我们将把注意力限制在广泛使用的 ApproximateTime 策略上，该策略要复杂得多且难以分析。尽管 ROS 多年来一直在积极发展，但其消息同步器组件很稳定。我们检查了直到最新的 Humble [11] 为止的所有 ROS 2 C++ 版本，以及自 Diamondback [12] 以来的 ROS 1 C++ 版本，其中消息同步策略是相同的，因此本文的模型和结果适用于所有这些版本。

ApproximateTime 策略旨在查找并发布时间差异尽可能小的常规消息集。 ApproximateTime 策略相当复杂，有很多优化和实现细节。构建与其源代码等效的完整模型既不可行，也没有必要。相反，我们将开发一个高级抽象模型，捕获与本文研究的分析问题相关的基本方面，并排除那些不相关的低级细节。<span style="background:#d3f8b6">特别是，我们只会对其输出进行建模，而不是在其实际实现中如何获得输出。</span>

我们的抽象模型是否能够正确表示 ApproximateTime 策略本身是一个自然的问题。为了解决这个问题，我们进行了深入的实验，通过比较 ROS 中原始实现的实际输出和根据我们的抽象模型的预期输出，从经验上验证我们的模型。如第 VI-A 节所示，在所有实验中，根据我们的模型，实际输出与预期输出相匹配。尽管这仍然不能给出任何绝对的保证，但可以公平地以高度可信的方式声称我们的抽象模型的正确性。下面，我们介绍我们的抽象模型，首先介绍 ApproximateTime 策略中使用的一些重要概念。

## A. 预测消息
每个队列 Q i 不仅存储已经到达的消息（称为到达消息），还存储 Q i 末尾的人工预测消息。<span style="background:#d3f8b6">预测消息永远不会包含在输出消息集中。相反，它仅用于在选择过程中提供辅助信息。 </span>m k i 表示Q i 中第k个位置存储的消息，无论是到达消息还是预测消息。如果Q i 当前存储消息{m 1 i , ..., m k i }，则m k i 一定是预测消息，并且m 1 i , ..., m k−1 i 都是到达消息。预测消息 m k i 的时间戳设置为
![image.png|325](https://raw.githubusercontent.com/wsm6636/pic/main/202405201151501.png)
其中 m k−1 i 是 Q i 中最后到达的消息，T B i 是该通道中两个连续消息的时间戳之间的最小差异。<span style="background:#d3f8b6">当系统在时间 0 启动时，时间戳为 0 的预测消息最初被放入每个队列中。请注意，有时队列可能只有预测的消息，但没有到达的消息。</span>

通过考虑预测的消息，ApproximateTime 策略可以利用这样的可能性：已到达的消息可能与将来到达的一些消息组合在一起，形成时间差异更小的输出消息集。例如，假设有两个输入通道 Q 1 和 Q 2 ，其中 T B 1 =T W 1 =T B 2 =T W 2 = 10。假设当前 Q 1 中只有一条到达消息 m 1 1 ，其中 t(m 1 1 ) = 2，且 Q 2 中只有一条到达消息 m 1 2 ，且 t(m 1 2 ) = 10。如果我们使用 m 1 1 和 m 1 2 构成输出消息集，则其时间差为 t(m 1 2 )−t(m 1 1 ) = 10−2 = 8。但是，由于 Q 1 中的消息定期到达，因此到达 Q 1 的下一条消息的时间戳将为 t(m 1 1 )+T W 1 = 2 + 10 = 12，所以实际上最好等待 Q 1 中的下一条消息到达并让它与 m 1 2 配合，这会导致更小的时间差异 12 − 10 = 2。

一般来说，T W i 大于T B i ，因此到达Q 1 的下一条消息的实际时间戳可能晚于预测消息的时间戳。例如，我们将上例中的 T W 1 改为 20，并假设 Q i 的下一条消息的实际时间戳为 22。这种情况下，当 m 2 1 到达后（且其实际时间戳已知），ApproximateTime 策略将选择 m 1 1 和 m 1 2 来形成输出消息集，因为 m 2 1 和 m 1 2 组合在一起会导致更大的时间差异，本节稍后将介绍。

# B、pivot
**定义 2（pivot）**。设S 1 = {m 1 1 , ..., m 1 N }，其中每个m 1 i 是Q i 中第一个到达的消息。pivot m P 是 S 1 中所有元素中时间戳最大的一个。
直观上，<span style="background:#d3f8b6">枢轴是必须包含在下一个发布的输出消息集中的消息，其他消息将根据它们与枢轴的接近程度（以时间戳计）来选择。</span>随着队列状态的变化，枢轴也会随着时间的推移而变化。

> 最大时间消息

<span style="background:#d3f8b6">包含枢轴的队列是枢轴队列，其他队列是非枢轴队列。</span>例如，假设当前队列状态如图3所示，则m 1 4 是主元，因为它具有所有队列中的所有第一消息中最新的时间戳。 Q4 是枢轴队列，Q1、Q2、Q3 是非枢轴队列。
![image.png|600](https://raw.githubusercontent.com/wsm6636/pic/main/202405201210011.png)

>  例子
> 选择所有队列中第一个到达的组成S1
> S1里时间戳最大的为pivot
> 输出set为每个队列中和pivot时间差最小的
> 输出必须包括pivot

## C选定集
所选集合是包括主元在内的所有常规消息集合中时间差异最小的集合。
**定义 3（选定集）**。令 Λ 为所有常规消息集的集合，其中包含当前在队列中的消息（到达的或预测的）并包括枢轴。所选集合在Λ中的所有元素中具有最小的时间差异。

如果 Λ 中的多个元素都具有最小时间差，则所选集合 S = {m1, ..., mN } 必须满足以下条件：不存在另一个元素 S′ = {m′1, .. ., m′N } in Λ s.t. (i) Δ(S′) = Δ(S) 且 (ii) ∃mi ∈ S : t(m′i) < t(mi)。

如果Λ中只有一个正则消息集合具有最小的时间差异，则它显然是被选择的集合。如果Λ中的多个正则消息集都具有最小的时间差异，根据定义3的后半部分，具有尽可能早消息的消息集就是被选择的集。例如，在图3中，在包括主元m14在内的所有常规消息集合中，两个集合S = {m21, m22, m33, m14}和S′ = {m21, m22, m43, m14}都具有最小的时间视差6。根据定义3的后半部分，S'不是选择集，因为存在包含m33的S，其早于S'中的对应关系m43。 S 是选定的集合，因为没有其他包含主元的常规消息集具有与 S 相同的时间差异，并且满足 ∃mi ∈ S : t(m′i) < t(mi)。


> 即使有其他集合满足时间差，但是有时间戳更早的选更早的
> 时间差，这组消息集合里面，最大和最小的差
> 例子里最大最小一样，所以时间差一样
> 但是除此之外的消息，也要满足是它所属队列中，时间戳最小，且在时间差内


> [!NOTE] Title
> 为什么选最早的时间戳，所以孙景浩他们才改进成选时间戳更接近的？

尽管所选集被定义为在包括枢轴在内的所有常规消息集中进行选择，其数量可能呈指数级增长，但它是通过 ROS 消息同步器中的实现中的多项式时间过程找到的。由于我们的目标是提供一个高级模型，<span style="background:#d3f8b6">重点关注策略生成的结果是什么，而不是如何获得结果</span>，因此我们不会进一步讨论其在 RO​​S 中多项式时间实现的细节。

## D. 近似时间策略
![image.png|700](https://raw.githubusercontent.com/wsm6636/pic/main/202405201236635.png)

算法 1 显示了 ApproximateTime 策略的伪代码，用于在新消息到达时选择并发布输出消息集。假设当前时刻 Qi 最初有 k 条消息 {mi1, ..., mik}，其中 mik 是预测消息（回想一下，队列中的最后一条消息必须是预测消息）。该算法首先用新到达的消息mi更新Qi（第1行到第3行），<span style="background:#d2cbff">丢弃原来的预测消息mik，将新到达的消息作为mik放在Qi的末尾，</span>最后生成新的预测消息mk+1 i其中 t(mk+1 i ) = t(mik) + TiB 并将其放在 Qi 的末尾。

接下来，该算法重复检查每个队列当前是否包含至少一个到达的消息。如果不是，即某个队列只有预测消息，则无论如何都不可能发布输出消息集，因此算法只是停止而不进行任何进一步检查。如果是，它首先根据定义 2（第 5 行）设置当前枢轴。然后它检查所有预测消息的时间戳是否不早于 t(mP)（第 6 行）。如果不是，算法返回而不发布任何输出消息集（第 15 行），其背后的直觉解释如下。<span style="background:#d2cbff">如果某个队列 Qk 中的预测消息 mk 具有 t(mk) 小于 t(mP)，则该队列中到达的消息（如果有）的时间戳甚至更小，因此该预测消息具有与枢轴 mP 最接近的时间戳。因此，到达该队列的下一条消息有机会比 Qk 中现有到达的消息产生更好的输出消息集，因此等待 Qk 的下一条消息到达（并且显示其实际时间戳）是有意义的做出决定 1.</span>

如果所有预测消息的时间戳都不早于 t(mP)，算法将根据定义 3（第 7 行）找到所选集合 S，并检查 S 中的所有消息是否都是到达消息（第 8 行）。如果不是，即 S 包含至少一条预测消息，则 S 无法发布并且算法停止（第 13 行）。如果是，则将 S 作为输出消息集发布（第 9 行）。之后，对于每个队列Qj，S中对应的消息mj以及mj之前Qj中的所有消息都被丢弃。

从算法1中我们可以看到，<span style="background:#fff88f">在ApproximateTime策略下，输出消息集是根据消息的时间戳决定的，而不是根据消息的到达时间决定的。到达时间影响算法 1 的执行时间以及输出消息集的发布时间</span>。

![image.png](https://raw.githubusercontent.com/wsm6636/pic/main/202405201425135.png)

## E. 一个说明性的例子
 我们用图4来说明算法1。x轴代表时间戳，图中没有明确描述消息的到达时间。 T B 1 = 30，T B 2 = T B 3 = 40，T W 1 = T W 2 = T W 3 = + ∞。原始队列状态如图4-(a)所示，在稍后的某个时间点，时间戳为60的消息到达Q 3 。请注意，T B 3 是 Q 3 中两个连续消息的时间戳之间的最小间隔，并且该新到达的消息的时间戳大于相应的预测消息（图 4-(a) 中的 m 1 3 ）。

这个新到达的消息触发算法 1 的执行。首先，更新 Q 3 ，丢弃原来的预测消息，将新到达的消息作为新的 m 1 3 插入到 Q 3 中，并生成新的预测消息 m 2 3 ，如图4-(b)所示。现在每个队列至少有一条到达消息，因此第 4 行中的 while 条件为 true。 m 1 3 是主元（用 m P 表示），因为它在所有队列的第一条消息中具有最大的时间戳。由于预测消息的时间戳 m 2 2 小于 m P ，因此第 6 行中的 if 条件为假，算法停止。

随后，时间戳为 50 的消息到达 Q 2 ，触发算法 1 的执行。用这条新到达的消息更新 Q 2 后，m 1 3 仍然是枢轴，如图 4-(c ）。现在第 6 行的 if 条件已满足。正则消息集S={m 2 1 ,m 2 2 ,m 1 3 }具有最小的时间差异，因此是选择集。由于这个选定的集合只包含到达的消息（满足第8行的if条件），因此它将被发布，并且S中的消息以及早于S中相应消息的消息将被丢弃，结果如图4-（d）。

算法 1 可能会发布多个输出消息集（即，在 while 循环中迭代多次）。假设当前队列状态如图4-(e)所示。现在选择的集合是{m 2 1 ,m 1 2 ,m 1 3 }，由于m 2 1 是预测消息，因此无法发布该集合。后来，所有队列中的下一个消息都到达了，但是 Q 1 中的消息的时间戳比预测晚得多，如图 4-(f) 所示。现在选择的集合是{m 1 1 ,m 1 2 ,m 1 3 }，它们都是到达的消息，可以发布。之后，算法1进入while循环的第二次迭代。现在，如图4-(g)所示，m 1 1 成为枢轴，选择的集合是{m 1 1 ,m 1 2 ,m 1 3 }，它只包含到达的消息，因此也可以发布，之后队列状态如图4-(h)所示。

# 四．时间差异分析


> [!NOTE] 分析时间

# V. 所需的队列大小限制
到目前为止介绍的模型和分析都是基于所有队列都足够长并且不会发生溢出的假设。在本节中，我们将通过证明我们可以找到定理 1 仍然成立的队列大小的上限来摆脱这个假设。
实际上，ROS 消息同步器可能出于两个原因丢弃消息： 
- 主动丢弃。回想一下，算法 1（第 11 行）会丢弃已发布的消息以及每个队列中早于已发布消息的所有消息。在这种情况下，我们说这些消息被主动丢弃。 
- 被动丢弃。如果新消息到达时队列已满，则该队列中最早的消息将被丢弃。在这种情况下，我们说消息被被动丢弃。

为了确定所需队列大小的上限，我们似乎需要找到永远不会发生被动丢弃的条件。然而，这实际上是不必要的。考虑具有相同系统输入的两个场景：
S1。队列大小不受限制，并且不会发生被动丢弃。 
S2。队列大小有限，一些未在 S1 中发布的消息将被被动丢弃。 

<span style="background:#d3f8b6">S2中的被动丢弃不应该影响枢轴的选择以及相应的已发布输出消息集的选择，并且这两种情况下的输出是相同的。</span>换句话说，我们可以将S1中的每个无限队列视为有两部分：第一部分与场景S2中对应的队列具有相同的大小，第二部分具有无限大小并存储场景S2中被动丢弃的消息。在这种情况下，只有位于队列​​第一部分的消息才能发布，而第二部分中的消息无论如何都会被丢弃。因此，下面我们将<span style="background:#ff4d4f">计算每个队列所需的大小，以便在发布输出消息集时，队列足够大，可以存储包含此发布消息的所有消息，并确保枢轴一旦被选择就保持不变，无论之前的消息是否已被被动丢弃。</span>





***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考
