---
created: 2024-03-27T18:55
updated: 2024-05-09T11:31
tags:
  - 笔记
  - 笔记/文献笔记
  - 待归档
status:
  - ing
---


**TitleTranslation:**  并行路径进展DAG调度
**Journal or Conference:**  IEEE Trans. Comput.  IEEE Transactions on Computers 
**Authors:**  NiklasUeter, MarioGünzel, Georg Von DerBrüggen, Jian-JiaChen
**Pub.date:**  2023-10
**DOI:**  10.1109/TC.2023.3280137
**tags:** 
**zoterolink:**  [zotero](zotero://select/library/items/X4I3VCIH)

# 摘要

现代网络物理系统不断增长的性能需求导致多处理器架构得到越来越多的利用。为了有效地利用硬实时系统中潜在的并行性，需要适当的任务模型和调度算法来提供时序保证。由于基于最坏情况假设的悲观分析，此类调度算法和相应的最坏情况响应时间分析通常会遭受资源过度配置的困扰。因此，需要具有高资源效率的调度算法和分析。一个著名的细粒度并行任务模型是有向无环图 (DAG) 任务模型，它由优先级约束的子作业组成。本文研究零星任意期限DAG任务的分层实时调度问题。我们提出了一种并行路径进展调度属性，该属性仅使用两个不同的子任务优先级来实现，这允许在响应时间分析中量化用户选择的完整路径集合的并行执行。这种新颖的方法显着改进了高度并行 DAG 结构的并行 DAG 任务的最先进的响应时间分析，并且可以证明耗尽大量核心。基于此特性设计了两种分层调度算法，扩展了并行路径进展特性并改进了零星任意期限 DAG 任务集的响应时间分析。


# 一、引言和动机

现代网络物理系统已经从单处理器系统转向多处理器系统，以应对热量和能量限制，以及日益复杂的应用程序和紧迫的期限限制的计算需求。值得注意的是，用于实时领域的多核架构中的可用核心数量已大大增加。具有 256 个内核的 Kalray MPPA 架构就是一个例子，这加剧了对能够利用可用内核潜力的方法的需求。这种架构转变对实时感知并行软件的设计方法、细粒度并行任务模型的规范和实现以及允许正式响应时间分析的适当调度算法的设计提出了多重挑战。

并行计算 OpenMP 和实时扩展 OmpSs [14] 的事实上的标准编程和调度模型正在使用分层调度。也就是说，在较高级别上，工作线程由操作系统调度，而在较低级别上，并行任务的子作业由负责将就绪子作业分派给可用工作线程的相应运行时环境管理。分层调度的具体实现尚未标准化，例如，OpenMP 和 OmpS 的方法不同之处在于，OpenMP 通过主线程实现 fork-join 并行性，主线程在遇到并行区域时创建所谓的并行线程组。相比之下，OmpSs 使用工作线程池在子作业准备好后立即为其提供服务，这类似于列表调度。在这两个框架中，应用程序源代码都是用高级编程语言编写的，该语言使用一组指令进行检测，与库例程和提供的运行时环境一起用于描述和执行并行应用程序。

我们认为，一方面并行应用程序设计和调度的解耦，另一方面实时操作系统调度和服务契约的解耦，由于时间隔离和简单集成，是实现实时并行软件的最有前途的方法使用所使用的实时操作系统的任何常用的调度算法，例如固定优先级的分区或全局调度变体或最早截止时间优先（EDF）调度算法。

<span style="color:black;background:#40a9ff !important;">分层调度方法的响应时间分析被分解为验证每个工作线程是否能够提供实时操作系统必须承诺的定义数量的服务的问题以及随后验证的问题每个 DAG 作业都可以在其期限限制内使用承诺的服务完成其工作负载。</span>

在DAG任务集的实时调度理论中，目标是有效地利用多处理器为具有任务间和任务内并行性的任务集提供的并行性，同时保证每个任务满足其截止日期。并行性可以分为任务间并行性和任务内并行性，任务间并行性是指不同任务的并行执行，每个任务顺序执行；任务内并行性是指单个任务的并行执行。任务内并行性需要具有可以并行调度的子任务级粒度的任务模型，例如Fork-join模型[25]、同步并行任务模型或基于DAG（有向无环图）的任务模型。已经提出了大量的实时调度算法及其响应时间分析，例如，针对广义并行任务模型 [33] 和基于 DAG（有向无环图）的任务模型 [3]、[5]、[13] ]、[16]、[17]、[19]、[28]、[42]。对于基于 DAG 的任务模型，响应时间分析的改进可以分为改善任务间干扰的分析，例如[13]、[16]，或任务内干扰的分析，例如[19]、[ 20]、[26]、[42]。一般来说，任务内干扰分析建立在包络执行过程中的干扰分析（也称为关键路径或关键路径）的基础上。直观上，包络路径是依赖于调度的子作业序列，其特性是所有包络路径子作业的到达和完成时间间隔是DAG作业的到达时间和完成时间间隔的划分。由于这些子作业包含 DAG 作业的执行，因此用于执行信封路径子作业的累积时间量以及信封路径子作业受到干扰的累积时间量限制了响应时间。

与最先进的技术相比，我们分析了沿着包络路径的多个用户选择的路径的同时进行，最多有多个处理器的数量。因此，我们只需考虑不属于任何用户选择的响应时间限制路径的子作业的干扰，从而能够将格雷厄姆的完工时间限制从一条路径推广到多条路径。这种改进是通过任务内优先级排序来实现的，即通过为用户选择的路径的所有子任务分配较低的优先级。由此，包络路径子作业的进展和来自用户选择的路径的子作业的进展可以在分析上彼此相关。据我们所知，这是第一篇提出并行路径进展概念1和相应的响应时间分析以及这些概念对分层调度的扩展的论文。

贡献：我们提供以下贡献：

- 基于第 III-A 节中提出的并行路径进展概念，我们在第 III-B 节中提出了一种<span style="color:black;background:#ff4d4f !important;">抢占式固定优先级调度算法，以及针对最多处理器数量的任意路径集合的可持续响应时间分析</span>。在第四节中，我们提供了<span style="color:black;background:#ff4d4f !important;">一种多项式时间算法，该算法要么找到完全覆盖 DAG 的路径集合（如果存在可用数量的处理器），要么找到具有可证明有界的最坏情况响应时间的近似值。</span>
- 我们将我们的研究结果扩展到第五节中的两种分层调度算法。即<span style="color:black;background:#ff4d4f !important;">第 V-A 节中的偶发任意截止日期团体预订系统和 V-B 节中的偶发任意截止日期普通预订系统</span>，它们利用了并行路径进展概念。分层调度算法可以应用于零星的任意期限 DAG 任务，这些任务可以与不同任务模型描述的任务（例如顺序任务）同时执行。
- 对于这两个预订系统，我们提供响应时间分析和算法来生成“可行”的预订系统，分别如第 V-A 和 V-B 节中所述。
- 在第六节中，我们使用综合生成的 DAG 任务集评估我们的方法，并证明我们的方法在高并行性场景中推进了最先进的技术，并表明我们的方法的性能介于起始-在更连续的场景中进行最先进的联合调度。

# 二.任务模型和问题描述
我们考虑一个集合 T := {τ1, . 。 。 , τn} 是在 M 个同构处理器上调度和执行的零星任意截止时间有向无环图 (DAG) 任务。每个任务 τi := (Gi, Di, Ti) ∈ T 由描述子任务和优先约束、最小到达时间 Ti 和相对截止时间 Di 的 DAG Gi 定义。每个任务都会释放无限序列的任务实例，称为作业。我们用 Ji 表示任务 τi 的第-个作业，用 ai 、 fi 和 di = ai + Di 表示作业 Ji 的到达时间、完成时间和（绝对）截止日期。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405091128296.png)


**DAG**：任务的 DAG Gi 由元组 (Vi, Ei) 定义，其中 Vi 表示子任务的有限集，关系 Ei ⊆ Vi × Vi 表示它们之间的优先级约束，因此不存在循环优先级约束。为了在数学上精确，每个作业 Jil 都与 DAG Gil 的一个实例相关联，该实例具有相应的第l个子作业 vjl，其中 vj 是 Vi 中的子任务。任务τi的第l个作业的子作业，即vjl (vj ∈ Vi)，在(vk, vj) ​​∈ Vi的所有第l个子作业vkl 执行完毕后被释放。为了减少这种表示法，我们在分析一项特定作业时删除任务和作业的索引。也就是说，我们用 G = (V, E) 和 vj ∈ V 来表示特定 DAG 作业的子作业。示例性 DAG 如图 1 所示。

**Volume**： <span style="color:#00b050 !important;">voli : Vi → R≥0 指定每个子任务 vj ∈ Vi 的最坏情况执行时间，</span>这意味着没有子作业（实例）vjl 在执行平台上执行的时间超过 voli(vj) 个时间单位，但是可能会更早完成。此外，子任务 W ⊆ Vi 的任意子集的体积为 vol(W ) := Σ vj∈W   voli(vj)。特别是，任务的总体积 τi 由 Ci := voli(Vi) 给出。



![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405091131463.png)








***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考
