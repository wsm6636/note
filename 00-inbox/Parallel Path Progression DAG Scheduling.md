---
created: 2024-03-27T18:55
updated: 2024-05-10T10:44
tags:
  - 笔记
  - 笔记/文献笔记
  - 待归档
status:
  - ing
---


**TitleTranslation:**  并行路径进展DAG调度
**Journal or Conference:**  IEEE Trans. Comput.  IEEE Transactions on Computers 
**Authors:**  NiklasUeter, MarioGünzel, Georg Von DerBrüggen, Jian-JiaChen
**Pub.date:**  2023-10
**DOI:**  10.1109/TC.2023.3280137
**tags:** 
**zoterolink:**  [zotero](zotero://select/library/items/X4I3VCIH)

# 摘要

现代网络物理系统不断增长的性能需求导致多处理器架构得到越来越多的利用。为了有效地利用硬实时系统中潜在的并行性，需要适当的任务模型和调度算法来提供时序保证。由于基于最坏情况假设的悲观分析，此类调度算法和相应的最坏情况响应时间分析通常会遭受资源过度配置的困扰。因此，需要具有高资源效率的调度算法和分析。一个著名的细粒度并行任务模型是有向无环图 (DAG) 任务模型，它由优先级约束的子作业组成。本文研究零星任意期限DAG任务的分层实时调度问题。我们提出了一种并行路径进展调度属性，该属性仅使用两个不同的子任务优先级来实现，这允许在响应时间分析中量化用户选择的完整路径集合的并行执行。这种新颖的方法显着改进了高度并行 DAG 结构的并行 DAG 任务的最先进的响应时间分析，并且可以证明耗尽大量核心。基于此特性设计了两种分层调度算法，扩展了并行路径进展特性并改进了零星任意期限 DAG 任务集的响应时间分析。


# 一、引言和动机

现代网络物理系统已经从单处理器系统转向多处理器系统，以应对热量和能量限制，以及日益复杂的应用程序和紧迫的期限限制的计算需求。值得注意的是，用于实时领域的多核架构中的可用核心数量已大大增加。具有 256 个内核的 Kalray MPPA 架构就是一个例子，这加剧了对能够利用可用内核潜力的方法的需求。这种架构转变对实时感知并行软件的设计方法、细粒度并行任务模型的规范和实现以及允许正式响应时间分析的适当调度算法的设计提出了多重挑战。

并行计算 OpenMP 和实时扩展 OmpSs [14] 的事实上的标准编程和调度模型正在使用分层调度。也就是说，在较高级别上，工作线程由操作系统调度，而在较低级别上，并行任务的子作业由负责将就绪子作业分派给可用工作线程的相应运行时环境管理。分层调度的具体实现尚未标准化，例如，OpenMP 和 OmpS 的方法不同之处在于，OpenMP 通过主线程实现 fork-join 并行性，主线程在遇到并行区域时创建所谓的并行线程组。相比之下，OmpSs 使用工作线程池在子作业准备好后立即为其提供服务，这类似于列表调度。在这两个框架中，应用程序源代码都是用高级编程语言编写的，该语言使用一组指令进行检测，与库例程和提供的运行时环境一起用于描述和执行并行应用程序。

我们认为，一方面并行应用程序设计和调度的解耦，另一方面实时操作系统调度和服务契约的解耦，由于时间隔离和简单集成，是实现实时并行软件的最有前途的方法使用所使用的实时操作系统的任何常用的调度算法，例如固定优先级的分区或全局调度变体或最早截止时间优先（EDF）调度算法。

<span style="color:black;background:#40a9ff !important;">分层调度方法的响应时间分析被分解为验证每个工作线程是否能够提供实时操作系统必须承诺的定义数量的服务的问题以及随后验证的问题每个 DAG 作业都可以在其期限限制内使用承诺的服务完成其工作负载。</span>

在DAG任务集的实时调度理论中，目标是有效地利用多处理器为具有任务间和任务内并行性的任务集提供的并行性，同时保证每个任务满足其截止日期。并行性可以分为任务间并行性和任务内并行性，任务间并行性是指不同任务的并行执行，每个任务顺序执行；任务内并行性是指单个任务的并行执行。任务内并行性需要具有可以并行调度的子任务级粒度的任务模型，例如Fork-join模型[25]、同步并行任务模型或基于DAG（有向无环图）的任务模型。已经提出了大量的实时调度算法及其响应时间分析，例如，针对广义并行任务模型 [33] 和基于 DAG（有向无环图）的任务模型 [3]、[5]、[13] ]、[16]、[17]、[19]、[28]、[42]。对于基于 DAG 的任务模型，响应时间分析的改进可以分为改善任务间干扰的分析，例如[13]、[16]，或任务内干扰的分析，例如[19]、[ 20]、[26]、[42]。一般来说，任务内干扰分析建立在包络执行过程中的干扰分析（也称为关键路径或关键路径）的基础上。直观上，包络路径是依赖于调度的子作业序列，其特性是所有包络路径子作业的到达和完成时间间隔是DAG作业的到达时间和完成时间间隔的划分。由于这些子作业包含 DAG 作业的执行，因此用于执行信封路径子作业的累积时间量以及信封路径子作业受到干扰的累积时间量限制了响应时间。

与最先进的技术相比，我们分析了沿着包络路径的多个用户选择的路径的同时进行，最多有多个处理器的数量。因此，我们只需考虑不属于任何用户选择的响应时间限制路径的子作业的干扰，从而能够将格雷厄姆的完工时间限制从一条路径推广到多条路径。这种改进是通过任务内优先级排序来实现的，即通过为用户选择的路径的所有子任务分配较低的优先级。由此，包络路径子作业的进展和来自用户选择的路径的子作业的进展可以在分析上彼此相关。据我们所知，这是第一篇提出并行路径进展概念1和相应的响应时间分析以及这些概念对分层调度的扩展的论文。

贡献：我们提供以下贡献：

- 基于第 III-A 节中提出的并行路径进展概念，我们在第 III-B 节中提出了一种<span style="color:black;background:#ff4d4f !important;">抢占式固定优先级调度算法，以及针对最多处理器数量的任意路径集合的可持续响应时间分析</span>。在第四节中，我们提供了<span style="color:black;background:#ff4d4f !important;">一种多项式时间算法，该算法要么找到完全覆盖 DAG 的路径集合（如果存在可用数量的处理器），要么找到具有可证明有界的最坏情况响应时间的近似值。</span>
- 我们将我们的研究结果扩展到第五节中的两种分层调度算法。即<span style="color:black;background:#ff4d4f !important;">第 V-A 节中的偶发任意截止日期团体预订系统和 V-B 节中的偶发任意截止日期普通预订系统</span>，它们利用了并行路径进展概念。分层调度算法可以应用于零星的任意期限 DAG 任务，这些任务可以与不同任务模型描述的任务（例如顺序任务）同时执行。
- 对于这两个预订系统，我们提供响应时间分析和算法来生成“可行”的预订系统，分别如第 V-A 和 V-B 节中所述。
- 在第六节中，我们使用综合生成的 DAG 任务集评估我们的方法，并证明我们的方法在高并行性场景中推进了最先进的技术，并表明我们的方法的性能介于起始-在更连续的场景中进行最先进的联合调度。

# 二.任务模型和问题描述
我们考虑一个集合 T := {τ1, . 。 。 , τn} 是在 M 个同构处理器上调度和执行的零星任意截止时间有向无环图 (DAG) 任务。每个任务 τi := (Gi, Di, Ti) ∈ T 由描述子任务和优先约束、最小到达时间 Ti 和相对截止时间 Di 的 DAG Gi 定义。每个任务都会释放无限序列的任务实例，称为作业。我们用 Ji 表示任务 τi 的第-个作业，用 ai 、 fi 和 di = ai + Di 表示作业 Ji 的到达时间、完成时间和（绝对）截止日期。

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405091128296.png)


**DAG**：任务的 DAG Gi 由元组 (Vi, Ei) 定义，其中 Vi 表示子任务的有限集，关系 Ei ⊆ Vi × Vi 表示它们之间的优先级约束，因此不存在循环优先级约束。为了在数学上精确，每个作业 Jil 都与 DAG Gil 的一个实例相关联，该实例具有相应的第l个子作业 vjl，其中 vj 是 Vi 中的子任务。任务τi的第l个作业的子作业，即vjl (vj ∈ Vi)，在(vk, vj) ​​∈ Vi的所有第l个子作业vkl 执行完毕后被释放。为了减少这种表示法，我们在分析一项特定作业时删除任务和作业的索引。也就是说，我们用 G = (V, E) 和 vj ∈ V 来表示特定 DAG 作业的子作业。示例性 DAG 如图 1 所示。

**Volume**： <span style="color:#00b050 !important;">voli : Vi → R≥0 指定每个子任务 vj ∈ Vi 的最坏情况执行时间，</span>这意味着没有子作业（实例）vjl 在执行平台上执行的时间超过 voli(vj) 个时间单位，但是可能会更早完成。此外，子任务 W ⊆ Vi 的任意子集的体积为 vol(W ) := Σ vj∈W   voli(vj)。特别是，任务的总体积 τi 由 Ci := voli(Vi) 给出。

**发布和截止日期**：在实时系统中，任务必须满足时间要求，即每个作业 Jil 必须在作业到达 ail 和该作业在 ail + Di 的绝对截止日期之间完成其总量。如果每个作业都满足其截止日期，即，fil ≤ ail + Di 对于所有 l∈ N，则称任务 τi 满足其截止日期。我们考虑任意截止日期，这意味着我们不对截止日期和 inter 的关系做出任何假设-到达时间。例如，相对期限可能小于最小到达间隔时间 (Di ≤ Ti)，在这种情况下，只有前一个作业完成后才会释放新作业。或者，截止时间可以大于最小到达间隔时间（Di > Ti），在这种情况下，尽管先前的作业尚未完成，但仍可以发布新的作业。 τi 的任何两个后续作业的释放时间至少相隔 Ti 个时间单位，即，对于所有 ε N，a l+1,i ≥ ail + Ti。表 1 中提供了所用符号的摘要。


![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405091131463.png)

# 三．并行性和路径感知调度

DAG 任务的并行性本质上受到其组成的路径的限制，因为路径强制执行关联子作业的顺序执行顺序。在本文中，我们的目标是通过强制执行跟踪和保证 DAG 内路径集合并行进度的属性来减少任务内干扰，从而显着改善高并行用例的最坏情况响应时间。为此，我们回答以下问题：（Q1）跟踪和保证一组专用处理器上的并行路径进展所需的最小理论属性是什么？ （Q2）任何路径集合都可以用于并行进程吗？如果可以，什么是可证明的良好选择？ （Q3）如何扩展（Q1）和（Q2）的结果以考虑分层调度？

## A. 并行路径进展概念
在本小节中，我们将研究在专用于执行 DAG 任务的单个作业的 M 个处理器上实现并行路径进展所需的属性。这样，我们就避免了任何任务间干扰，只关注任务内干扰。

**定义 1（路径）**：对于 DAG G = (V, E) 的每个子任务 vj ∈ V，vj 的前驱集由 pred(vj) := {vi ∈ V | (vi, vj) ​​∈ E}。 vj 的后继集合分别由下式给出 和 succ(vj) := {vi ∈ V | (vj, vi) ∈ E}。路径是一组有序的子任务 π := 〈v1,...。 。 。 , vn> 使得 pred(v1) = ∅, succ(vn) = ∅ 且 vk ∈ pred(vk+1) 对于所有 k ∈ {1, . 。 。 ，n−1}。如果 pred(v1) = ∅ 或 succ(vn) = ∅ 则 π 在本文中不被视为路径。

**定义2（n路径集合）**：设一个DAG G = (V, E)，则所有可能路径的枚举表示为 Ψ(G) := {π | π 是 G 中的根据定义 1 的路径}。来自 ψ(G) 幂集的路径 ψ ∈ P(ψ(G)) 的任何子集称为路径集合。此外，如果 |ψ| = n，则路径集合 ψ ∈ P(ψ(G)) 被称为 n 路径集合。即 ψ 是 n 条路径的集合。
> 幂集，所有可能的合集，包括空集和本身
> ψ(G) 只包含所有可能的路径（路径1，路径2）
> P(ψ(G))包括空路径，路径1，路径2，路径1+路径2

在本文的其余部分中，我们将使用 π* 来表示 G 中的最长路径，即，对于所有 π ∈ Ψ(G)，vol(π*) ≥ vol(π)。事实上，<span style="color:black;background:#d3f8b6 !important;">可以并行执行的最大路径数量受到处理器数量 M 的限制。因此，我们将解决方案空间限制为 n 路径集合，其中 n ∈ {1, . 。 。 ，M}</span>。基于具体的 n 路径集合 ψ，对于每个 πψ1 。 。 。 , πψn ∈ ψ, 属于 ψ 中至少一条路径的子任务集由 Vs(ψ) := πψ1 ∪ · · · ∪ πψn 定义。请注意，我们使用下标来索引属于路径集合的路径。相反，不属于任何选定路径的子任务的补集由 Vsc(ψ) := {v ∈ V | v ∉ Vs(ψ)}。

我们提出了一种并行进度优先级，根据上述集合的成员资格为每个子任务赋予优先级，这在以下定义中得到了形式化。在本节后面，我们将解释如何通过在响应时间分析中明确考虑 ψ 中路径的并行执行，使用这种优先级来更好地分析自干扰。

**定义 3（并行路径进展优先级）**：令 Vs(ψ) 表示 DAG G = (V, E) 的 n 路径集合 ψ 中的子任务集。所有子任务 v ∈ V 的固定优先级策略是并行路径进展优先级当且仅当对于任意两个 vi ∈ Vs(ψ) 和 vk ∈ Vsc(ψ) ，Π(vi) < Π(vk)，其中 Π( vi) 表示子任务 vi 的优先级。
> 补集的优先级更高

请注意，在我们的<span style="color:black;background:#d3f8b6 !important;">优先级符号中，较高的值意味着较高的优先级，即 Π(vi) > Π(vk) 意味着 vi 比 vk 具有更高的优先级。</span>满足并行路径进展优先级属性的充分策略是仅使用两个不同的优先级级别。

我们在下面的例子中集中阐明引入的符号和定义。图 1 所示 DAG 的路径枚举 Ψ(G) 由 6 条路径 {π1, π2,…. 。 。 , π6}，即； π1 := 〈v1, v2, v3〉, π2 := 〈v1, v4, v5, v9〉, π3 := 〈v1, v4, v5, v6〉, π4 := 〈v1, v7, v5, v9〉, π5 := 〈v1, v7, v5, v6〉 和 π6 := 〈v1, v7, v8〉。来自幂集 P(Ψ(G)) 的 2 路径集合 ψ 例如由 ψ := {π2, π3} 给出。随后，Vs(ψ) = π2 ∪ π3 = {v1, v4, v5, v6, v9} 和 Vsc(ψ) := {v2, v3, v7, v8}。例如，如果所有子作业 vi ∈ Vs(ψ) 被分配优先级 Π(vi) = 1，相反，所有子作业 vi ∈ Vsc(ψ) 被分配优先级 Π(vi) = 2，则此优先级是有效的并行路径进度优先顺序。
> 看不懂

## B. 并行路径进展调度
在本小节中，我们将研究通过工作保存抢占列表调度算法结合并行路径进展优先级在 M 个专用处理器上调度的单个 DAG 作业。我们详细阐述了这种优先级如何帮助分析路径集合的并行进程，从而帮助分析 DAG 作业的响应时间。

**定义 4（List-FP）**：在 M 个专用处理器上的抢占式 list-FP 调度中，DAG 任务 G = (V, E) 的任务实例（作业），每个子作业 v ∈ V 的固定优先级分配为按照以下规则安排：
- 如果所有前面的子作业都已执行直至完成，则子作业到达就绪列表，即每个子作业 vi 的子作业到达时间 ai 由 max{fj | vj ∈ pred(vi)} 给出。 已到达但尚未完成的子作业被视为待处理。
- 在任何时间 t，M 个最高优先级的挂起子作业将在 M 个处理器上执行，并且如果需要，较低优先级的子作业将被抢占。
首先，我们引入并形式化调度包络的概念，它是一系列子作业，其属性是所有包络路径子作业的到达和完成时间间隔，是 DAG 的到达时间和完成时间间隔的划分工作。

**定义 5（包络）**：令 S 为某个 DAG 任务 G = (V, E) 的给定 DAG 作业的子作业 V = {v1, . 。 。, vl }的任何具体调度。令每个子作业 vk ∈ V 在 S 中具有到达时间 ak 和结束时间 fk。我们将 G 在 S 中的包络定义为到达和结束时间间隔的集合 \[ak1 , fk1 ), \[ak2 , fk2 ) , . 。 。 , \[akp , fkp ) 对于某些 p ∈ {1, . 。 。 ,l } 向后迭代如下： 
1) ki = kj ∈ {1, . 。 。 , l} 对于所有 i = j。 
2) vkp 是V 中完成时间最长的子作业。 
3) vki−1 是 vki 之前具有最大完成时间的子作业，对于所有 i ∈ {p, p − 1,...。 。 。 , 2}。 
4) vk1 是源节点，即没有前驱节点。

我们称 πe := {vk1 , vk2 , . 。 。 , vkp } 包络路径。我们注意到，如果存在具有相同完成时间的子作业，则 DAG 作业的包络定义可能不唯一。在这种情况下，关系可以任意断开。

在本小节的剩余部分中，我们使用之前介绍的所有属性来分析单个 DAG 作业的响应时间。为单个作业 J 生成 M 个专用处理器上的固定优先级列表调度 S，其中所有子作业都根据定义 3 中描述的规则确定优先级。对于响应时间分析，我们分析之间的时间间隔 \[aJ , fJ )将J的到达时间和结束时间按区间划分为繁忙时间和非繁忙时间。如果在时间 t 在 S 中执行包络子作业，则任何时间点 t ∈ \[aJ , fJ ) 都称为忙。相反，如果包络子作业未执行，则任何时间点 t ∈\[aJ , fJ ) 称为非忙。通过根据定义 5 构建包络，必须在任何时间点 t ∈ \[aJ , fJ ) 信封子作业处于待处理状态，即已到达但尚未完成。结合 t 可以完全忙或不忙这一简单事实，我们知道 DAG 作业 J 的响应时间由在这两种状态中的任何一个状态下花费的累积时间量给出。

与之前的工作相比，我们将非繁忙时间进一步划分为并行路径（如果包络子作业 vki ∈ Vs(ψ)）和非并行路径时间（如果 vki ∈ Vsc(ψ)），假设包络路径 πe := 〈vk1 , vk2 , . 。 。 , vkp 〉 在S。这种方法的直觉是将包络子作业的执行与路径集合 ψ 的子作业的执行联系起来，这将在接下来的分析中使用和解释。

**定理 6（抢先响应时间限制）**：具有任意 n 路径集合的 DAG 作业 J 的响应时间 ψ = {πψ1 , . 。 。 , πψn } ∈P(Ψ(G)) （n  最多为M ）使用抢占式 List-FP 调度在 M 个专用同构处理器上调度，其边界为
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405091452597.png)

证明：根据包络的定义（参见定义 5），我们知道在具体的抢占式列表-FP 调度 S 中，DAG 作业到达到完成时间的间隔 \[aJ , fJ ) 可以被划分成连续的区间 \[ak1 , fk1 = ak2 ), . 。 。 , \[fkn−1 = akn , fkn ) 其中 \[aki , fki )​​ 表示所有 i ∈ {1, .  。 。 , p}的子作业 vki 的到达和完成时间, 在包络线 πe := {vk1 , vk2 , . 。 。 ，vkp}。

**繁忙时间**：单独考虑每个包络子作业间隔 \[aki , fki )​​ 对于 i ∈ {1, . 。 。 , p}，繁忙时间量由 vki 的执行时间给出，根据定义，该执行时间不超过 vol(vki )。 \[aJ , fJ ) 中的累积繁忙时间量可以通过将间隔的各个繁忙时间相加而获得，即 vol(πe)，其不超过最长路径 vol(π*)。

**非繁忙时间**：由于我们的调度策略是节省工作的，因此每当包络子作业 vki 在 \[aki , fki )​​ 期间不执行时，所有 M 个处理器都必须忙于执行非包络子作业。由于 vki 可以排他地存在于 Vs(ψ) 或 Vsc(ψ) 中，因此我们分析集合 {t ∈ \[aJ , fJ ) |包络子作业未执行} ∩ \[aki , fki )​​ 对于两种情况分别：
- **并行路径**：令 vki ∈ Vs(ψ) 并假设在时间 t 不执行，则最多 n − 1 个处理器执行 Vs(ψ) 中的子作业。这是因为 Vs(ψ) 中的所有子作业都源自 n 个不同的路径，这意味着一般情况下，Vs(ψ) 中同时待处理的子作业永远不会超过 n 个。此外，由于假设 vki ∈ Vs(ψ) 并且在 t 时不执行，因此 Vs(ψ) 中的最多 n − 1 个子作业处于待处理状态。相反，我们知道至少有 M − (n − 1) 个处理器执行 Vsc(ψ) 中的子作业，否则 vki 的执行将会与案例假设相矛盾。
- **非并行路径**：在另一种情况下，令 vki ∈ Vsc(ψ) 并假设在时间 t 未执行，则必定没有处理器正在执行 Vs(ψ) 中的任何子作业。这是因为，如果 Vs(ψ) 中的任何较低优先级子作业将被执行，则较高优先级的包络子作业 vki ∈ Vsc(ψ) 也将被执行，这与案例假设相矛盾。相反，我们知道所有 M 个处理器都专门用于执行 Vsc(ψ) 的子作业。
总之，我们知道在所有非繁忙时间 t ∈ \[aJ , fJ ) 中，至少有 M − (n − 1) 个处理器执行 Vsc(ψ) 的子作业。 \[aJ , fJ ) 期间来自 Vsc(ψ) 的子作业总量最多为 vol(Vsc(ψ))。非繁忙时间的最大累积量是通过平均分配工作量来实现的，因此不超过vol(Vsc(ψ))/(M − (n − 1))。

我们的响应时间分析的可持续性：<span style="color:black;background:#fff88f !important;">文献中提出的许多多处理器硬实时调度算法和可调度性分析都是不可持续的，这意味着它们会出现时序异常。</span>这些异常描述了一种反直觉的现象，即被验证始终满足其截止日期的作业可能会通过增加资源而错过其截止日期，例如，在更多处理器上执行作业或减少执行时间（提前完成）。在推论 7 中，我们表明我们的响应时间限制在处理器数量和子作业执行时间方面是可持续的。在可用处理器和执行时间各不相同的动态环境中，这是一个有益的特性，并最终简化了实际系统中的实现工作。

**推论 7（可持续性）**：定理 6 中的响应时间界限对于 G = (V, E) 的 DAG 作业成立，即使任何子作业 v ∈ V 在其最坏情况执行时间之前完成或者处理器数量增加。

证明：这直接来自于包络路径 vol(πe) 的体积以及并行路径非繁忙和非并行路径非繁忙间隔的长度只有在最坏情况执行时间为任何子作业减少或处理器数量增加。由于响应时间的上限是执行包络作业的次数和不执行包络作业的次数之和，因此证明了推论。
## A. DAG 顶点覆盖
寻找最少数量的顶点不相交路径（使得图 G 的所有顶点都被覆盖）的一般问题是一个 NP 完全问题，可以通过简化为 HAMILTONIANCYCLE 问题来证明。然而，对于有向图 G，Gallai 和 Milgram 在 1960 年表明，覆盖有向图 G 的所有顶点的顶点不相交路径的最小数量不超过 G 的最大独立集的大小，概括了结果来自 Dilworth [11] 和 König-Egevary [10]。

在有向图也是非循环的情况下，即 DAG，则可以通过已知的二分图中最大匹配问题的简化，在多项式时间内计算 G 的最大独立集，例如，Hopcroft-Karp算法。

例如，覆盖图 1 所示 DAG 的顶点不相交路径集由下式给出： U = {<v1, v2, v3>, <v4, v5, v6>, <v7, v8>, \<v9> }，其计算方法如上所述。在我们提出的路径收集算法中，我们需要完全覆盖 G 的从源顶点到汇顶点的路径集合，这些路径不一定是顶点不相交的。因此，我们在这里解释了我们提出的算法 1 第 1 行所要求的显式算法构造，以获得覆盖 G 的 w ∈ N 多条路径。请注意，对于我们的算法，知道数值 w 就足够了，而无需知道显式的路径。然而，为了证明存在性，我们显式地构造了 w 条路径。

对于每个 i∈ {1, . . . , |U |}，我们用顶点不相交路径 ui = 〈ui1 , . . . , uin 〉 ∈ U ,初始化第 i 条路径 πi，并连续应用以下步骤，直到所有 πi 都是根据定义 1 的路径：
- 如果 πi 中最左边的顶点不是 G 的源顶点，则针对某个 z∈ {1, . . . , m} 选择任意 uh = 〈uh1 , . . . , uhm 〉 ∈ U 使得 E 中的 <vuhz , vui1 > 并将路径延伸到πi = 〈uh1 , . . . , uhz 〉 ◦ πi 。
- 如果 πi 中最右边的顶点不是 G 的汇顶点，则选择任何元组 uh = 〈uh1 , . . . , uhm 〉 使得 E 中对于某个 z∈ {1, . . . , m}  存在 <vuin , vuhz > 并将路径更新为 πi = 〈uh1 , . . . , uhz 〉 ◦ πi 

例如，参考所提供的示例，我们从 u4 = (9) 开始，其中 π4 = 〈v9〉（它是 G 中的一个汇点）并识别元组 u2 = (4, 5, 6)，因为 (v5, v9) ∈E 并且路径更新为 π4 = 〈v4, v5, v9〉。由于 v4 不是 G 中的源顶点，我们继续并由于 (v1, v4) ∈ E 识别 u1 = (1, 2, 3) 并更新 π4 = 〈v1, v4, v5, v9〉。由于 v1 是源顶点，因此过程终止。重复该过程产生四个简单路径 π1 = 〈v1, v2, v3〉, π2 = 〈v1, v7, v8〉, π3 = 〈v1, v4, v5, v6〉, π4 = 〈v1, v4, v5, v9>，共同覆盖所有顶点 v ∈ V 。请注意，虽然在此示例中，w = 4 是覆盖 G 的最小路径数，但该算法通常仅提供安全上限。

# B. 加权最大覆盖范围
另一个相关算法是加权最大覆盖率[31]问题。下面，我们将寻找 DAG G 最大化 vol(Vs(ψ))（最小化 vol(Vsc(ψ))）的 n 路径集合 ψ 的问题映射到该问题，如下所示：
- 输入：加权最大覆盖问题的问题实例 I 由集合 S := {S1, . 。 。 , Sm}、权重函数 ω 和自然数 k。每个集合 Si ⊆ U 都是某个总体 U 的子集，其中每个 i ∈ {1, . 。 。 , m} 并且每个元素 s ∈ Si 都与函数 ω(s) 给出的权重相关联。
- 目标：对于给定的问题实例 I，目标是找到一个子集 S′ ⊆ S 使得 |S′| ≤ k 且 Σ s∈{∪{Si∈S′}} w(s) 最大化。
Nemhauser 等人证明了这一点。 [31] 加权最大覆盖问题的任何多项式时间逼近算法相对于下界为 1 − 1/e 的最优解具有渐近逼近比，除非 P = N P ，其中 e 是欧拉数。这种近似比率可以通过贪婪策略来实现，该策略总是选择包含尚未选择的元素的最大权重的集合。尽管加权最大覆盖率和我们的问题并不等价，但我们对算法 1 中的 n 路径集合近似使用相同的近似策略。

## C. 近似算法
基于大小为w的路径集合的存在性，可以分析算法1的逼近质量。我们首先提出我们提出的算法，然后证明逼近因子。
n 路径集合近似算法：从算法 1 中的第 1 行到第 3 行，计算完全覆盖 的最小路径数的上限 w。如果处理器的数量 M 足以允许所有 w 条路径的并行执行，即 w ≤ M，则选择这些路径作为路径集合。

在另一种情况下，从第 4 行到第 17 行，在每次迭代中 n ∈ {1,... 。 。 , M }，选择相对于当前迭代的体积函数 vol' 的最长路径 π\*n。选择路径后，该路径的子作业的所有体积都设置为0，表示子作业已被覆盖。通过这种策略，我们总是选择每次迭代中包含最大数量的尚未选择的子作业的路径。此外，在每次第 n 次迭代中，在第 14 行中探测解 ψn 是否严格改进先验解 ψn−1 少一条路径。在第 M 次迭代结束时，发现一个 n* 路径集合 ψ*，它产生如定理 8 中所述的形式保证。使用 Hopcroft-Karp 算法可以在 O(|V |) 中获得最大二分匹配。 nPCA 的时间复杂度主要由 for 循环和第 9 行中每次迭代中调用的深度优先搜索 (DFS) 决定，导致时间复杂度为 O(M · |V ||E|)

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405091620847.png)
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405091648684.png)
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405091648305.png)


**定理 8 (nPCA)**：使用并行路径级数调度且根据算法 1 计算 n* 多路径的 DAG 作业 J (makespan) 在 M 个专用处理器上的最坏情况响应时间最多为
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405101015404.png)
其中 w 指的是 PATHCOVERAGE 的解。
> 能覆盖所有节点的最小路径数

证明：我们分别针对 M ≥ w 和 M < w 的情况证明该定理。
情况 1：在第一种情况下，即从第 1 行到第 3 行，令 M ≥ w。从第 IV-A 节的讨论中，我们知道 DAG G = (V, E) 的每个顶点 v ∈ V 至少被 PATHCOVERAGE 算法计算出的 w 条路径中的一条覆盖，这些路径在 PATHCOVERAGE 算法中返回第 3 行。因此，响应时间界限由下式给出
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405101029489.png)
它的上限是最佳响应时间，因为 G 中的最长路径是任何 DAG 作业响应时间的下限。

情况 2：请注意，从 PATHCOVERAGE 获得的 w 不是最小解，而是它的上限。也就是说，在w>M≥n≥1的约束下，可能存在n条路径，使得可以覆盖DAG总体积C。然而，尚不知道这样的最小解是否可以在多项式时间内计算。然而，我们可以证明最佳响应时间相对于该上限的近似比率。

步骤 1：我们通过反证法证明，对于每次迭代 n ∈ {1, . 。 。 , M } 以下不等式成立
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405101036780.png)
其中 ψ0 := ∅ 且 vol(Vs(ψ0)) = 0。为了使证明更加清晰，我们在第 n 次迭代中使用 vol(n) 来指代 vol′。假设矛盾存在迭代 n ∈ {1, . 。 。 , M } 这样
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405101039712.png)
成立。那么它必须特别指出
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405101039271.png)
其中 - - 通过算法策略选择- π\*n，使得对于所有路径 π ∈ Ψ(G)，满足不等式 vol(n)(π\*n) ≥ vol(n)(π)。因此，对于任意 w 条路径的集合，w·vol(n)(π\*n) ≥ vol(n)(∪w,i=1  πi)。因此，如果 (6) 成立，那么
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405101042990.png)
也成立。根据算法不难看出
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405101043960.png)
成立，因为如果第 n 次迭代中顶点的体积与初始体积不同，则该顶点必须被先前迭代期间收集的任何路径覆盖，即 Vs(ψn−1)。然后，在 (7) 中使用 (8) 的恒等式，得出 (5) 对于任意 w 条路径的任意集合，得出条件 vol(∪w,i=1  πi) < C，这与 w 条解的存在性相矛盾路径。

步骤 2：在第二步中，我们现在通过归纳法断言并证明
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202405101044348.png)








***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足\&可继续研究

## 5 可参考

## 6 思考
