---
created: 2023-12-28T22:10
updated: 2024-02-27T15:17
tags:
  - 笔记
  - 笔记/文献笔记
---


# Efficient maximum data age analysis for cause-effect chains in automotive systems
# 汽车系统因果链的高效最大数据时效分析

| Title                 | Efficient maximum data age analysis for cause-effect chains in automotive systems |
| --------------------- | --------------------------------------------------------------------------------- |
| Journal or Conference | DAC '22: 59th ACM/IEEE Design Automation Conference                               |
| Authors               | Ran Bi; Xinbin Liu; Jiankang Ren; Pengfei Wang; Huawei Lv; Guozhen Tan            |
| Pub. date             | 2022-07-10                                                                        |
| DOI                   | [10/gsfbs4](https://doi.org/10/gsfbs4)                                            |
| Level                 | CCF A                                                                             |
# 摘要
汽车系统经常受到对某些因果链的最大数据年龄的严格要求。本文提出了一种形式化分析因果链最大值数据年龄的有效方法。特别地，我们将链的最大数据年龄的边界问题解耦为链中连续的倒数数据传播实例的释放间隔的边界问题。由于问题的解耦，可以在多项式时间内有效地获得相对较紧的数据年龄上界。实验表明，该方法能够以较低的计算代价实现较高的分析精度。


# 1 introduction
随着人工智能技术的飞速发展，汽车系统越来越多地集成了更多的数据依赖组件，通过端到端的计算来实现智能驾驶。考虑到这种复杂性，汽车系统通常用因果链建模，以描述依赖数据的任务的逻辑顺序(例如，执行传感、处理和驱动)[5]。对于大多数与安全相关的汽车应用，通常对通过因果链的数据传播有一些严格的端到端时序限制，从而符合功能安全汽车标准ISO 26262[10]。此外，当今的汽车系统本质上是高度分布式的，它们通常运行在由多个电子控制单元(ECU)与标准化总线连接的分布式体系结构上。因此，为分布式系统的因果链提供一种有效的端到端时序分析策略是至关重要的，这样才能有效地验证复杂汽车系统对端到端时序的严格要求。
对于因果链的端到端时序分析，根据延迟语义，现有的分析方法一般可以分为两类：反应时间分析和数据年龄分析[5]。反应时间分析得出从外部原因发生到该外部原因被处理为止的最大时间间隔。反应时间是对系统反应性的衡量，它是人体电子学中分析系统对外部原因的第一反应的首选[5]。与反应时间分析相比，数据年龄分析从采样值开始计算最大时间间隔，直到基于该采样值执行动作的最后一个时间点。数据年龄是数据新鲜度的一种度量，它直接影响到可实现的控制性能。对于反应时间和数据年龄之间的关系，Dürr等人。[5]证明了最大反应时间总是因果链最大数据年龄的上界。本文主要研究分布式系统中周期因果链的最大数据年龄分析。请注意，有效地计算此类系统的准确最大数据年龄并不是一件容易的事，因为当链中的任务具有不同的激活周期时，应该考虑过采样和欠采样的问题。
对于运行在不同节点上的周期性因果链，Davare等人。[4]提出了一种具有线性时间复杂度的最坏情况延迟分析方法，该方法通过简单地求出最坏情况响应时间和因果链中所有任务的周期，从而得到最大数据年龄和最大反应时间的上界。然而，这种方法过于悲观，因为它单独考虑链中每个任务的计时行为。对于具有周期性偏移同步任务的因果链，Schlatow等人。[14]提出了一种通过限定因果链中连续读写事件之间的距离来分析数据年龄的方法。然而，他们的分析方法主要适用于简谐任务系统，对于非简谐情况，其分析结果比Davare等人提出的方法更为悲观。[4]。对于分布式系统中的SPO-Radic因果链，Dürr等人。[5]提出了一种基于直接后向作业链的数据年龄分析方法，并分析了Davare等人的分析。[4]。
然而，他们的方法对于周期性的因果链过于悲观，因为他们忽略了任务周期对直接向后的作业链中两个作业的释放时间之间的差距的影响。为了准确估计全局异步化、局部同步化分布式系统上的异步周期任务集的最大数据年龄，Günzel等人提出了一种新的方法。[8]针对单个ECU场景，提出了一种精确的最大数据年龄分析方法，并通过限定全球异步分布式系统中ECU之间的通信时间，将其扩展到互联ECU场景。然而，这种方法的计算复杂性呈指数级增长，这在交互式设计环境中成为巨大的缺陷，<span style="color:black;background:#fff88f !important;">在这种环境中，需要多次调用最大数据年龄分析算法来评估和优化设计级的多个设计选择[13]。</span>
<span style="color:black;background:#fff88f !important;">此外，随着汽车动力系统中软件规模和复杂性的快速增加，这个问题将恶化[2]。</span>为了解决这一问题，我们提出了一种问题分解方法，用于<span style="color:black;background:#ff4d4f !important;">有效地计算相对较紧而不是准确的最大数据年龄上限</span>。我们的方法，称为DBAge，是基于对因果链中连续的最后到最后的数据传播实例的发布间隔上限的分析。<span style="color:black;background:#d3f8b6 !important;">基于链中每对连续任务的最后到最后一个数据传播实例的释放间隔上界，我们可以通过简单累加在多项式时间内高效地计算数据年龄上界，而不像[8]中那样枚举超周期内的所有作业链</span>。
贡献。与前人的工作相比，本文主要做了以下工作：
 - 将因果链的最大数据年龄限制问题分解为因果链中连续任务的最后一个数据传播实例的发布间隔限制问题。
- 通过研究链中连续任务的相邻实例的释放间隔，得到了后续最后到最后一个数据传播实例的释放间隔的上界。
- 在问题解耦的基础上，提出了一种在任务最坏响应时间已知的情况下，计算具有多项式时间复杂度的因果链最大数据年龄的有效算法。
基于一个汽车基准的评估表明，该方法具有很高的效率和较低的精度损失。

# 2 模型
本文研究的汽车系统由<span style="color:black;background:#d3f8b6 !important;">N个独立的周期性实时任务</span>组成，由Γ={τ1，...，τN}标识，它们在具有m个电子控制单元(ECU)的全局异步局部同步(GALS)分布式体系结构上执行。每个任务被静态地分配给一个专用的ECU，每个ECU上的任务按照固定优先级的抢占调度策略进行调度。每个∈τIΓ由一个元组τi=(Ci，Ti，Di)来表征，其中
- Ci是任务τi的最坏情况执行时间；
- ti是任务τi的周期；
- Di是任务τi的相对截止日期。
对于任务集i，我们使用由Ui表示的术语利用率来表示比率Ci/Ti，并且设UΓ表示任务集Γ的总利用率(即，$U_\Gamma= {\textstyle \sum_{\tau_i \in \Gamma }}U_i$)。我们假设所有任务都受隐式最后期限(即Di=Ti)的约束，并且它们最初在时刻t=0被同时释放。任务τi的实例释放时间记为ri，属于无限集合A(τi)={0，Ti，2Ti，...}。对于在ri处释放的任务τi的实例，其完成时间表示为fi(ri)。任务τi的最坏情况响应时间被表示为Ri，它是从其实例释放时间到其执行结束时间之间的最长时间间隔。对于每个任务Di∈Di，如果Ri≤Di，则系统被认为是可调度的。假设每个任务τi具有唯一的优先级Pi，并且如果τi具有比τj更高的优先级，则我们将其表示为Pi < Pj。

本文主要研究AUTOSAR[9]中定义的隐式通信语义。在隐式通信语义中，每个任务在其执行开始时将所需数据读入其本地内存，并在其执行结束时写入所产生的结果。此外，在执行过程中，该任务仅在本地副本上运行。利用这种通信语义，可以减少对远程存储器的访问时间，避免数据不一致。对于分配给同一ECU的任务，我们假设它们通过共享寄存器进行通信。对于分布在不同ECU上的任务，它们通过广播总线进行通信，我们将这种通信建模为总线上的周期性实时通信任务。请注意，链中的连续任务之间没有信令，任务仅根据分配的优先级进行调度。

基于上述通信范式，我们使用因果链对汽车系统中执行数据依赖任务的因果顺序进行建模。因果链Fn是描述任务之间的通信流的n≥1任务(τ1、τ2、...τn)的序列。因果链Fn的第一个和最后一个任务分别表示为Head(Fn)=τ1和Last(Fn)=τn。

对于单一和互联的ECU场景，我们考虑了两种类型的因果链：<span style="color:black;background:#d3f8b6 !important;">局部因果链和互联因果链</span>。对于本地因果链，该链的所有任务都在单个ECU上执行。相比之下，相互关联的因果链的任务分散在多个ECU上。注意，<span style="color:black;background:#d3f8b6 !important;">互连的ECU可以是同步的，也可以是异步的，并且它们的通信是通过通信任务实现的。</span>

作为控制应用的重要指标，数据年龄直接影响汽车系统可实现的控制性能[1]。对于因果链，我们定义其数据年龄如下[5]。
**定义2.1. (Data年龄[5]）**。对于因果链F n，其数据年龄定义为
- 因果链F n的头任务head（F n）读取数据的时刻
- 因果链F n的最后任务last（F n）完成处理数据的时刻之间经过的时间间隔
为了形式化地建模因果链的最大数据年龄，基于[6]中引入的时间路径的概念，我们定义了因果链的最后到最后路径。

**定义2.2。(last-to-last路径[6])**。设Fn是其头部任务在时刻r1∈A(τ1)被释放的因果链，最后到最后的路径由Ω(Fn，r1)=(r1，...，rn)表示，其中$ri\inΩ(Fn，r1)$(i>1)是从释放时间为ri−1的任务τi-1的实例写入的寄存器中读取最后未重写数据的任务τi的最后输出实例的释放时间，并且任务τi在执行后将该数据写入与下一个任务τi+1共享的寄存器时传播数据。

**定义2.3.** 给定因果链Fn的一条最后到最后的路Ω（Fn，r1），最后到最后的路Ω（Fn，r1）的区间长度，记为len（Ω（Fn，r1）），定义为，
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012006526.png)
其中，r1∈Ω(Fn，r1)以及fn(rn)是在rn∈Ω(Fn，r1)处释放的任务τn的完成时间。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012007209.png)
基于上述定义，我们定义了因果链的最大数据年龄如下[6]。
**定义2.4。(最长数据年龄[6])。** 设Fn是具有n≥1任务的因果链。因果链Fn的最大数据年龄DA(Fn)可表示如下：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012020636.png)
其中Ω(Fn，r1)是Fn的last-to-last路径，其第一个任务头(Fn)在r1处被释放。

如图1所示，它是因果链F3的Last-to-Last路径的一个例子，有三个任务。在超周期中，链F3有两条最后到最后的路径，即，Ω（F3，r1 = 0）和Ω（F3，r1 = 12）。由于所有任务最初都是同时发布的，因此我们可以通过仅考虑第一个超周期内的Last-to-Last路径来获得链F3的最大数据年龄，并且它是max{15.5，9.5} = 15.5。

==问题：==本工作的主要目的是为实时分布式汽车系统中的周期性因果链提出一种有效的最大数据年龄分析策略，以便以较低的计算代价获得较紧的因果链数据年龄上限。本文将因果链的最大数据年龄限制问题分解为因果链中每对相邻任务的最后一个数据传播实例的发布间隔限制问题。基于这种解耦问题，我们还提出了一种计算数据年龄上界的多项式时间算法，该算法具有较低的精度损失。

# 3最长数据年龄分析
为了实现对因果链的最大数据年龄的有效分析，我们将因果链的最大数据年龄的界限问题解耦为链中每对相邻任务的最后到最后数据传播实例的释放间隔的界限问题(见定理3.1)。此外，我们还推导了连续的最后到最后的数据传播实例的释放间隔的上界，以产生期望的最大数据年龄界(见定理3.2)。现在，我们首先给出了单个ECU场景下的局部因果链的分析方法。然后，基于[8]中证明的最大最大数据年龄的组成性质，我们将我们的分析方法扩展到多ECU场景中的互连因果链。

**定义3.1。** 设Fn=(≥1，τ2，...，τn)是n≥2任务的局部因果链，Ω(Fn，r1)=(r1，r2，...，rn)是Fn的last-to-last路径，τi和τi+1(1≤i≤n-1)在路径Ω(Fn，r1)中的传播实例释放时间间隔定义为$δ_{i，i+1}$，
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012102658.png)
其中ri∈Ω(Fn，r1)和ri+1∈Ω(Fn，r1)

**定义3.2**。对于具有n≥2个任务的局部因果链Fn=(τ1，τ2，...，τn)，设$δ^{ub}_{i，i+1}$表示对于链Fn的任一last-to-last数据传播路径，两个连续任务τi和τi+1(1≤i≤n-1)的传播实例释放时间之间的间隔的上界。
从定义3.2中，很容易得到以下结论
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012106777.png)
基于以上定义，我们可以获得局部因果链的最大数据年龄界限的以下替代表示。

**定理3.1**。设Fn是n≥2任务的局部因果链，其最大数据年龄DA(Fn)由下界限定：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012117959.png)
其中Rn是任务τn=Last(Fn)的WCRT，并且$δ^{ub}_{i，i+1}$是Fn中连续任务τi和τi+1的最后到最后数据传播实例的释放区间上界。
**证据**。通过方程式(1)、(2)和(4)，我们有
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012205380.png)
因此，DA(Fn)有界于方程(5)。
> fn-r1 = rn+Rn+r1 = Rn + ri+1 - ri = Rn + max{ri+1 - ri}
> 和[P]一样，r计算两个任务之间的时间，最后加上最后一个任务的WCRT
> 区别在于ri+1 - ri的计算方式

基于定理3.1，我们将局部因果链的最大数据年龄的边界问题解耦为链中每对相邻任务的Last-to-Last数据传播实例的释放间隔的边界问题。为了推导Last-to-Last数据传播实例的释放间隔的界限，我们<span style="color:black;background:#d3f8b6 !important;">将因果链Fn中的每对相邻任务τi和τi+1（1 ≤ i ≤ n − 1）建模为生产者和消费者</span>。现在，我们首先提出以下引理来描述任何两个周期性实时任务的相邻实例的释放间隔[12]。

**引理3.1**。([12])。对于任意两个任务τi=(Ci，Ti，Di)和τj=(Cj，Tj，Dj)，我们假设<span style="color:black;background:#d3f8b6 !important;">它们的第一个实例在时刻0同时释放</span>，设ri是任务τi的实例释放时间，$r^{front}_j$是不晚于ri的任务τj实例的释放时间，λij=$ri-r^{front}_j$，我们可以得到：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012212778.png)
其中ηij=gcd(Ti，Tj)，它是Ti和Tj的最大公约数。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012216212.png)


首先，我们认为生产者τi比消费者τi+1具有更高的优先级(即PI<PI+1)。如图2所示，它是这两个任务的执行示例。由于生产者τi具有更高的优先级，因此一旦发布，它就可以抢占消费者τi+1。因此，<span style="color:black;background:#d3f8b6 !important;">对于在ri发布的Producer实例产生的数据，消耗该数据的τi+1的最后一个输出实例应该在ri+Ti之前发布</span>。因此，我们可以获得：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012218723.png)
> 计算消费者（i+1）的最后一个输出实例，应该是对应第几个周期，也就是对应的释放时间

**引理3.2**。对于分配给同一ECU的两个可调度任务τi和τi+1，使得τi将其执行后的结果写入与τi+1共享的寄存器，并且τi具有比τi+1更高的优先级，则τi的实例释放时间ri∈τA(τi)与读取由在ri处释放的τi的实例传播的数据的τi+1的实例的释放时间ri+1之间的间隔$δ_{i，i+1}$不大于：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012225982.png)
式中，ηii+1是Ti和Ti+1的最大公约数
**证据**。设mod(Ti，Ti+1)是Ti除以Ti+1的余数，我们可以得到mod(Ti，Ti+1)∈Λi，i+1={0，ηi，i+1，…，Ti+1−ηi，i+1}。因此，通过公式(7)和引理3.1，我们得到
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012228560.png)
> λij=$ri-r^{front}_j$
> i的优先级高，
>   
a−(a mod  b)这个表达式的结果是b 的整数倍。

因此，当生产者τi具有比消费者τi+1更高的优先级时，$δ_{i，i+1}$受等式(8)的限制

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012307605.png)

现在，我们认为消费者τi+1具有比生产者τi更高的优先级(即，PI+1<PI)。图3示出了这两个任务的示例。如图3所示，一旦发布，消费者τi+1就可以抢占生产者τi的先机。因此，对于在ri发布的Producer实例产生的数据，消耗该数据的τi+1的最后输出实例应该在在ri+Ti发布的Producer实例完成之前发布。因此，我们可以获得：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401012307208.png)
**引理3.3**。对于分配给同一ECU的两个可调度任务τi和τi+1，使得τi将其执行后的结果写入到与τi+1共享的寄存器并且τi+1具有比τi更高的优先级，在δi的实例释放时间ri∈A(τi)和τi+1的实例读取由在ri处释放的τi的实例传播的数据的释放时间ri+1之间的间隔$δ_{i，i+1}$不大于
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401021050352.png)
**证据**。通过公式(9)和引理3.1，我们得到
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401021051606.png)

![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401022019851.png)
因此，当消费者τi+1具有比生产者τi更高的优先级时，$δ_{i，i+1}$受等式(10)的约束。
从引理3.2和3.3，我们可以得到下面的定理。
**定理3.2**。对于分配给同一ECU的两个可调度任务τi和τi+1，使得τi将其计算结果写入与τi+1共享的寄存器，在δi的实例释放时间ri∈A(τi)和τi+1的实例的释放时间ri+1之间的间隔$δ_{i，i+1}$最后一次读取由在ri处释放的τi的实例传播的数据不大于由下式给出的$δ^{ub}_{i，i+1}$：
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401022155484.png)

在定理3.1和3.2的基础上，针对固定优先级抢占式调度器在单ECU平台上执行的周期性因果链，设计了一种高效的最大数据年龄分析算法(即计算局部因果链的最大数据年龄)。<span style="color:black;background:#ffbbff !important;">我们的算法旨在以多项式时间复杂度计算相对较紧而不是精确的数据年龄上限。</span>为此，基于定理3.1，我们将因果链的最大数据年龄限制问题分解为因果链中每个相邻任务对的最后一个数据传播实例的释放间隔限制问题。此外，在定理3.2的基础上，我们推导出连续的最后到最后的数据传播实例的发布间隔的一个界，以产生期望的最大数据年龄界。由于问题的解耦，我们可以通过简单的累加来有效地计算数据年龄上界。如算法1所示，它是我们针对局部因果链的最大数据年龄分析方法的伪代码。通过定理3.1和3.2，我们可以得出我们算法的正确性。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401022156416.png)
基于[8]中证明的最大数据年龄的组成性质，我们可以通过将相互关联的因果链分割成更小的局部部分，将我们的局部因果链的最大数据年龄分析方法扩展到相互关联的因果链。在下文中，我们将局部因果链表示为LF，将相互关联的因果链表示为IF。

**定理3.3**.（切割[8]）。考虑包含k个局部因果链$LF_1，.，LF_k$和k-1个通信任务$τ^c_i，.，τ^c_{k−1}$，并且IF =（$LF_1 → τ$c_1 → LF_2 → τ$c_2 →..→ τ^c_{k−1} → LF_k$）。链IF的最大数据年龄可以通过下式计算：![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401022203318.png)其中DA(LFi)是局部因果链LFi的最大数据年龄，Tlast(LFi)是最后任务的周期(LFi)，Rci和Tci分别是通信任务τci的WCRT和周期。

在本文中，我们<span style="color:black;background:#d3f8b6 !important;">假设系统中所有任务的最坏响应时间都是已知的</span>。算法1的时间复杂度取决于因果链中任务的个数和计算两个任务周期的最大公约数的时间复杂度。用欧几里德算法计算因果链中两个任务周期的最大公约数的时间复杂度为O(LogTmax)，其中Tmax为该任务在因果链中的最大周期。因此，算法1的总时间复杂度为O(NlogTmax)，其中n是链中的任务数。对于互连的因果链，其基于算法1的方程(12)的最大数据年龄分析复杂度也是O(NlogTmax)。

# 4实验评估
在本节中，我们通过实验比较了我们的分析方法DBAge与最先进的最大数据年龄分析算法Dürr [5]和Günzel [8]的性能。我们的评估有两个主要目标：（1）比较DBAge在分析精度方面与现有算法的性能;（2）评估DBAge的分析效率。

在我们的实验中，我们基于汽车基准[11]生成了任务集，以评估不同分析方法的精度和效率。所有任务的周期都是汽车特有的半谐波，并且它们是从集合{1，2，5，10，20，50,100,200,1000}中随机抽取的，出现概率在[11]中给出。每个任务的WCET是根据其周期和UUniFast方法从[3]中生成的利用率来推导的。我们综合了1000个可调度任务集，这些任务集的利用率在0.5到0.9之间，步长为0.1。在给定合成任务集的情况下，根据文[11]中涉及的激活模式生成因果链，每个任务集生成30个因果链。对于单个ECU案例，我们创建了15万个具有2到30个任务的因果链。对于互联ECU的情况，我们首先创建一个包含20个任务的通信任务集，如[8]所述，然后通过随机选择具有相同利用率的不同任务集的5个因果链和从通信任务集中随机选择4个通信任务来生成10000个互联因果链。
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401022208935.png)
延迟减少被定义为，
![image.png](https://gcore.jsdelivr.net/gh/wsm6636/pic/202401022208374.png)
其中BDavare是Davare等人[4]获得的端到端延迟界限，BOther是通过更精确的算法得出的最大数据年龄（即，Dürr，Günzel and DBAge）.
**分析精密度**。图4显示了不同方法对Davare等人[4]方法的改进，用于单个和互连ECU场景。我们可以发现，DBAge始终优于Dürr显着无论是在单一的ECU的情况下，或在互联ECU的情况下。这是因为DBAge在最大数据年龄界限分析时，通过探索链中连续周期任务的释放间隔，降低了分析结果的悲观性。此外，我们可以发现DBAge的性能与Günzel相似，Günzel通过模拟和比较超周期内的所有直接向后作业链来提供最准确的最大数据年龄估计。
**分析效率**。图5示出了<span style="color:black;background:#FFDBBB !important;">对于因果链的不同数量的任务，每个因果链所需的平均分析时间</span>。请注意，因果链中每个任务的最坏情况响应时间分析的计算时间包括在DBAge和Dürr的分析时间中。这里，y轴使用以10为底的对数标度，以使结果更清晰。通过分别分析因果链中每个任务的计时行为，具有线性时间复杂度的算法Dürr的性能优于DBAge和Günzel，这并不令人惊讶。我们还可以看到，由于问题的解耦，DBAge获得了与Dürr相似的分析效率，特别是对于任务较多的链。这是因为，对于任务较多的链，伪多项式复杂度的最坏响应时间分析的计算时间在Dürr和DBAge的分析时间中占据主导地位。此外，我们还可以发现，DBAge的分析时间比Günzel要短得多。对于有30个任务的因果链，DBAge的平均速度几乎是Günzel的1000倍。<span style="color:black;background:#FFDBBB !important;">值得注意的是，Günzel的计算复杂性主要取决于任务集的超周期，它随最大周期和任务集中的任务数[7]呈指数增长</span>，因此它可能是难解的。实验结果表明，Günzel的分析时间不到1秒。这是因为汽车基准[11]合成的任务的周期是半调和的，并且在实验设置中任务集的超周期是1000的上界。

# 5 结论
提出了一种基于问题解耦的全局异步局部同步分布式汽车系统周期因果链的最大数据年龄分析方法DBAge。在我们的方法中，我们将因果链的最大数据年龄的限制问题分解为对链中每对相邻任务的最后到最后数据传播实例的发布间隔的限制问题。由于这样的解耦问题，我们可以有效地在多项式时间内获得相对较紧的数据年龄上界。基于汽车基准的评估表明，DBAge在单个和互连的ECU场景中都实现了高精度的分析，同时显著减少了解决时间。



***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考

***

标签 链接

Referred in [端到端](端到端.md)
