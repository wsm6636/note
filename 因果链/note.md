---
created: 2023-07-08T20:33
updated: 2024-02-13T22:40
tags:
  - 笔记
  - 笔记/idea
---

# TSN 端到端 因果链

> 最大响应时间和最大数据年龄如何影响到控制性能
>
> **最大响应时间和最大数据年龄的分析在can总线和TSN上有什么区别，can总线是确定的但为什么还需要计算**，TSN同步，GALS和CAN总线异步
>
> Controller Area Network  Time-Sensitive Networks
>
> QCh
>
> ATS
>
> 非抢占
>
> sporadic

## 响应时间和数据年龄如何影响到控制性能

与年龄和反应延迟相对应的延迟约束也是AUTOSAR事实上的标准[29]的一部分以及几个汽车领域特定的体系结构描述和建模语言[30]。

现代主动安全汽车应用的复杂性和物理分布性要求使用分布式体系结构。这些体系结构由多个电子控制单元(ECU)组成，这些ECU通过标准化的总线连接。最常见的配置功能是定期激活任务和消息，并结合运行时基于优先级的调度。要在此类架构上正确部署应用程序，需要满足端到端延迟最后期限。这是具有挑战性的，因为必须在一组ECU和总线上强制执行最后期限，每个ECU和总线都支持多种功能。适应遗留任务和消息的需要使情况进一步复杂化。

汽车应用的控制算法的响应性、性能和稳定性通常取决于所选效应链的传播延迟。

> 其他论文里没有说如何影响性能，只有引用对语义定义的论文，并且说响应时间和数据年龄对控制来说非常重要。
>
> 其他论文的实验结果，没有约束的任务响应时间会随着任务增多线性增加，或者和其他分析方法对比证明自己的更好
>

## 有必要用响应时间和数据年龄分析TSN吗——TSN和CAN总线都是确定的，为什么CAN总线可以分析响应时间、数据年龄

> 在其他论文中用CAN总线的场景：全局异步局部同步GALS，CAN总线是异步的
>
> 如果是TSN是否还能分析，因为TSN是同步的
>
> **为什么能分析TSN或者为什么不能**

为了确保达到预期的延迟边界，需要仔细选择**==周期时间==**、**网络中网桥之间的==周期时间对齐==**以及**一个周期内第一次和最后一次传输的时间**。

TSN中，FIFO（先进先出）队列在最坏情况下会产生长延迟，这会阻止控制任务实现短采样周期，从而阻碍控制性能优化

CAN不需要考虑时钟同步问题

其他人的工作：关联的任务集是预先已知的，并且==ECU之间的进一步通信任务是给定的==。

**2 )当τ 1的一个作业完成后，它将所需的值写入一个类似于一个核心中通信的缓冲区中，并且每个τ c的作业在初始化时读取当前值；**

> 通过交换机的话，还需要这样的假设吗？还有缓冲区吗
>
> TSN有缓冲区，可以假设

非抢占非周期，

没有考虑到TSN中周期性的任务

将多ECU任务链，拆分成任务因果链和通信因果链

通信因果链使用Davare的分析：**对任务链中所有任务的最坏响应时间和周期（最大到达间隔）进行求和。**

过于悲观，且没有考虑到通信延迟的具体情况。网络任务周期的偏移量，先进先出队列，走过多少跳

> 怎么分析通信/网络延迟的情况？
>

最大传输单元(**MTU**) ，表示为 M，它定义了**单次传输中允许的最大数据大小**

第一个在φ释放，后续每间隔T释放一个作业。r=φ+（m-1）T

> 直接拆成两个因果链，存在的悲观情况
>
> 没有考虑到传输，
>
> 一定概率范围内，时钟的偏移量，到达另一个终端（ECU）
>
> 任务晚到，在网络中的影响。零星任务

## **背景**

### 自动驾驶

分布式系统，自动驾驶中电子控制单元ECU。工厂自动化数字化，分布式系统变得复杂。

控制执行单元负责将来自决策控制单元的控制指令转化为具体的动作，如油门、制动和转向等信号，从而实现车辆的精确控制。在这个过程中，任何延迟都可能会对行车安全产生重大影响。

例如，在高速道路上进行自动巡航时，如果控制执行单元的延迟超过50毫秒，就可能会导致车辆失去稳定性，导致急剧减速或转向不灵敏等问题。长时间甚至可能损坏车辆或造成交通事故。

此外，由于自动驾驶汽车是由多个ECU协同工作完成各项任务的，每个ECU之间也存在着一定的延迟。因此，当控制执行单元的延迟过高时，可能会影响整个自动驾驶系统的运行效率。

因此，在设计和优化自动驾驶系统时，需要考虑控制执行单元的延迟问题，从硬件、软件和网络等多个方面进行技术优化，以最大程度地减小延迟，并确保控制执行单元能够在最短的时间内对车辆做出反应，保证车辆的行车安全和稳定。

自动巡航控制(ACC)或电子稳定程序(ESP

==进气系统(AIS)==就是一个例子，它是现代汽车发动机管理系统(EMS)的一部分。为了顺利运行，发动机内部的空气和燃料混合物必须得到控制，AIS负责注入正确的空气量。为此，最初的传感器任务定期对踏板位置进行采样，随后是处理这些信息的多个控制任务，最后是执行器任务启动油门以调节发动机内部的空气量。对于控制算法来说，重要的是检测到的输入数据是新鲜的，以便达到所需的控制质量。因此，从读取数据到启动的时间除了受任务各自的时间限制外，还受到延迟限制。

TSN中，由于802.lQbv交换机中的FIFO（先进先出）队列在最坏情况下会产生长延迟，这会阻止控制任务实现短采样周期，从而阻碍控制性能优化



今天的汽车嵌入式系统本质上是高度分布式的，它们是通过多个电子控制单元(ECU)、传感器、执行器和通信总线来实现的。物理参数由传感器节点感知，传递到处理这些参数的计算节点，最后发送到执行器节点(可能是闭环系统的一部分)。一个例子是巡航控制应用程序，它可以感知发动机速度、车速和刹车开关，通过调整油门位置(驱动)来改变条件(控制)来设置和保持车辆速度。

在现代汽车中，自动巡航控制(ACC)或电子稳定程序(ESP)等功能分布在几个ECU上，而巴士延误增加了信号延迟。尤其是**数据年龄的增加，对原有控制模型的质量有明显的影响**。对于系统设计人员来说，最重要的是及早控制这些影响，以避免陷入后期(和昂贵的)重新设计。

这种端到端定时很重要的第二个领域是人体电子学。在这里，汽车制造商非常关注“按钮对行动”的延迟，例如电子门锁。客户(购车者)通常认为任何意想不到的(或“不充分”的)延迟(或所有四个门的不同步锁定)都是部分故障，即使系统功能根本没有受到损害(因为汽车最终会被锁住)。

现代自动驾驶汽车包括越来越多的部件，这些部件必须遵守时间限制，以确保车辆及其环境的正确功能和安全。它们包括不同电子控制单元(ECU)上的智能灯、ACC和ABS等组件，这些组件通过车内网络进行交互。此外，还有许多以不同硬件和软件解决方案为特色的系统设计。随着这些系统的复杂性增加，保证时间约束变得更加困难。

在具有实时约束的工业系统中，为了确保软件操作的正确功能，需要及时性。具体地说，诸如端到端等待时间之类的定时属性用于验证必须在特定时间间隔内执行期望的控制行为的安全关键任务，例如，汽车中的电子控制单元(ECU)的交互。

### 因果链

安全相关领域的任务通过所谓的因果链(CEC)中的数据依赖相互关联，则端到端定时行为变得更相关且更难处理

特别是，如果来自上述安全相关领域的任务通过所谓的因果链(CEC)中的数据依赖相互关联，则端到端定时行为变得更相关且更难处理。相关的端到端指标是端到端系统响应时间和最长数据寿命[5]。前者表示系统对价值变化的反应[6]。相反，数据年龄描述了输入数据影响CEC输出的最长时间[7]。传感器到执行器延迟约束是这种端到端链的已知代表[7]。

因果链描述了完成特定功能所必需的一系列任务，例如，第一个任务读取传感器值，第二个任务处理传感器值，第三个任务基于传感器的读数产生输出。**必须确定从原因到结果的时间间隔，以验证程序的定时要求，即所谓的端到端定时分析。**

由于系统复杂的行为，使得任务间具有因果关联的关系，一个任务的输入取决于之前任务的输出，这中因果链形式的任务使得端到端延时更难以预测。

### TSN

近年来，作为数据链路层协议，以太网已从标准的计算机网络发展为工业自动化的应用（例如，PROFINET，ETHERNET/IP，ETHERCAT和SERCOS III [18]），航空航天（例如Afdx [3）[3]），能量和力量（例如，高于HSR/PRP的IEC 61850）以及车载通信（例如确定性实时以太网[19]）。在新兴的安全性系统（例如高度自动化的车辆）中，需要在相同的基础设施上传输大量具有混合类型的消息，这需要确定性和可预测的时机来确保安全。传统的实时网络使用非标准的以太网来实现高带宽确定性交流，这禁止不同供应商的不同协议和组件之间的连通性，并增加了时间和危害分析的不确定性和困难。因此，要求网络协议满足确定性端到端延迟和高流量负载的要求。

满足端到端的需求不仅仅是对单个设备的调度和分析，而是对整个分布式系统的检查。这还包括另外的通信系统。最近的发展需要在以太网之上采用新的通信技术，如时间敏感网络(TSN)[8]，这些技术似乎很有希望为不同的安全关键领域实现未来的通信系统，并为未来的创新建立一个共同和标准化的开发基础。尽管TSN为实现可靠的实时通信提供了有益的机制，但它仍然依赖于适当的配置和调度。时间敏感网络中的网络流调度和任务调度是一个被广泛探索的领域。

因此，IEEE 802.1Qch[6]提出了一种称为循环排队和转发(CQF)的配置模型。通过静态配置入队和出队机制，部分简化了对它们的管理。同时，交替时隙的循环转发模式保证了周期性和非周期性业务的确定性传输。然而，构建和优化流和时隙的映射以实现高效调度仍然需要对这两个模型进行进一步的研究。

### TSN 802.lQch

传输时间划分为等长，有编号的时间间隔（i，i+1，i+2），每个间隔持续时间为D

最大延迟（h+1）*d，

最小延迟（h-1）*d，h为跳数

==到达间隔x的帧将在间隔x+1中传输。类似地，到达间隔x+1的帧在间隔x+2中传输，依此类推。==

==先进先出==

**当一个帧通过网络时引入的==延迟完全由周期时间和跳数描述==，不受任何其他拓扑考虑因素的影响，包括来自其他非时间敏感流量的干扰。**

为了确保达到预期的延迟边界，需要仔细选择**==周期时间==**、**网络中网桥之间的==周期时间对齐==**以及**一个周期内第一次和最后一次传输的时间**。

==一次传输就会把队列传完==

注入时间与延迟

延迟是固定的，注入时间对传输延迟没有什么影响，主要影响能否在截止期内完成

循环排队和转发(CQF)是一种流量整形方法，可以为时间敏感型流量提供确定性且易于计算的延迟。顾名思义，CQF的基本原理是以循环方式沿网络路径传输和排队传输流流量。时间被分成编号的时间间隔i，i+1，i+2，...在时间间隔i期间，由网桥Alice发送的帧由下游网桥Bob在时间间隔i期间接收，并且在时间间隔i+1期间由Bob向网桥Charlie继续发送，依此类推。开始假设是，对于给定的业务类别，所有网桥和连接到给定网桥的所有终端站对周期i的开始时间和周期持续时间d具有共同的理解(以已知的精度)。

由Alice在间隔i期间发送的帧由Bob在间隔i+1中发送；给定帧所经历的最大可能延迟是从i的开始到i+1的结束，或两次d。类似地，所经历的最小可能延迟是从i的结束到i+1的开始，这是零。更一般地，给定帧经历的最大延迟是(h+1)d，给定帧经历的最小延迟是(h-1)d，其中h是跳数。

这说明了CQF作为一种处理时间敏感型流量的技术的吸引力；帧通过网络时引入的延迟完全由周期时间和跳数描述，不受任何其他拓扑考虑因素的影响，包括来自其他非时间敏感型流量的干扰。然而，这仅在帧被保持在其分配的周期内时才成立；例如，如果预期在周期i期间由Bob接收的一些帧直到周期i+1已经开始才出现，则所述关于最大等待时间计算的假设不再成立。为了确保达到所需的延迟界限，需要仔细选择周期时间、网络中网桥之间的周期时间对齐以及一个周期内的第一次和最后一次传输的定时。

为了简化TSN交换机的设计，IEEE 802.1 QCH[5]标准最近提出了一种简单易用的模型，称为循环排队转发(CQF)，它在TAS的门控列表(GCL)上安装了静态配置。CQF通过循环交换乒乓队列来提供可预测的确定性延迟。据我们所知，在撰写本文时，IEEE 802.1 QCH只定义了CQF的队列模型和工作流程，并且只有几篇综述介绍了相关的原理[18][19][28][27]。然而，如何将目标时间敏感流映射到基于CQF的TSN的底层硬件资源上，使CQF实用化仍然是一个悬而未决的问题，这也是本文的主要目标。

延迟保证促进了网络中的确定性行为，并根据所应用的机制，还促进了对时间敏感的网络流量的低抖动。帧抢占(IEEE 802.1 QBU[15])、循环排队和转发(IEEE 802.1 QCH[16])、异步流量整形(IEEE 802.1 QCR[17])和TAS(IEEE 802.1 Qbv[18])等机制可以帮助实现这些目标。在这项工作中，我们关注的是后者。

### TSN QBV

**TT流**，固定优先级情况下，在每个交换机内都通过相同队列传输，影响时间的因素主要是偏移量（在每个交换机的偏移量都不同），FIFO队列其他帧的影响，传输速率和帧的长度。

TT流的调度，通过各种约束，计算出偏移量和传输队列

> TT流可以看成偶发性任务吗？？
>
> 如果是偶发性任务，最大最小周期如何确定
>
> 最差执行时间WCET，取决于帧长度/传输速率
>
> 释放、传输、传播、接收



### QBU

两种模式：

1具有保持和释放机制：由抢占提供的保持和释放机制允许在ST业务的传输窗口之前实现显式“保护带”，这比其他情况下需要的要小得多。调度、保持和释放以及抢占的组合使得ST业务传输窗口完全受到保护，不受可抢占业务的干扰，同时减少受保护窗口对可用于可抢占业务的带宽量的影响。保护频段由λ指定。

2没有保留和释放机制：在这种模式下，即使在快速流量的传输门打开后，也允许可抢占的流量继续传输高达123个字节。在这种模式下，不需要保护频带，事实上，由于没有完全保护干扰，ST业务可能会被延迟。在未启用该机制的情况下的分析中，必须考虑快速业务(即ST业务)的闸门打开后传输的超限。

可抢占流量在抢占之后恢复，但带有新的报头。这意味着，例如，当帧被抢占并被分成两个片段时，第二个片段还获得报头和CRC，在这种情况下应将其计入帧开销。这会对SR类的分析产生影响，这将在后面的分析部分讨论。

### 通信语义

这些通信语义设置了有关如何以及何时跨函数通信数据的规则，以确保数据一致性和时间确定性。AUTOSAR提出的“隐式通信”的目标是数据一致性，而逻辑执行时间(LET)则通过解耦计算和通信来解决时间不确定性问题，特别是当软件部署在多个处理器上时。据我们所知，在工业级部署中，并发任务之间不受控制/不受控制或直接通信的情况非常少见，并且使用了更复杂的通信语义。

![image-20230417154841649](https://cdn.jsdelivr.net/gh/wsm6636/pic/202304171548791.png)

**隐式通信**这种语义由AUTOSAR提出，主要用于维护数据一致性，以避免显式通信的陷阱。它基本上遵循读写范例-隐式通信要求任务始终在执行开始时制作它需要的共享数据的本地副本，在本地副本上工作，并在执行结束时写回数据(参见图4)。这可确保任务在整个执行过程中在同一拷贝上工作，并保持数据的一致状态。从访问延迟的角度来看，**在任务执行期间读取的所有变量都必须从其源预取到本地内存中，然后任务可以通过引用随时可用的本地副本来执行**(参见图5)，因此不会招致多次远程访问的成本。

**逻辑执行时间(LET)**是由时间触发编程语言Giotto[11]引入的。它是一种实时编程概念，通过分离计算和通信来确保时间确定性。不受约束的通信方法(即，允许任务任意读写)的问题是由于“执行抖动”而导致的不确定性。结果高度依赖于在任务激活间隔内(例如，从其释放到其周期结束)内执行的其他任务的可能干扰。==这种抖动的影响在事件链中变得更加突出，导致端到端延迟的变化很大==。通过实施严格的通信规则，LET模型对这些抖动具有很强的抵抗力。在LET模型中，任务总是在激活间隔开始时读取数据，在激活间隔结束时写入数据(参见图6)。与隐式通信一样，let要求任务访问的每个变量都有一个本地副本。使用LET，任务的可观察时间行为独立于其物理执行。也就是说，与任务在其执行间隔内执行的确切时间无关，结果将始终仅在其激活间隔结束时可用。LET还确保了可移植性，即任务在迁移到另一个硬件(核心)时的相同行为，添加新软件时的可集成性和互操作性，这通过确定性通信进行了验证。

> LET侧重于消除抖动

LET 会导致事件链中出现更长的延迟。

使用 LET，同步刺激情况下的端到端延迟始终等于链中涉及的任务周期的总和。然而，对于异步刺激，效果链中的每个任务可能会在其激活窗口中尽可能早地执行，但数据恰好在它开始执行后到达（这意味着它正在对数据的旧值进行操作）。因此较新的数据仅在一个时间段后被消耗。

图 7 总结了不同的通信机制如何影响一个简单事件链的最终延迟，其中所有可运行对象都映射到一个任务，但存在反向通信，因为消费者位于任务中的生产者之前，如图所示7a，并且在事件链中具有不同的顺序。

![image-20230417214700848](https://cdn.jsdelivr.net/gh/wsm6636/pic/202304172147980.png)

## **实验**

> 虚拟机end2end密码rtas21

### 步骤

```shell
#先运行一次screen
sudo screen
#将/run/screen赋予777权限
sudo chmod -R 777 /run/screen
#将脚本赋予777权限
chmod -R 777 auto.sh 
#开始测试
./auto.sh 10
#运行一次num_tries=1，12分钟
```

### 代码笔记

transformer.py 生成任务集，不用动

event_simulator.py，模拟器，不用动。带有周期性作业行为、固定执行时间>0、受限期限和单个ECU情况下同步发布的事件模拟器

**数据年龄为了对比Duerr进行了削减**，反应时间没有，我们不需要

==davare相关不能动，一些参数基于这个==

==TDA是原来的单个ECU任务的response time计算==

![image-20230419161042071](https://cdn.jsdelivr.net/gh/wsm6636/pic/202304191610165.png)

对于多ECU联合的实验，只考虑了“End-to-End Timing Analysis of Sporadic Cause-Effect Chains in Distributed Systems”==Duerr==和“Timing Analysis of Asynchronized Distributed Cause-Effect Chains”==our==

> 单ECU实验可以不进行其他的

```python
improvement.append((1-(chain.Gunzel_react/chain.davare))*100)
#计算比davare减少了多少，我们可以加一个直接比较？
#有数据了，可以试试
```

- [x] **TSNtask.py对应task.py，对应TSN网络任务属性**
- [x] **Qch.py对应communication.py，生成TSN网络任务，响应时间计算**，==ddl约束==
- [x] **analyzer.py加入对带有tsn因果链的分析**
- [x] chain.py 加入对tsn任务的判定
- [x] **evaluation.py，加入tsn画图**

![image-20230420155543617](https://cdn.jsdelivr.net/gh/wsm6636/pic/202304201555704.png)

原论文中，带宽1Mbps，wcet为130*10的-3ms，0.13ms=130us

> 如果任务优先级最低，生成20个任务，那rt=20*130=2600us = 

> 怎么设置tsntask的属性区间，TSN流控头的长度4字节，数据长度8字节，TSN协议头长度18字节
>
> slot长度，论文里的最坏情况rt / 7跳。20*130/7 = 371us = 0.37ms
>
> ​	**d=125us=0.125ms，协议里的例子是125，**
>
> **hops跳数，n，1≤n≤6**，协议不超过7跳，802.1AS2011
>
> offset偏移量，o=n*slot
>
> 延迟需要加上offset吗？

### <strong style="color:#ff0000;"> <strong style="color:#ffc000;">QCH约束</strong></strong>

slot长度=，QueueSize是每个队列可以容纳的最大数据包量，MTU是最大数据包长度。B是链路带宽，HopDelay是交换机的内部处理延迟和传播延迟，syncprec是时钟同步精度。

![image-20230420104439059](https://cdn.jsdelivr.net/gh/wsm6636/pic/202304201044172.png)

==deadline约束，==（偏移量+跳数）*slot长度 ≤ deadline

🔤4)最后期限约束：在ITP中，延迟流量的注入时隙会影响到达目的地的时间。此约束对于限制每个流的所有数据包在指定的截止日期之前到达非常重要。🔤



![image-20230420104817112](https://cdn.jsdelivr.net/gh/wsm6636/pic/202304201048194.png)

==偏移量约束，==

偏移量约束要求注射时隙的偏移量小于流动周期。例如，流的第一个周期中的分组在第二个周期中生成的分组之前被转发。造成这种限制的原因有两个。首先，如果不满足这一约束，多个周期的报文将同时占用主机中有限的网卡(NIC)存储资源。其次，该约束将偏移量限制在合理的范围内，从而减小了每流偏移量的搜索空间。

![image-20230421194944045](https://cdn.jsdelivr.net/gh/wsm6636/pic/202304211949206.png)

> 考虑ddl，偏移量
>
> 不考虑队列资源，接收窗口

### <strong style="color:#c00000;">待解决问题</strong>

- [ ] 画图，如果最小值是负数怎么改
- [x] 跳数1到6行不行，可以
- [ ] 需不需要改slot长度，考虑avb流等其他TSN论文提到的，百兆带宽，目的是为了解决TSN端到端延迟分析，然后才是和他们比较
- [ ] 怎么描述实验设置合理，实时任务wcet是ms级，通信任务us级，差距大
- [x] Gunzel中对于通信任务的选取，每次都是按照优先级从0到3，所以通信任务的响应时间很小而且固定，改成随机的了
- [ ] 和gunzel差距太小

