---
created: 2023-07-21T12:27
updated: 2024-02-13T22:40
tags:
  - 笔记
  - 笔记/文献笔记
---

# Timing Analysis of Asynchronized Distributed Cause-Effect Chains

| Title                 | Timing Analysis of Asynchronized Distributed Cause-Effect Chains                             |
| --------------------- | -------------------------------------------------------------------------------------------- |
| Journal or Conference | 2021 IEEE 27th Real-Time and Embedded Technology and Applications Symposium (RTAS)           |
| Authors               | Mario Gunzel; Kuan-Hsun Chen; Niklas Ueter; Georg Von Der Bruggen; Marco Durr; Jian-Jia Chen |
| Pub. date             | 5/2021                                                                                       |
| DOI                   | [10/gsfbtz](https://doi.org/10/gsfbtz)                                                       |
| Level                 |                                                                                              |

# **7、Timing Analysis of Asynchronized Distributed Cause-Effect Chains——异步化分布式因果链的时序分析**

**2021RTAS**

**CCF B**



## 摘要

实时系统需要对时间约束的形式保证，不仅对于单个任务，对于数据传播路径也是如此。因果链描述了多个任务之间的数据流，例如，从传感器到执行器，与任务的优先顺序无关**。在考虑最大反应时间(数据处理持续时间)和最大数据年龄(最坏情况数据新鲜度)的情况下，对具有周期性任务激活的异步化分布式系统的因果链进行了端到端的时序分析**。在一个局部电子控制单元(ECU)上，我们给出了当周期性任务的执行时间固定时，如何计算精确的局部(最坏情况)端到端延迟。通过结合局部结果，我们进一步将我们的分析扩展到全局异步系统。通过基于汽车基准和随机参数的合成数据，我们表明我们的分析结果改进了周期性任务激活的最新技术。

## 引言

在具有实时约束的工业系统中，为了确保软件操作的正确功能，需要及时性。具体地说，诸如端到端等待时间之类的定时属性用于验证必须在特定时间间隔内执行期望的控制行为的安全关键任务，例如，汽车中的电子控制单元(ECU)的交互。

因果链描述了完成特定功能所必需的一系列任务，例如，第一个任务读取传感器值，第二个任务处理传感器值，第三个任务基于传感器的读数产生输出。**必须确定从原因到结果的时间间隔，以验证程序的定时要求，即所谓的端到端定时分析。**

文献中验证因果链的定时要求的大多数方法可以分为两类：主动方法[8]、[15]、[22]，其控制链中后续任务中的作业的释放以确保正确地写入和读取数据；以及被动方法[2]、[3]、[5]、[9]、[10]、[12]、[14]、[17]、[21]、[23]，讨论如何在因果链中的经常性任务的工作中适当地产生和使用数据。这项工作中提出的方法可以分为被动方法。

在分析因果链时，文献中主要考虑了两种类型的端到端延迟：最大反应时间表示从外部原因发生到该外部原因被完全处理的最早时间间隔的长度，即按钮到行动的最大延迟。最大数据年龄表示从采样值开始到最后一个时间点的最长时间间隔的长度，在该时间点上，激励基于该采样值。我们注意到，最大反应时间包括采样和前一次采样之间的时间，因为外部原因可能发生在前一次采样之后。调度的最大反应时间(分别为数据年龄)可以通过计算前向(后向)作业链的最大长度来确定，如==[10]==

[10](Fixed-Priority Scheduling and Controller Co-Design for Time-Sensitive Networks)中所定义。然而，最大反应时间和最大数据年龄的定义仅限于特定的零星任务模型，其中每个任务具有最小和最大到达间隔时间。==在这项工作中，我们提供了一个定义，而不将其限制在任何特定的任务模型上。==此外，在文献[9]、[10]、[17]中，存在一个(隐含的)假设，即只有当所有任务都已经在系统中时，即当所有任务都发布了它们的第一个作业时，才测量最大反应时间和数据年龄。==我们改进了这一假设，从而实现了一个成分属性：我们可以将E分解成更小的片段，并分别对每个片段进行分析，而不是计算因果关系链E的最大反应时间(数据年龄)。==

> 在哪里体现，分段

我们针对单个ECU进行了精确的端到端分析，其中==预定义的周期性任务在固定优先级的抢占策略下进行调度==。随后，我们利用组成性质将分析扩展到互连的ECU场景，其中多个单个ECU通过内部通信基础设施连接，例如控制器区域网络==(CAN)==[7]或FlexRay[13]。对于互连的场景，**我们假设分区调度，即每个ECU都有单独的周期性任务集。虽然单个ECU上的任务是使用一个同步时钟来调度的，但不同ECU之间的时钟通常不同步。**本文研究了这类全局异步局部同步(GALS)系统。我们注意到，尽管ECU的概念是从汽车系统中采纳的，但我们的工作可以抽象为类似的设置。

为了分析GALS系统的最大反应时间和最大数据年龄，文献中提供了以下结果：

·Davare等人给出了0GALS系统上周期性任务集的因果链的最大反应时间的上界。[^9]。

·两个上限，一个是最大反应时间，另一个是Dürr等人提出的GALS系统上零星任务集因果链的最大数据年龄。[^10]。

·由Kloda等人提供的全局同步系统上周期性任务集的因果链的最大反应时间的上限。[^17]。

> 组会那个论文的最大数据年龄分析

自从Dürr等人。[10]表明最大数据年龄小于或等于最大反应时间，这是Davare等人提供的上限。[9]和Kloda等人。[17]还可保留最长数据使用期限。然而，Kloda等人的分析。[17]仅针对同步任务释放而制定，即每个任务的第一个作业在时间0被释放，并且假设每个任务的最坏情况响应时间预先已知。此外，Schlatow等人的论文。[23]重点分析了调和任务系统的最大数据年龄。对非简谐情况的分析实际上比Davare的分析更悲观，即方程。(36)在[23]中加上链中任务的最坏情况响应时间由在[9]中的分析决定。

值得注意的是，Dürr等人。[10]结果表明，他们在零星任务模型下提出的端到端时序分析支配了Davare等人提出的上界。[9]解析地，它被用于几个已知的分析[2]-[4]。在这项工作中，我们利用他们的分析上界作为骨干，并在**定期任务的实际用例执行时间固定时对其进行改进**。

### **贡献：**

我们研究了全局异步化局部同步(GALS)分布式系统上的异步周期性任务集的最大反应时间和最大因果链的数据年龄。我们的贡献是：

·在第四节中，我们提供了最大反应时间和最大数据年龄的精确定义。底层模型仅假设具有某些读写操作的重复释放的作业。因此，该定义对于所有公知的任务模型(例如周期性或零星任务)和通信模型(例如隐式通信或逻辑执行时间(LET))是有效的。它涵盖了单个ECU以及互连的ECU场景。

·在第五-B节中，我们提供了一种方法，如果**每个作业的执行时间是固定**的，那么在具有**抢占式固定优先级调度的周期性任务集**的单个ECU场景中，确定准确的最大反应时间和最大数据年龄。特别地，我们证明了在这种情况下，**==仅评估在有限时间窗口内释放的作业链==**就足够了。

·在第五-C节中，我们将精确的局部分析扩展到互连的ECU场景，并提出了一种方法来限制全局异步分布式系统中ECU之间的通信时间。

我们评估了我们在第七节中对单个和相互关联的ECU案例的建议分析，将其与文献中的结果进行了比较，表明我们的方法在最大反应时间和最大数据年龄方面都优于最先进的分析。

## 系统模型

### 任务和作业

对于最大反应时间和最大数据寿命的一般定义，我们依赖于一个非常基本的作业和任务模型。如果电子控制单元(ECU)不同步，即它们的**时钟不一致，则我们会考虑它们的时钟偏移**，以在全球级别上比较ECU上的事件时间。首先，我们介绍作业、时间表和任务。我们假设在一个ECU上不存在作业的并行执行，即**一个ECU等价于经典的单处理器系统。**

> TSN时钟同步，不需要考虑时钟偏移

作业J是程序的一个实例，它根据其输入产生输出。它在时间Rj被释放，并且必须执行一定的时间Cj≥0才能完成。

调度S指定ECU上作业的执行行为。如果J由S调度，则J的开始时间(或开始)表示为SJS，而J的结束时间(或结束)为f S J。出于可读性的原因，如果在上下文中清楚地选择了调度，则对于所有定义，我们省略了索引S。

作为同一程序的实例的所有作业的集合称为任务，由τ表示。我们假设每个任务被分配给一个ECU，即一个任务的所有作业都在同一个ECU上调度，并且聚集到一个任务τ的作业是可数的。在本文中，我们将所有任务的集合表示为T，将任务的作业表示为(∈(M))m∈N，其中0τN。此外，我们假设任务集T是有限的。

虽然第四节的一般定义适用于所有类型的任务模式，例如定期或零星任务，但第五节的分析仅限于定期任务。周期性任务由τ=(C，T，φ)描述，其中C≥τ0是任务的最坏情况执行时间，即，没有抢占或中断的任务的最长运行时间，Tτ>0是该任务的周期，而τ，φ≥0是该任务的阶段。

第一个作业在φ释放，后续每间隔T释放一个作业。r=φ+（m-1）T

任务利用率 U=C/T，单个ECU上利用率最多为1

超周期H=lcm{ T | τ }

> lcm：最小公倍数

### 通信模型

我们用reJS表示调度S中作业J的第一个读事件，用weJS表示S中J的最后一个写事件。我们考虑两种常见的通信策略。一种称为隐式通信，其中读和写事件与作业的开始和结束对齐，即reJS=sjs和wejs=fSJ，如图1所示。另一种是基于逻辑执行时间的概念[16]。为了利用LET，每个任务τ都配备了一个相对截止日期Dτ。由任务τ发布的每个作业J具有绝对期限DJ=RJ+Dτ，并且J的读和写事件被设置为其发布时间和期限，即REJS=RJ和WEJS=DJ。虽然LET最初仅限于单一ECU，但Ernst el al。[11]概括介绍互连的ECU设置。如果我们在下文中使用let，我们只考虑可行的调度，其中每个作业在其截止日期之前完成，即，对于S中的所有作业J，f S J≤DJ。我们假设满足以下(不是很严格的)要求：

·读事件和写事件的顺序是：Re(m)<Re(m+1)，we(m)<we(m+1)，re(m)≤we(m)

·集合{re∈(M)|m∈N}和{we(M)|m∈N}没有累积点，即在每个有界时间间隔中只有有限多个读和写事件。

我们注意到，如果我们考虑具有周期性或零星任务以及LET或隐式工作交流的标准任务模型，则满足上述性质。

**标准应用程序由多个ECU组成。我们通过额外的通信任务 τ c 对不同 ECU 之间的通信基础设施进行建模。**这些是第II-A节意义上的常见任务，其中每个作业都有在ECU之间传输数据的目的。==更具体地说，由通信任务释放的作业从一个ECU的共享资源读取数据，并向另一个ECU的共享资源写入数据。大多数通信任务都被建模为在额外的通信ECU上执行，因此它们不会影响其余ECU上的作业执行。==

### 因果链

为了达到一定的目的，数据必须由不同的程序依次处理。因果链E=(→1→∈··ττk)描述了通过IτT的有限任务序列通过不同程序的数据路径。例如，如果τ1使用τ3提供的数据，则E=(τ3→τ1)。==我们注意到，如果系统中的任务是优先的，例如为了使用某种调度算法，则因果链不一定遵循这个顺序==。我们用|E|表示E中的任务数，其中|E|≥1。对于m∈{1，...，|E|}，**函数E()返回因果链E的第m个任务**。例如，设E=(τ4→τ5→τ1)，则|E|=3，E(1)=τ4，E(2)=τ5，E(3)=τ1。我们注意到，因果链的灵感来自AUTOSAR定时扩展的事件链[1]，它代表更一般的函数依赖性链。

要获取因果链中第一个任务的数据，可能需要对数据进行采样。在这项工作中，我们假设一个**隐式采样率**，其中对因果链E的采样**发生在E(1)的每个作业的读取事件**。请注意，τsample作业的读取和写入事件需要满足上一小节中的属性，并且附加任务不应影响时间表S，例如，通过将其分配给附加ECU或将WCET值设置为0

我们考虑两种类型的因果链。本地因果链仅包含单个ECU上的任务(具有同步时钟)。相互关联的因果链的任务分布在多个ECU中。这些ECU可以是同步的，也可以是异步的，即它们具有同步或异步的时钟。我们注意到，第四节中的定义适用于所有类型的因果链。这种区别只对第五节中的分析是必要的。

### 作业链

作业链的概念对于确定最大反应时间和最大数据年龄至关重要。我们将[10]中的定义改写为具有读写事件的模型。设E和S是因果链和T的进度表。

**定义1(作业链)**。对于S，E的作业链是T中具有以下属性的任务的数据相关作业的序列JCES=(J1，...，J|E|)：对于所有i∈{1，...，|E|}，条目Ji是E(I)的作业。在表S中，数据由Ji写入后由Ji+1读取，即对于所有i≤{1，...，|E|∈1}，WeJi≤reji+1。

**定义2(直接前向职务链)**。直接向前作业链是作业链JCES=(J1，...，J|E|)，其中对于所有I∈{1，2，...，|E|−1}，**作业Ji+1的读事件是作业Ji的写事件之后最早**的，即，Ji+1=ArgminJ∈E(i+1)，Rej≥weJi Rej。

**定义3(直接向后职务链)**。紧靠后向作业链是作业链JceS=(J1，...，J|E|)，其中对于所有i∈{|E|，|E|−1，...，2}**作业Ji−1的写事件是作业Ji的读事件之前的最后一个**，即，Ji−1=ArgMaxJ∈E(i−1)，WEJ≤Reji wej。

如果我们考虑图1中具有E=(τ1→τ2)的调度，则(τ1(1)，τ2(1))和(τ1(2)，τ2(2))，(τ1(3)，τ2(2))是直接向前作业链，而(τ1(1)，τ2(1))和(τ1(3)，τ2(2))是直接向后作业链。

## 问题定义

本文分析了全局异步化局部同步(GALS)系统上分布式因果链E的最大反应时间和最大数据年龄。我们假设对于每个电子控制单元(ECU)来说，关联的任务集是预先已知的，并且==ECU之间的进一步通信任务是给定的==。

输入：一些(相互关联的)因果链E·

输出：通过在每个**(非通信)**ECU上引入固定执行时间而获得的E的最大反应时间和最大数据寿命的上限。

## 最大反应时间和数据使用期限

本文提出了一种基于因果链的端到端时序分析，即确定原因(外部活动或采样传感器值)发生到可识别结果(完成对执行器的数据或运动的处理)之间的时间间隔。端到端计时对于保证安全关键任务在给定时间范围内的正确功能非常重要。对于控制工程，最大反应时间(处理外部原因需要多长时间？)以及最长数据使用年限(致动中使用的数据使用时间有多长？)因果链的影响是特别值得关注的。

### A.扩充后的作业链

假设E和S是因果链和任务集T的时间表。按照E的依赖关系通过时间表S的数据移动可以通过从外部活动到驱动的事件序列来捕获，如图2中总结的：数据的(变化)是由一些外部活动引起的，并通过采样输入到系统中。根据我们在第II-C节中的假设，==采样与第一个任务E(1)的作业的读取事件重合。在事件序列中的第一个作业完成执行后，它将数据写入共享资源。然后，第二个作业从该共享资源读取数据，对其进行处理，并将其再次写入共享资源以用于下一个任务。当序列中的最后一个作业写入共享资源时，数据完全由系统处理。在此之后，可以基于该数据进行激励==

![image-20230330195742153](https://cdn.jsdelivr.net/gh/wsm6636/pic/202303301957329.png)

最大数据年龄和反应时间在[10]中通过使用向后和向前作业链定义。事实上，**作业链仅描述从采样到数据处理的数据流。在本文中，我们通过为外部活动和驱动添加事件来涵盖整个数据流**。我们称这种延长的作业链为扩充的作业链。

**定义4(扩充的作业链)**。S的E的增广作业链是序列CeS=(z，J1，…，J|E|，z‘)，其中(J1，…，J|E|)是作业链，并且z≤reJ1和z’≥wej|E|是外部活动和激励的时刻。

我们用CeS(K)表示扩充作业链CeS的第k个条目。CeS(1)=z，CeS(|E|+2)=z‘ 和CeS(K)=jk−1 for 2≤k≤|E|+1。为了**描述一个数据流从外部活动到启动的时间**，我们定义了扩充作业链Ce，S的长度(ce，S)为

![image-20230330200623845](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402782.png)

在下文中，如果在上下文中清楚，我们将省略作业链的指数S和E。

最大反应时间衡量从外部活动到数据完全由系统处理的时刻的时间。我们省略了处理事件和驱动之间的时间，只考虑了其中驱动是处理事件的时间的扩充作业链，即z‘=weJ|E|。如果外部活动直接发生在上一个采样事件之后，则发生从外部活动到采样的最长时间。因此，我们构造了立即转发扩充作业链，以测量最大反应时间，其方法如下：

**定义5(立即转发扩充的作业链)**。直接前向扩充作业链CeSm是唯一的扩充作业链(z，J1，...，J|E|，z‘)，使得：

·外部活动直接发生在第m次采样之后，即**z=ReE(1)(m)**。

·采样发生在E(1)的下一个读取事件，即**J1=E(1)(m+1)**。

·序列(J1，...，JE)是S中E的直接正向作业链。

·将激励设置为处理数据的时间，即**z‘=weJ|E|**。

对于每m个∈N，都有一个立即向前扩展的作业链。与下一小节中的比较直接得出反应时间的定义。

另一方面，==最大数据年龄测量从数据采样到基于该采样的激励的时间。在最坏的情况下，基于在特定时间处理的数据的激励直接发生在下一个处理的事件之前。==

**定义6(立即向后扩充的作业链)**。直接向后扩充作业链CeSm是唯一的扩充作业链(z，J1，…，J|E|，z‘)，使得：

·激励直接发生在第m个已处理事件之前，即**z‘=weE(|E|)(m)**。

·已处理事件发生在E(|E|)的上一个写事件，即J|E|=E(|E|)(m−1)。

·序列(J1，...，JE)是S中E的直接向后作业链

·外部活动设置为数据采样的时间，即**z=reJ1**。

请注意，并不是所有的m∈N都有立即向后扩充的作业链。我们称这种链为不完全向后扩充的作业链。未完成扩充的作业链的长度设置为0。

![image-20230330201839435](https://cdn.jsdelivr.net/gh/wsm6636/pic/202303302018558.png)

例7(向后扩充的作业链确定)。图3显示了具有两个周期任务τ1=(Cτ1=1，Tτ1=5，φτ1=1)和τ2=(Cτ2=1，Tτ2=3，φτ2=0)的单个ECU调度。我们假设隐式作业通信，即在每个作业开始时读取数据，并在每个作业完成时写入数据。因果链E=(τ1→τ2)的c5的直接后向扩展作业链的确定从时间13的因果链中最后一个任务的第5个读取事件开始。包括在c5中的后向作业链是(J1，2，J2，4)，并且将采样设置为6，这是J1，2的读取事件。这导致c5=(6，J12，J24，13)。

如果我们考虑c1或c2，就会出现一种特殊情况。由于在weJ2，1=1之前没有τ2的作业的写事件，所以立即向后扩充的作业链c1是不完整的。此外，c2也是不完整的，因为没有具有第二条目j2，1的立即向后作业链。

我们注意到，立即向前扩展的作业链和立即向后扩展的作业链已经由其对应的作业链唯一地确定。为了表示简单，包括了用于外部活动和驱动的辅助条目。

### B.最大反应时间和数据期限的定义

设E和S为因果链和具有任务集T的时间表。关于图2，

·反应时间测量从外部活动到数据被处理的时间，并且

·数据年龄基于该数据测量从数据采样到启动的时间。

我们注意到，我们的定义可能不同于文献中的其他定义，例如，在[10]中，数据年龄仅涵盖数据被处理之前的时间。我们对最长数据使用年限的定义对于获得第IV-C节中的组成属性是必要的，也就是说，==因果链E的最大数据年龄是E的各部分的最大数据年龄之和==。然而，我们在第六节讨论如何将我们的分析应用于[10]中提供的定义。

与[10]类似，我们可以通过取所有直接向前(向后)扩充的作业链的长度的上界来定义最大反应时间(数据年龄)。然而，由于例如由相移引起的第一读事件的移位，反应时间可能变得任意大：

例8.考虑具有因果链E=(τ1→τ2)且Reτ1(1)=0，Re 2(1)=x的任务集T={τ1，τ2}。立即向前作业链CeS1具有至少x的长度。

避免这种违反直觉的行为的解决方案是仅考虑**当所有相关任务都在系统中时开始的立即向前(向后)扩充的作业链**Ce、S，即，

![image-20230330202458348](https://cdn.jsdelivr.net/gh/wsm6636/pic/202303302024443.png)

此属性类似于[10]中的(隐含)假设，==即仅当所有任务都已在系统中时才测量最大反应时间和数据年龄==。然而，以这种方式，<span style="background:#FFDBB1;">仅一个读取事件的轻微变化可能会将许多扩展的作业链排除在考虑范围之外</span>：

例9.对于图4中的调度，如果作业遵循隐式通信，则τ2的第一个作业的读取事件略有移位。采用等式中的方法。(2)对于因果链E(τ1→τ2)，将只考虑具有c(1)≥12的扩充的作业链c，尽管包括c1(前)、c2（后）、c3（后）、c4（后）和c5（后）是合理的。

![image-20230330202809978](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402905.png)

为了解决这个问题，我们只考虑扩展的作业链CeS，如果所有任务都有它们的第一个读事件，直到CeS(1)之后的下一个读事件E(1)。我们将这种扩充的作业链定义为有效的：

定义10(有效)。设CeS=(z，J1，…，J|E|，z‘)是进度表S中因果链E的某个直接向前或立即向后扩充的作业链。设p∈N，使得z=reE(1)(P)成立。我们称CeS有效当且仅当ReE(1)(p+1)>Re(E，S)。

定义11(最大反应时间和数据年龄)。对于具有时间表S的因果链E，我们定义了时间表特定的最大反应时间和最大数据年龄。其中，事件链的长度定义为等式。(1)

![image-20230330203541048](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402117.png)

请注意，此定义适用于所有不同类型的任务集和通信策略，**因为关键部分由确定读事件和写事件来承担**。

> 不考虑网络传输

我们还给出了不受特定时间表限制的最大反应时间和数据年龄的定义。如果指定了从任务集中提取作业发布和执行时间的过程，例如，任务集是周期性的或零星的，并且如果预先知道调度算法，则这表征了所有可能的调度。此外，如果读和写事件由调度唯一地确定，例如通过遵循隐式通信或LET，则我们定义总体最大反应时间和最大数据寿命，由**所有可能的时间表S的最高优势**。

![image-20230330203846882](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402699.png)

在他们的定理6.2中，Dürr等人。[10]证明他们的系统模型的数据年龄受反应时间的限制。我们注意到，即使对于这个广义定义，

![image-20230330203953537](https://cdn.jsdelivr.net/gh/wsm6636/pic/202303302039605.png)

保持：设CeSm（后），m∈N是有效的立即向后扩充的作业链。此外，设p∈N使得CeSm(1)（后）与任务E(1)的第p个作业的读事件重合，即CeSm(1)（后）=reE(1)(P)。类似于[10]中定理6.2的证明，我们证明了

### C.增加的作业链的削减

将局部分析应用于第五-C节中相互关联的案例的一个基本要素是将因果链分割成较小的(局部)部分。我们对最大反应时间和数据年龄的定义使我们能够通过确定较小片段上的最大反应时间和数据年龄来推断上限。我们在这一节中证明，即使不限制任何任务或通信模型，也不引入固定的执行时间，这种组合性质仍然成立。

定理12(切割)。设E=(τ1→τ|E|)为任意因果链，k为整数{1，…，|E|−1}。对于因果链，E1：=(τ1→→τk)和E2：=(τk+1→→τ|E|)成立

![image-20230330205514262](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402832.png)

切割定理的证明依赖于将立即向前(向后)扩充作业链切割成更小的立即向前(向后)扩充作业链，使得它们的总长至少等于初始立即向前(向后)扩充作业链的长度。在图5中，给出了立即向后扩充的作业链的过程，假设作业遵循隐式通信。我们看到L(CeSm)≤L(CE1，S_q+1)+L(CE2，Sm)。标有模式的Ce，Sm序列中的作业分布在CE1，Sq+1和CE2，Sm之间。只有外部事件和驱动的事件必须正确确定。

定理12的证明(切割)：我们首先证明等式。(10)。根据定义，DataAge(E，S)是所有有效的立即向后扩充的作业链的长度的上界。设Ce，Sm(后)=(reJ1，J1，…，J|E|，z‘)。设Q∈N使得jk是任务E(K)的第q个写事件，即E(K)(Q)=jk。场景如图5所示。根据立即向后扩充作业链的定义，E(K)(q+1)的写事件发生在jk+1的读事件之后，即̃z‘：=weE(K)(q+1)>re jk+1。此外，(reJ1，j1，…，jk，̃z‘)=ce1Sq+1和(rejk+1，jk+1，...，J|E|，z’)=ce2，Sm是直接向后扩充的作业链。它们都是有效的，因为reJk+1≥rej1和由于Ce，Sm是有效的。我们获得了应用上确界可得到公式的结果。(10)。

![image-20230330214357281](https://cdn.jsdelivr.net/gh/wsm6636/pic/202303302143366.png)

![](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402497.png)

类似地，我们证明了(9)。根据定义，反应(E，S)是所有有效的立即转发扩充作业链的长度的上确界。设CeSm=(z，J1，…，J|E|，weJ|E|)，其中m∈N是有效的立即前向扩充作业链。

## 端到端延迟分析

在本节中，我们假设每个ECU上的任务按照**==抢占式==固定优先级调**度，即它们具有固定的优先级顺序，并且每次执行具有最高优先级的任务的未决作业。我们的目标是确定这类系统的最大反应时间和最大数据年龄。

> qbv流不能抢占吗

考虑如上所述的任务系统T的调度S和T的因果链E。如果S中的读和写事件的模式在一定时间后重复，则仅分析有限的时间窗口就足以计算最大反应时间和最大数据寿命。根据通信策略的不同，有不同的方式来实现读写事件的循环模式。

对于LET，在最大第一次读取(处于最大阶段φ：=最大τφτ)之后，读和写事件重复每个超周期。此外，所有在φ或之后具有外部活动的立即向前和立即向后扩充的作业链都是有效的。在这种情况下，只要找到在\[0，φ+H)期间具有外部活动事件的所有立即向后和立即向前扩展的作业链，并计算所有这些有效的扩展作业链的长度中的最大值就足够了。Kordon和Tang[18]提出了一种在单个ECU系统上高效地计算LET的最大数据年龄的方法，该方法以该过程为骨干。

如果我们==假设隐式通信==，则读事件和写事件在很大程度上取决于所分析的作业的执行时间。此外，当释放其他任务时，读事件和写事件可能会更改。在这种情况下，我们**将每个作业的执行时间固定为最坏情况下的执行时间**，以获得循环调度。这可以通过旋转早期完成的作业直到达到其最坏情况的执行时间来实现。本节的其余部分说明，这些属性足以使最大反应时间和最大数据寿命可计算。尽管乍一看，固定每个作业的执行时间似乎不是一个好主意，但这实际上改善了V-A部分中概述的分析。通过与这里提供的类似论证，可以处理仅基于作业的开始和结束的任何通信策略。请注意，必须存在较小的超周期，才能在可接受的时间内计算数据年龄和反应时间。在下文中，我们进一步研究如何计算固定执行时间的隐式通信的最大反应时间和数据年龄。

### **固定执行时间的动机**

乍一看，将作业的执行固定在最坏的情况下似乎不是一个好主意，因为我们的直觉表明，这还会增加这些任务的因果链的端到端延迟。然而，情况并不总是如此。事实上，有充分的理由禁止作业提前完成，如下所述，并且任务集的可调度性不受影响。因此，引发固定执行时间应被视为一种系统设计决策。



![image-20230306192955845](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402767.png)

对于因果链（τ1-τ3）

左侧：任务运行时间为，最差执行时间作业链的长度从4-12（需要任务2执行完，任务3开始。所以从任务1第三个作业开始，数据被任务2使用并传递到任务3）

右侧：如果任务2不是最差执行时间，提前结束，那么作业链长度是从0-12（因为任务2在1时刻已经能够获取到任务1的数据，所以从任务1的第一个作业开始）

> Hyperperiod（超周期）是指在周期性任务调度中，**所有周期长度的最小公倍数**。在实时系统中，周期性任务需要按照一定的周期性执行，并且需要满足严格的时间限制。Hyperperiod（超周期）是周期性任务调度中一个重要的概念，可以用来评估和优化实时系统的性能。
>
> 在一个实时系统中，有多个周期性任务需要按照一定的周期性执行。这些任务的周期长度可能不同，Hyperperiod（超周期）是指这些任务周期长度的最小公倍数。Hyperperiod（超周期）可以用来确定任务调度的周期，以便确保所有任务都能按照要求在规定的时间内完成执行，避免任务之间的冲突和延迟。
>
> 超周期的长度是实时系统性能评估的一个关键指标。**如果Hyperperiod（超周期）很长，则可能导致任务之间的执行时间间隔较大，影响实时性能。反之，如果Hyperperiod（超周期）太短，则可能会增加任务调度的复杂度，导致系统性能下降。**因此，在实际应用中，需要根据具体系统的要求和性能需求来选择合适的超周期长度。

然而，由于在==分布式实时系统中经常避免全局时钟同步以减少故障相关性==，不同ECU之间的时钟偏移对于观察者来说是未知的。此外，通信任务的实现根据底层体系结构的不同而不同，即，这些任务可以以非抢占式甚至非周期性的方式运行。这阻碍了数据年龄和反应时间的准确确定。

### B.本地分析

在本节中，我们假设正在分析的因果链E是局部的，即它只包含一个(同步的)ECU上的任务。在没有提前完成的假设下，任何周期性任务集都有一个唯一的时间表。我们表明，该时间表在一定时间后重复。因此，在隐式通信下，读写事件也会重复。以下考虑是基于梁和怀特黑德的工作[20]。他们的证明不能直接使用，因为他们创建了一个新的时间表(他们称之为部分时间表)，并表明这个时间表是重复的。我们需要证明，即使是最初的时间表也是重复的。

设S是任务集T={τ1，...，τn}在一个ECU上的固定优先级调度，其中所有作业的执行都固定为最坏情况。在不损失一般性的情况下，我们假设任务的索引是根据它们的优先级来分配的，即，当且仅当i<j时，∈i具有比τj更高的优先级。此外，设τ：=ΦτmaxφτTτ是T中任务的最大阶段。对于时刻t，我们用S(T)表示元组(s1，t，...，sn，t)，其中每个si，t是自上次释放以来τi的作业被执行的时间量。类似于[20，引理3.3]的证明，我们证明如下。

引理13.设**Φ是任务集T的最大阶段**，**H=lCm(Tτ1，…，Tτn)是超周期**。则对于所有t≥Φ，关系S(T)≥S(t+H)(组件方式)成立。

假设至少有一个任务具有公式中的属性。(11)。假设只有有限多个任务具有此属性，并假定τj是其中具有最高优先级的任务之一。由于sj，tj<sj，tj+H，存在一些t‘∈[φτj，tj]，其中τj不在时间t’而在t‘+H执行。因此，存在在t’期间但不在t‘+H期间执行的较高优先级任务τj’，即，sj‘，t’<sj‘，t’+H=Cτj‘。因为在t‘期间执行j’，我们知道≤t‘是τj’φτt‘。这与τj是具有来自公式的属性的最高优先级任务的假设相矛盾。(11)。

此外，类似于[20，引理3.4]，我们利用前面的引理证明了时间表在Φ+2H之后重复，即区间\[Φ+H，Φ+2H)中的时间表与\[Φ+2H，Φ+3H)，\[Φ+3H，Φ+4H)中的时间表重合，依此类推。我们仅利用总利用率UT=∑∈τT CτTτ。

引理14.当UT≤为1时，则S(T)=S(t+H)对所有t≥Φ+H成立。

==基于引理14，在时间Ce，Sp(1)≥≥+2H(Ce，Sm(1)ΦΦ+2H)，任何具有外部活动事件的前向(后向)增广作业链Ce，Sp(Ce，Sm)的长度与其外部活动事件提前一个超周期发生的前向(后向)增广作业链的长度一致.==

我们得出结论，在不存在提前完工的假设下，通过模拟调度可以准确地计算出反应时间和数据年龄。

算法(计算反应时间)：

·模拟外部活动事件发生在Φ+2H之前的所有立即转发作业链。

·用(12)中的公式计算反应时间。

算法(计算数据年龄)：

·模拟外部活动事件发生在Φ+2H之前的所有直接反向作业链。

·使用(13)中的公式计算数据年龄。

复杂性：在我们的分析中，有两个组件在时间复杂性中起着决定性的作用。首先，我们必须(A)为有限的时间框架创建时间表，然后(B)基于时间表创建和比较作业链。我们考察了任务集T={τ1，...，τn}且有n个任务的ECU上因果链E的时间复杂性。

![image-20230330215304197](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402785.png)

### <span style="background:#FF9999;">**C.互联分析⭐️⭐️⭐️⭐️⭐️**</span>

在本小节中，我们将分析分布在多个ECU之间的因果链的计时行为。<span style="background:#FFDBBB;">如果**时钟移位是已知的**，**并且所有任务(甚至通信任务)的行为类似于周期性任务**，</span>则可以利用上一小节中的分析。更具体地说，我们可以使用<span style="background:#FF9999;">LET或强制所有任务的固定执行时间</span>，以将最大反应时间和数据年龄的计算减少为有限多个扩充的作业链的计算。

然而，由于在分布式实时系统中经常避免全局时钟同步以减少故障相关性，不同ECU之间的时钟偏移对于观察者来说是未知的。此外==，通信任务的实现根据底层体系结构的不同而不同，即，这些任务可以以非抢占式甚至非周期性的方式运行。这阻碍了数据年龄和反应时间的准确确定。==

我们讨论了如何为相互关联的因果链的数据年龄和反应时间提供适当的上界。我们的估计仅使用关于**每个通信任务τc的最坏情况响应时间Rτc和最大到达间隔时间Tmaxτc**的知识，即**两个循环作业发布之间的最大时间。**

设S是任务集T的调度，考虑T的一些相互关联的因果链IE。我们将IE**分解成具有通信任务**τc1，τc2，...，τc kτ1的**局部因果链**e1，…，Ek。更具体地，我们有

![image-20230330215541267](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402119.png)

其中，每个Ei，i=1，…，k仅包含**单个−的任务**，即τ(Ei)，并且**每个通信任务τci，i=1，...，k - 1从ECU(Ei)到ECU(Ei+1)进行通信。**

我们==利用切割定理(定理12)来估计IE的局部成分的反应时间和数据年龄==，即，

![image-20230330215722831](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402233.png)

请注意==，(τci)，i=1，...，kτ1可以被认为是一个任务的因果链==。我们应用了Davare等人的界。==[9]用T_(Max)τ_i+R_(τ)_i估计隐含沟通条件下(τ_i)的数据年龄和反应时。==

> 对于通信任务（网络传输任务），使用Davare的分析：对任务链中所有任务的最坏响应时间和周期（最大到达间隔）进行求和。
>
> 悲观？？？

推论15.相互关联的因果链IE在==隐式通信==下的最大反应时间和数据年龄可以通过其局部部分的计时行为来估计：

![image-20230330220200793](https://cdn.jsdelivr.net/gh/wsm6636/pic/202303302202876.png)

> 拆分多个ECU的因果链为：任务-通信-任务-通信-任务
>
> 通信任务
>
> 上界=任务因果链上界+通信任务因果链上界

证明：这一结果来自切割定理(定理12)，并与Davare等人的估计一起得出。[9]如上所述。我们注意到，反应(Ei，S)和数据年龄(Ei，S)的值可以通过固定e1，...，Ek的所有ECU上的执行时间来计算，如第V-B节中所述。下面让我们得到类似的结果。

推论16.相互关联的因果==链IE**在LET下**的最==大反应时间和数据年龄可以通过其局部部分的计时行为来估计：

![image-20230330230411260](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402668.png)

![image-20230330231648998](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402175.png)

对于推论16，反应(Ei，S)和数据年龄(Ei，S)的值可以通过将有效的扩充的作业链与在[0，Φ+H)期间的外部活动的事件相比较来计算，如第五节开始处所述。

## 备用数据年龄定义

Dürr等人对最大数据年龄的定义。[10]与我们定义的最大数据年龄在以下方面不同：如果我们考虑图2中概述的事件链，则它们的最大数据年龄仅包括从采样到处理事件的时间，而不包括到致动事件的时间。这并不意味着他们的估计更精确，而是他们限定了更小的时间间隔。为了与[10]中的最大数据年龄进行比较，我们引入了最大缩减数据年龄*(E，S)的定义。它遵循定义6，只是我们将用于激活的事件设置为已处理事件。

**定义17(缩短的立即向后扩充的作业链)**。简化的立即向后扩充作业链c∗ESm，m∈N是唯一的扩充作业链(z，J1，...，J|E|，z‘)，其中

·将激励设置为在E(|E|)的第m个写入事件时发生的处理事件的时间，即，z‘=weJ|E|和J|E|=E(|E|)(m)，

·序列(J1，...，JE)是S中E的直接向后作业链，以及

·外部活动设置为数据采样的时间，即z=reJ1。

更具体地说，c∗mE（后）的前|E|+1个条目，与c（m+1）的条目一致，z‘被设置为wej|E|。

我们定义c∗E，Sm有效当且仅当Ce，Sm+1在定义10的意义上有效。减少的数据年龄的定义类似于定义11：

**定义18(最长缩短数据使用年限)**。对于具有调度S的因果链E，我们定义特定于调度的最大减少数据年龄为

![image-20230331102122244](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402778.png)

其中是公式中定义的扩充作业链的长度。(1)。如前所述，通过对所有调度的上确界获得总体最大减少数据年龄，即DataAge\*(E)=sups DataAge*(E，S)。

将切割定理(定理12)转移到约简数据年龄如下。在定理的证明中，我们从一开始就切断了一个直接向后扩充的作业链。这与z‘的选择无关，也就是说，我们将立即向后扩展的作业链也从缩减的立即向后扩展的作业链中切断。对于所有因果链E=(e1→e2)，这导致：

![image-20230331102512614](https://cdn.jsdelivr.net/gh/wsm6636/pic/202303311025705.png)

局部情况下的计算类似于第V-B节。==对于定期的作业发布和固定的执行时间，调度在Φ+2H处重复==，其中**Φ和H是该ECU上任务的最大阶段和超周期。**它足以模拟所有外部活动发生在Φ+2H之前的简化立即转发扩充作业链

![image-20230331103131856](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402350.png)

<span style="background:#FFDBBB;">对于互连计算</span>，我们依赖于公式中新的切割定理。(20)并获得

![image-20230331103232541](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402226.png)

在推论15中，对于任何相互关联的因果链，IE=(e1→Ek c 1→→···→−c k→τ1τEk)。公式中的最大(减少)数据年龄的局部值。(22)是通过在有限的时间框架内模拟所有(减少的)立即向后扩充的作业链并使用公式来计算的。(13)和公式。(21)。

## <span style="background:#FFDBBB;">评估⭐️⭐️⭐️⭐️⭐️</span>

所提出的端到端延迟分析的相关工业用例是汽车领域中因果链的时序验证。为了评估我们建议的分析在这一领域的实际好处，我们使用符合汽车基准[19]中描述的细节的合成任务集和因果链来评估分析。此外，==我们使用使用UUnifast算法[6]生成的任务集来评估一般任务参数的性能。==我们考虑了周期性任务集和隐式工作沟通来应用我们在第五节和第六节中的分析结果。

ECU内部设置：每个因果链中的所有任务都映射到一个ECU，并使用本地同步的时钟。

ECU间设置：因果链中的任务映射到不同步的不同ECU。互连结构用于跨不同ECU的数据通信。这项评估发布在Github[24]上。

在下文中，**我们使用Davare等人的方法。[9]标准化所有其他端到端边界**，因为此方法产生最悲观的结果。我们定义分析方法m相对于评估界B(·)的潜伏期减少G(M)，例如，最大反应时间

> 计算比davare的结果减少了多少？

![image-20230419095033478](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402751.png)

### A.任务和任务集生成

在该评估中，任务τi由最坏情况执行时间Ci、周期Ti、阶段φi和优先级πi来描述。此外，Ui=Ci/Ti是任务τi的利用率。

**Automotive benchmark**汽车基准[19]：在汽车基准下，任务τi的生成如下：

1)根据[19，表III，IV和V]的相关份额2，从集合T={1，2，5，10，20，50,100,200,1000}中提取任务τi的以ms为单位的周期Ti。

2)任务的平均执行时间(ACET)是基于满足[19，表III，IV和V]中所给出的性质的威布尔分布来生成的。

3)任务的最坏情况执行时间(WCET)是通过提取WCET因子来确定的，该WCET因子从区间[fmin，fmax]均匀分布，然后乘以该任务的ACET。

对于单个ECU情况，我们为U=50%、60%、70%、80%和90%的每个累积任务集利用率生成1000个汽车任务集。由于任务的利用率取决于最坏情况下的执行时间和汽车特定的半调和周期，因此我们使用全多项式近似方案来求解子集和问题，以选择候选任务集中的任务子集，使累计利用率满足上述要求。我们<span style="background:#FFDBBB;">首先生成T个1,000到1,500个任务的集合</span>，然后<span style="background:#FFDBBB;">使用子集和近似算法选择任务的子集T‘</span>，以在1个百分点的误差范围内达到目标利用率，即|(∑T’Ui)−U|≤0.01。平均而言，生成的任务集由50个任务组成。

均匀任务集生成[6]：对于用户指定的值n∈N和0<U∗≤1，UUniFast算法在∑n i=1 Ui=U∗的约束下，从(0，1]n均匀随机抽取利用率(U1，U2，...，un)。由于这些分析只适用于足够小的超周期，因此我们根据汽车基准绘制半调和周期。对于每个利用率值，即U∗=50%、60%、70%、80%和90%，<span style="background:#FF9999;">我们生成1,000个任务集，每个任务集50个任务。</span><span style="background:#FF9999;">每个任务的周期按照对数均匀分布从区间[1,2000]中提取，并舍入到集合{1，2，5，10，20，50,100,200,500,1000}中的下一个最小周期。给定周期和使用率，最坏情况下的执行时间被设置为Ui·ti。</span>

就我们所知，还没有发布的基准测试详细说明如何实验性地设置任务的异步发布，即任务的阶段值应该是什么。此外，Kloda等人的分析。[17]仅为具有同步任务的因果链制定。因此，在此评估中，我们考虑同步任务集(φi=0)。

### B.通信任务

为了评估相互关联的因果链，我们假设了一个固定优先级的通信结构。具体地说，我们随机绘制每个消息的对数均匀的周期，范围从10到10000ms，并将结果截断到下一个最小的整数，以对通信频率进行建模。此外，我们==假设消息的传输时间，即在通信结构上的执行时间是一个常数==。在我们的评估中，<span style="background:#FFDBBB;">我们**利用了标准2.0A CAN总线的恒定时间，**带宽为1 Mbps，其中传输8字节的数据(以及由于其头部和尾部而产生的66位开销)将需要ci=130·10−3ms。</span>在给定所有消息的集合并随机分配优先级的情况下，使用**非抢占式任务**的时间需求分析来计算每个通信任务的最坏情况响应时间。

> TSN上怎么定义
>
> wcet = (float(CAN_BUS['MESSAGE_BIT'])/CAN_BUS['BANDWIDTH_MBPS'])/10**3

### C.因果链的产生

**ECU内部因果链生成**：给定第VII-A节中描述的生成的任务集，根据[19]第IV-E节中的描述生成因果链集合。也就是说，<span style="background:#FF9999;">从每个任务集生成包含30到60个因果链的因果链集合</span>，如以下步骤所示：

1)根据[19]中的表VI所示的分布来绘制所涉及的激活模式的数目Pj∈{1，2，3}，即，所产生的因果链中的任务的唯一周期的数目。

2)Pj唯一周期是从均匀分布的任务集中提取的，不需要替换。更具体地说，该步骤产生Pj个不同周期的集合Tj。

3)对于TJ中的每个周期，我们根据[19]中表VII所示的分布，从与各自周期对应的任务集合中随机抽取2到5个任务(不替换)。由此产生的**<span style="background:#FF9999;">因果链由2到15个任务组成</span>**，并且没有任务在因果链中多次出现。

**ECU间因果链生成**：在均匀分布下，选取<span style="background:#FF9999;">5条具有相同利用率和优先级的不同任务集的因果链，生成10000条互连的因果链</span>。对于每个选择，我们**<span style="background:#FF9999;">创建20个通信任务，如第VII-B节所述(每个ECU对一个)。我们选择其中的4个来连接这5个通信任务。</span>**

### D.评估结果



在图7和图8中，我们显示了汽车和统一任务生成的评估结果。方框图显示了Dürr等人对方法的改进。[10](Dür)和Kloda等人。[17](KLO)，以及我们在V-B节中的局部和我们在V-C节中分布的(OUR)，而不是Davare[9]的方法。(23)。由于我们在第六节中定义的最大缩减数据年龄与Dürr和Kloda中的数据年龄的定义一致，所以我们比较了我们使用的最大缩减数据年龄。Schlatow等人的方法。[23]由于它是由非调和任务系统的Davare方法主导的，因此被省略。在几乎所有情况下，我们的方法都明显优于最先进的分析。仅对于图7a和图8a中单个ECU场景中的最大反应时间的估计，我们的方法执行类似于Kloda。特别是对于相互关联的情况，我们的方法显著地提高了最新水平。

## 结论

将所有作业的执行固定到它们的最坏情况，我们给出了关于扩充作业链的精确定义和精确的局部分析。

限制ECU之间的通信时间，使得这种局部分析可用于互连的ECU案例。==我们计划进一步探索优先级分配，使系统中的所有因果链都满足其要求。==

不仅通过在ECU通信上划分因果链，而且在一个ECU上划分因果链，以寻找更有效的算法。



[^9]: [9] A. Davare, Q. Zhu, M. D. Natale, C. Pinello, S. Kanajan, and A. L. Sangiovanni-Vincentelli. Period optimization for hard real-time distributed automotive systems. In Design Automation Conference, DAC, pages 278–283, 2007.
[^10]: [10] M. Dürr, G. von der Brüggen, K.-H. Chen, and J.-J. Chen. Endto-end timing analysis of sporadic cause-effect chains in distributed systems. ACM Trans. Embedded Comput. Syst. (Special Issue for CASES), 18(5s):58:1–58:24, 2019.
[^17]: [17] T. Kloda, A. Bertout, and Y. Sorel. Latency analysis for data chains of real-time periodic tasks. In IEEE International Conference on Emerging Technologies and Factory Automation, ETFA, pages 360–367, 2018.



***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考

Referred in <a href="zotero://note/u/HWG3PU5P/?ignore=1&#x26;line=-1" rel="noopener noreferrer nofollow" zhref="zotero://note/u/HWG3PU5P/?ignore=1&#x26;line=-1" ztype="znotelink" class="internal-link">cause-effect chain</a>
