---
created: 2023-11-17T19:14
updated: 2024-03-17T22:51
tags:
  - 笔记
  - 笔记/文献笔记
  - 论文参考
---

# Supporting end-to-end data propagation delay analysis for TSN-based distributed vehicular embedded systems

| Title                 | Supporting end-to-end data propagation delay analysis for TSN-based distributed vehicular embedded systems |
| --------------------- | ---------------------------------------------------------------------------------------------------------- |
| Journal or Conference | Journal of Systems Architecture                                                                            |
| Authors               | Bahar Houtan; Mohammad Ashjaei; Masoud Daneshtalab; Mikael Sjödin; Saad Mubeen                             |
| Pub. date             | 08/2023                                                                                                    |
| DOI                   | [10/gsdx42](https://doi.org/10/gsdx42)                                                                     |
| Level                 |                                                                                                            |

# Supporting end-to-end data propagation delay analysis for TSN-based distributed vehicular embedded systems——基于TSN的分布式车载嵌入式系统支持端到端数据传播时延分析

在本文中，我们发现现有的分布式嵌入式系统端到端数据传播延迟分析方法在节点**同步时**会计算出悲观(过度估计)的分析结果。这尤其是时间敏感联网(TSN)中的调度业务(ST)类的情况，其根据IEEE 802.1Qbv标准被调度为离线，并且节点根据IEEE 802.1AS标准被同步。本文提出了一种适用于分布式嵌入式系统的综合系统模型，该模型综合了上述所有方面以及TSN中的所有业务类别。我们扩展了分析以支持**ECU之间的同步和非同步以及网络上的离线调度**。当节点被同步时，扩展分析现在可以用于分析TSN中的所有业务类别，而不会在分析结果中引入任何悲观。我们通过一个汽车工业用例对所提出的模型和扩展分析进行了评估。

## introduction

**车载分布式嵌入式系统**通常用任务和消息链建模，这些任务和消息可以分布在通过实时网络连接的两个或多个电子控制单元(ECU)1上[1]。传统上，车载通信是基于低带宽、低延迟的网络，如控制器局域网(CAN)[2]。由于==CAN是事件触发的通信协议，因此连接到网络的ECU不同步==。在许多复杂的车载分布式系统中，传统的车载网络无法支持高带宽的要求，在这些系统中，人们希望实现更高水平的自主驾驶。实现这些车辆系统的条件是纳入一系列功能，从处理高数据速率传感器读数，到收集车辆环境信息，并对相应的输入提供可预测的响应[3]。未来车辆系统中使用的通信标准需要灵活，以允许随着时间的推移适应系统的新功能。最近，IEEE时间敏感网络(TSN)任务组2开发了一套TSN标准，这些标准已经成为支持高带宽和低延迟车载通信的有前途的解决方案[4]。

在车载分布式嵌入式系统中，任务链和消息链中的数据从输入端传播到输出端。输入对应于链中的第一个任务，例如读取传感器信号的任务。然而，输出对应于链中的最后一个任务，例如，产生激励信号的任务。请注意，链中的任何两个相邻任务都使用可重写且非消耗的缓冲区(也称为寄存器)进行通信。这意味着，写入器任务可以覆盖缓冲区中的先前数据，而数据在被读取器任务读取后仍保留在缓冲区中。如果这样的链中的任务由具有不同周期(例如，不同的周期时钟)的独立激活源激活，则数据可以通过从链的输入到输出的不止一条路径传播。这会导致数据在遍历链时会遇到不同类型的延迟。这些延迟称为数据传播延迟或端到端延迟。系统的开发人员需要在设计时验证是否满足指定的时序约束。这可以通过执行这些系统的端到端数据传播延迟分析来实现[5-8]。

汽车业和学术界的一项联合努力确定了车辆系统中这些延迟的重要性，并提供了它们的形式语义[5，6，9]。最终，与这些延迟对应的时间约束被包括在汽车领域专用建模语言EAST-ADL[10]和汽车开放系统架构(AUTOSAR)标准[9]中。为了验证这些时间限制，研究界与汽车行业的研发人员合作开发了端到端数据传播延迟分析[5-8]。这一分析已经在汽车行业中使用的几个工具中实现，例如，SymTA/S4[11]和Rubus[12]。由于CAN是车载领域应用最广泛的车载实时网络，现有的分析将CAN[13，14]的响应时间分析包含在端到端数据传输延迟分析中。此外，由于CAN是事件触发的网络通信协议，不支持连接的ECU的同步，现有的端到端数据传播延迟分析中的数据路径计算算法没有考虑ECU的同步。

现有的端到端数据传输延迟分析及其数据路径计算算法也支持TSN的前身，称为以太网音视桥接(AVB)，它包括了TSN的一些类别。这是因为AVB还支持事件触发流量，并且不考虑ECU的同步。在这种情况下，AVB[15]的响应时间分析被合并到端到端数据传播延迟分析[16]中。然而，TSN标准支持根据IEEE 802.1AS标准的ECU同步。特别是，根据IEEE 802.1Qbv标准，当使用TSN中的调度流量(ST)类别时，ECU应该同步。根据离线创建的调度来传输映射到ST类的实时流量。通常，当使用IEEE 802.1AS标准时，无论使用哪种TSN业务类别(ST、AVB和尽力而为(BE))，都应认为TSN网络中的ECU是同步的。我们发现，当将现有端到端数据传播延迟分析中的数据路径计算算法(即[5])应用于同步ECU的情况时，分析结果可能是悲观的(过度估计的)，因为该算法没有考虑ECU之间的同步。

在本文中，我们在现有的端到端数据传播延迟分析中扩展了数据路径计算算法，以==支持ECU之间的同步和非同步==。==扩展算法支持TSN中的所有流量类别==。使用扩展算法，现有的端到端数据传播延迟分析现在可以用于分析TSN网络中的所有业务类别，其中ECU可能同步也可能不同步，而不会在分析结果中引入任何悲观(过度估计)。

论文的主要贡献如下：

-当**ECU使用IEEE 802.1AS标准进行同步**时，我们扩展了现有端到端数据传播延迟分析中的数据路径计算算法，以支持TSN网络中的所有流量类别。与现有算法不同，**当TSN网络中的ECU同步时，扩展算法的分析结果不包含任何悲观因素。**当ECU在TSN网络中不同步时，扩展算法是向后兼容的，以**支持对所有非调度业务(非ST)类别5(AVB或BE)的分析。**

-为了支持该扩展算法，我们提出了一个**完整的分布式嵌入式系统模型**，该模型包含了TSN中的所有业务类别。该模型可以表示包含TSN支持的各种类型流量的分布式任务链，包括ST、AVB和BE流量。

-通过对一个汽车工业应用案例的分析，验证了该模型和分析的适用性。我们还通过使用这两种分析对用例进行分析，对扩展分析和现有分析进行了比较评估。此外，通过实验对所提出的模型和分析进行了评估，以显示不同的ST类配置、接收方周期以及发送方和接收方ECU的同步对端到端数据传播延迟的影响。

论文的其余部分组织如下。在第二节中，我们介绍了TSN的背景和TSN网络时序分析的相关工作。第三节描述了端到端的数据传播时延，并阐述了如果将现有的分析应用于TSN中的ST类，则会高估时延。第四节提出了分布式嵌入式系统的系统模型，第五节对已有的端到端数据传输延迟分析方法进行了扩展。第六节介绍了一个车辆应用案例研究。我们将现有分析的结果与我们提出的扩展的端到端数据传播延迟分析进行了比较。此外，我们还给出了用例结果和实验研究，以展示各种参数对端到端数据传播延迟的影响。最后，我们讨论了6.4节中的结果，并在第7节中总结了本文。

## 2.背景及相关工作

### 2.1.时间敏感型网络(TSN)

TSN标准是最近由TSN任务组在IEEE标准化中制定的。这套标准可以被视为包含各种功能的工具箱，以提高多个应用中的通信性能，例如自动化和汽车应用[1，17，18]。根据IEEE 802.1Q-2022标准，业务类别分为ST、AVB和BE业务三类。在几个特征中，TSN标准允许通过如图1所示的门控制列表(GCL)根据离线调度传输的ST业务的时间隔离。GCL是时间感知整形器(TAS)的一部分，它可以使用一组门来实现临时隔离，这些门控制TSN接口或交换机的端口上的流量传输。门可以停止较低优先级业务的传输，以支持紧急ST业务类别，这进而保证ST业务的低抖动传输(也称为抢占)。此外，TSN标准定义了基于信用的整形(CBS)机制，该机制允许在网络上为一组称为AVB类的业务类预留带宽。AVB流量包括从A(高优先级)开始的多个类别，由于每个端口的队列数量为8个，因此最多可以包含8个类别。在分析和示例中只使用A类和B类是非常常见的，而在标准中可能有八个AVB业务类。分配给AVB类的队列经历用于传输的CBS机制。根据CBS机制，在每个TSN端口上按业务类别配置信用，并且仅当该类别的信用为零或正时才能发送与该类别相关联的业务。如果信贷为负，传输将被暂停，直到信贷以恒定的利率(即所谓的idleSlope)补充到零或正。当传输以恒定速率(称为发送斜率)进行，并且这两个值的总和等于端口速率时，信用会减少。此外，TSN可以支持不需要任何定时保证的传统业务传输，这被称为BE业务类别。如图1中的例子所示，优先级代码点(PCP)表中的八个业务优先级被映射到TSN交换机出口端口的八个可配置队列。队列可以被配置为使用上述机制中的每一种来将具有相关联的PCP的业务传递到端口。在这个例子中，PCP“111”被配置为使用ST类，PCP“101”和PCP“100”随后被分配给具有优先级A和B的AVB类。PCP“001”被视为BE流量。


![image-20230703214041642](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307032140943.png)

### 2.2.相关工作

在文献中已经提出了几种可调度性分析技术来计算通过TSN网络的业务穿越的最坏情况的延迟。在这些技术中，许多只关注在CBS下的A类和B类帧的最坏情况下的时延，例如，[19]中的工作和[20]中给出的改进技术。此外，文献[21]中的工作提出了一种基于轨迹方法的方法来计算A类和B类的延迟。该方法与以前的方法相比，例如与文献[19]中的方法计算的延迟相比，获得了更紧的延迟界。后来，[22]中的工作提出了合格间隔的概念，它可以为每帧的延迟提供一个界限，从而与以前的分析技术相比，导致更紧密的分析。上述工作单独考虑了TSN网络中的CBS。但是，TSN标准提供了各种整形器和机制供网络设计人员选择。例如，[23，24]中的建议提出了一种基于网络微积分的分析，其中考虑了一种称为突发限制整形器(BLS)的TSN整形器。

各种可调度性分析技术侧重于CBS以外的机制，例如门机制。文献[25]中提出的分析同时考虑了CBS和GATE机制，计算了TSN中A类和B类消息的最坏情况响应时间。但是，该分析考虑的是单交换机网络，而工业网络可以由多个交换机组成。[26]中的工作给出了计算每条链路的延迟累积的分析，而[27，28]中的工作使用网络演算来检查TSN消息的可调度性。此外，[29]中的技术提供了A类和B类消息的响应时间分析，考虑了CBS和对ST的支持，这是在[30]中早先提出的。此外，[31]中的工作扩展了[29]中的技术，用于在响应时间分析中支持BE业务。后一项工作中的流量转发和整形模型不同于TSN标准模型，因为它是在第一个TSN草案定稿之前提出的。

根据IEEE时间敏感网络(TSN)任务组，TSN网络还可以受益于抢占支持以及CBS和GATE机制。因此，[32]中的工作提出了一种在IEEE 802.3br标准下考虑帧抢占的分析。此外，[33]中的工作提出了一种技术，当在TSN网络中使用CBS、门机制和帧抢占时，该技术计算A类和B类帧的最坏情况响应时间。类似地，[34]中的工作提出了结合各种模式(例如启用和禁用保持和释放机制)的TSN特征的响应时间分析。在TSN标准中定义了保持和释放机制，以防止由于较低优先级类别A和B的传输而导致的ST业务的任何可能的抖动。

==为了验证基于TSN的分布式嵌入式系统的时序行为，不仅要考虑TSN网络中节点中任务和消息的响应时间，而且要考虑包含TSN消息的任务链中端到端的数据传播延迟。==

根据文献[35]的分类，计算最坏情况下的端到端时延有三种方法：(1)基于仿真的方法，从一组选定的场景中获得最大端到端时延。该模拟方法不一定会显示最大端到端延迟，因为它可能不会覆盖最坏情况下的所有可能假设；(2)基于穷举搜索的模型检查即使在大规模网络上也可以提供准确的最坏情况下的端到端延迟。然而，这些方法具有很高的时间复杂性；以及(3)提供端到端延迟上界的分析方法，但存在一定的悲观情绪。我们的工作在于上述分类中的一组分析方法。

参考文献[36]从不同的角度提到了端到端数据传播延迟分析的主动和被动方法。主动方法优化了链中的任务释放模式，以实现最佳延迟。然而，被动方法研究分布式嵌入式系统中端到端延迟的最坏假设，以找到延迟的上界。本文和文献[5，7，8，36-40]中的作品都属于被动范畴。在本节的后续段落中，我们将介绍一些关于端到端数据传播延迟分析的最新工作。

现有的计算端到端延迟的端到端数据传播延迟分析结合了各种传统实时网络的响应时间分析，例如CAN[7]和传统以太网[41]。

[42]中的工作以一个执行节点内的因果链中的数据年龄延迟为目标。这些任务在终端站内同步，并使用偏移量进行调度。本文的目的是找到任务的优先级和偏移量，并优化任务的设计映射，以最小化任务链中的数据年龄延迟。同样，[43]中的工作旨在找到任务链的偏移量，以优化端到端延迟。文献[42，43]中的工作属于主动端到端数据传播分析。此外，文[44]还研究了任务实例之间的依赖关系。这种依赖关系可以在早期开发阶段指定，以保证数据年龄延迟限制。

[36]中的工作对在一个终端站具有本地同步周期性任务的系统执行端到端时序分析。终端站仅支持非同步通信，即通过CAN或FlexRay。同样，[45]中的工作考虑了终端站之间的全局非同步通信，而终端站内的任务被认为是同步的。与[36]中的分析相比，[45]中的作者提出了一种计算效率更高的分析。此外，[45]中的工作比[36]中的工作获得了更高的数据年龄延迟上界。

前述工作的重点仅在于数据年龄延迟，而我们的分析还包括对反应延迟的分析。参考文献[5]是文献中的开创性工作，它引入了用于定义周期性和基于寄存器的系统中的端到端延迟的正式框架。[5]中的任务模型是**基于有限执行时间(BET)**的任务模型。在BET任务模型中，任务之间的通信是隐式的，其中任务在开始时从寄存器读取数据，并在执行结束时写入寄存器。此外，文献[46]中的工作提出了一种端到端的数据传播延迟分析方法，其中包括基于BET任务模型的零星任务。论文[37]的工作建立在逻辑执行时间(LET)范式的基础上，提出了一种基于逻辑执行时间(LET)的分布式嵌入式系统通信模型。Let是一个任务间通信模型，它将读/写访问时间(任务的输入和输出)增加到任务的物理执行时间模型。系统级LET对不同终端站任务之间的通信进行建模。在[37]中提出的工作中，终端站有自己的本地时钟(时间表)。全局时间线是基于发送方和接收方终端站的具有有界误差的本地时间线来近似的。==在我们的端到端数据传播延迟分析中，我们依赖于对ST流量承诺的确定性，并在分析利用ST流量的事务时排除全局同步误差。==[47]中的工作考虑了全局非同步和局部同步的任务链，并提出了一种方法来计算导致最大端到端延迟的有限数量的定时路径7。我们在[5，7，8，41]工作的基础上扩展了时间路径方法，**该方法在等于链中所有相关任务周期的两倍超周期或最小公倍数(LCM)的有界窗口内计算所有可能的时间路径。**因此，==我们的算法在考虑了所有可能的情况后，找到了导致最坏情况下端到端延迟的定时路径。==

虽然大多数工作集中于提供计算链中最大端到端延迟的方法，但[48]中的工作讨论了围绕端到端时序约束的稳健性裕度。文[48]采用BET和系统级LET通信模型，进一步研究了任务响应时间的变化及其对系统健壮性的影响(即端到端延迟的变化)。在我们的评估中，我们还考虑了通过改变ST流量的配置和接收器任务的周期来改变端到端定时延迟的变化。我们只关注BET，并考虑被评估系统的预定义的端到端时序约束。

[38]中的工作提出了机器人操作系统(ROS)环境中任务链的端到端数据传播延迟分析。在[38]之前的分析主要集中于分析周期性和零星任务。[38]中的工作扩展了端到端时序分析，以支持处理时间触发和事件触发函数混合的ROS2任务链。此外，[38]中的网络模型是基于发布者-订阅者通信模型的。因此，通信模型本质上是非同步的。我们工作中提出的分析只适用于周期性任务。

与前述工作相比，==本文的目的是在已有的端到端数据传播延迟分析[5，7，8，41，47，49]中扩展数据路径计算算法，以支持对TSN中节点可以同步或不同步的所有业务类别的分析==。这些工作也已经在支持车载嵌入式系统基于模型和基于组件的软件开发的工具中实现，例如[7，39，40]，所有这些工具都在考虑BET任务建模范型。

在端到端数据传播延迟分析算法中使用的现有定时路径计算，例如[5，47]，适用于不需要离线调度的业务类别，即AVB和BE。例如，[47]中的工作为发送方和接收方终端站之间的同步通信提供了端到端分析，但它只考虑了非ST在同步终端站之间传输的情况，即AVB或BE。

就我们所知，基于系统级LET模型的分布式嵌入式系统中，针对互联终端的端到端数据传输时延分析的工作很少，如[36-38，48]。与以往的工作不同，==本文认为ST消息的调度是有偏移量的(具有全局同步的终端)==。

根据[48]，==这两个模型可以相互映射。我们选择使用BET模型，因为它已经集成到支持车载嵌入式系统基于模型和基于组件的软件开发的几个工具(包括工业工具)中，==例如在[39，40]中。
> BET=隐式
## 3.端到端数据传播延迟

<span style="color:black;background:#40a9ff !important;">嵌入式实时系统通常用任务链和消息链来建模。为了验证这些链的计时行为，不仅需要计算它们的端到端响应时间并与相应的截止日期进行比较，还需要计算端到端的数据传播延迟(数据年龄和反应时间)并与相应的数据年龄和反应时间约束进行比较。</span>对数据年龄和反应延迟的时间约束通常在这些分布式链上指定。对于数据新鲜度很重要的控制应用而言，对数据老化延迟的约束尤其重要。然而，在对输入事件的第一反应时间具有价值的应用中，反应约束是重要的。这些约束被包括在AUTOSAR标准[9]的时序模型中，并被翻译成车辆领域的几种建模语言[50]。

### 3.1.单节点嵌入式系统中的数据传播延迟

为了解释数据年龄和反应时间延迟，考虑一个由三个任务τ1、τ2和τ3组成的任务链，如图2所示。所有任务都属于单核节点，并独立激活。任务τ1、τ2和τ3的激活周期分别为8ms、8ms和4ms。假设每个任务的最坏情况执行时间(WCET)为1ms。为简单起见，我们假设τ1的优先级高于τ2的优先级，并且τ2的优先级高于τ3的优先级。通过这种优先级分配策略，我们确保链中的先例元素应该在链中的后续元素之前执行。这些任务使用基于寄存器的通信，即它们通过向寄存器写入数据和从寄存器读取数据的方式相互通信以及与其环境通信。==寄存器是非消耗型的。这意味着读取器读取数据后，数据仍保留在寄存器中。此外，寄存器是可重写的，即，如果写入器比读取器快，则在读取器可以读取先前数据之前，寄存器中的先前数据可以被新数据覆盖。==τ1从REG-1读取的数据对应于链的输入。同样，τ3写入REG-4的数据对应于链的输出。

由于任务是独立激活的，并且一些任务具有不同的周期，因此数据通过从链的输入到输出的多条路径遍历整个链，如图3所示。这些路径称为定时路径(也称为数据路径)。由于多条定时路径，将数据从输入端传送到链的输出端可能会有各种延迟。

数据年龄延迟是从数据到达输入端到相应数据在输出端的最新可用性之间经过的时间。在数据年龄延迟分析中，我们感兴趣的是确定输入数据和相应输出数据的最后样本之间的最长时间差。另一方面，反应延迟对应于与刚刚错过输入处的读访问的数据相对应的在输出的第一实例处的数据的最早可用性。==如果事件(对应于数据可用性)发生在任务激活时或之前，则该事件被任务实例视为可读。如果该事件恰好在任务实例激活之后发生，则数据对该实例不可读，即该任务的当前实例刚好错过了该数据。丢失的数据由任务的下一个实例读取==。图3中的白色闪电说明了这一点，其中在时间0的τ1的第一个实例未命中数据，但是在时间8的τ1的下一个实例读取相同的数据。

图2中链中可能的数据年龄和反应延迟如图3所示。一方面，来自时间16之前发生的事件的数据可由τ1的第三实例访问(在时间16激活)。在这种情况下，此事件的最新影响在链的输出端可用，直到事件发生后5毫秒(数据老化延迟)。另一方面，来自时间0之后的事件的数据采样被延迟到时间8，此时数据可以被τ1的第二实例读取。因此，数据影响出现在链的输出端的最早时间是事件发生后11ms(反应时间延迟)。

![image-20230703220547385](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402870.png)

### 3.2.分布式嵌入式系统中的数据传播延迟

数据传播延迟在分布式嵌入式系统中同样有效。让我们考虑图4所示的分布式嵌入式系统中的分布式任务链，其中两个节点通过网络连接。在本例中，任务分别以6毫秒和3毫秒的周期定期激活。节点1中的任务τ1通过网络向节点2中的任务τ2发送消息。

根据网络类型的不同，我们可能有不同的可能的定时路径，数据可以通过这些路径从发送方任务传播到接收方任务。例如，当网络不能独立于发送任务发起通信时，消息只能由发送任务在网络接口上排队传输。这是许多==事件触发的网络协议的情况，如CAN[2]。在这种情况下，消息从发件人任务继承其周期。==此外，分布式任务链中的定时路径还取决于网络是否支持节点的同步。例如，TSN通过IEEE 802.1AS标准支持终端站之间的同步，而CAN协议不支持同步。图5示出了图4所示的系统中节点同步时的执行轨迹。该分布式链中的数据年龄和反应时间延迟分别被标识为7ms和10ms。

![image-20230703223712854](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402296.png)

图6(A)中示出了当节点不同步时图4中的分布式任务链的可能执行轨迹。为了在节点不同步时产生最坏的情况，我们假设接收器任务τ2在消息到达接收器节点之前被激活。因此，τ2的当前实例(第一个周期激活)将错过消息的读访问权限。消息将由τ2的下一个实例(第二周期激活)读取，如图6(A)所示。如图6(A)所示，相应的数据年龄延迟被标识为9ms。

为了增加可读性，当节点如图6(B)所示不同步时，我们为分布式任务链中的反应时间延迟的情况单独绘制了相同的执行轨迹(如图4所示)。在图6(B)中，τ1的第一实例正在激活消息M1的第一实例。根据对反应延迟的假设，τ1的第一个实例错过了链的输入事件的采样，因此M1的第一个实例不将有效数据从输入事件传递到接收器任务。然而，当τ1的第二个实例读取输入事件时，消息M1的第二个实例也保存新的数据。由于τ2与τ1不同步，因此最坏的假设是τ2在保存采样数据的消息到达之前被激活。因此，τ2的第一个实例未读取由M1的第二个实例写入的事件数据。但是，在τ2的下一个实例(第二周期激活)中，τ2能够从M1读取传入数据。相应地，反应延迟为12ms。

![image-20230704204408088](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402544.png)

### 3.3.需要扩展定时路径计算算法⭐️⭐️⭐️⭐️⭐️

现有的端到端数据传播延迟分析中的定时路径计算算法隐含地假设节点不同步。因此，消息接收任务的最坏情况假设是，该任务在消息到达之前被释放以供执行。这意味着该任务的当前实例无法读取该消息，因此该任务的下一个实例将读取该消息**。当使用IEEE 802.1AS标准同步节点时，这在TSN的情况下可能不是真的**。如果将现有算法应用于同步节点，如TSN的情况，则计算的延迟可能是悲观的(即，高估)。这可以在图5、6(A)和6(B)中看到，其中为同步的终端站计算了7ms和10ms的数据年龄和反应时间延迟(图5)。与非同步终端站的情况(图6(A)和6(B))相比，分别计算了9ms和12ms的数据年龄和反应延迟。

> TSN同步，所有站点时间同步。所以按照其他CAN总线网络的分析，由于不同步所以对于TSN来说是悲观的
>
> 需要考虑同步带来的延迟，这篇文章好像没考虑
>
> 终端支持TSN同步，如果考虑到终端不支持呢？结合上一条，需要加上时间同步带来的延迟

在图7中可以看到另一个例子，其中对使用ST类经由链路L1传输消息M1的两个终端站之间的事务执行现有的端到端数据传播延迟分析。在发送方终端站中，任务τ1和τ2中的每一个的周期为10ms。消息M1由发送方终端站中的τ2发送。接收器任务(τ3)的周期是10ms，并且它从链路L1读取来自消息M1的数据。将消息的偏移量设置为1.052毫秒，并且预计该消息将在比L1处的消息的偏移量晚0.025毫秒时完成其传输。每项任务的WCET为0.5ms。在ST业务的理想条件下，当发送方和接收方终端站如图7(A)所示同步时，数据年龄和反应时间延迟随后是10.5ms和20.5ms。如图7(B)所示，在非同步节点的情况下，该事务的数据年龄和反应时间延迟是悲观的(高估的)，即分别为11.577毫秒和21.577毫秒。这并不可取，因为ST流量最常应用于需要精确计算延迟的关键应用中。因此，现有分析中的数据路径计算算法需要扩展以支持同步节点，而不会在分析结果中引入任何悲观情绪。

> 怎么在分析里面综合同步和非同步的
>
> 激活时间，4.4.3

![image-20230704205025351](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307042050488.png)

## 4.系统模型

在这一部分中，我们正式提出了分布式嵌入式系统的系统模型，该系统由两个或多个通过TSN网络连接的==终端(单核节点、计算单元或ECU)==组成。系统S由一组表示为Γ的事务、一组表示为ε的终端站和一组表示为Ν的网络组成。该系统由以下元组正式表示。![image-20230704205803953](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211401919.png)

事务(表示为Γ)表示由两个或多个任务组成的分布式任务链的模型。任务链可以在一个终端站内执行；或者不同终端站的任务可以通过网络中的一个或多个消息(Ν)彼此通信。系统模型中可以存在多个事务。这组交易随后由等式正式表示。(2)：![image-20230704205810126](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402841.png)

系统中的终端站集合由方程表示。(3)。![image-20230704205823074](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402588.png)

### 4.1.终点站模型

终端站εi可以由一个或多个任务组成，如公式中所示。(4)：![image-20230704205906083](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307042059393.png)其中i是任务所属的终端站的索引。注意，终端站中的任务可以是一个或多个事务的一部分。因此，j表示事务索引。最后，k代表终端站范围内任务的唯一标识符。

> 第i个终端站里第k个任务，属于第j个事务（任务链）

### 4.2.任务模型

任务的属性由等式中的元组指定。(5)。

![image-20230704210216196](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402831.png)

其中，Cijk是任务的WCET，Tijk是任务的周期，Pijk是任务的优先级，Jijk是任务的释放抖动。此外，Oijk表示任务的偏移量。

任务的一些其他属性是使用任务的元组中的上述信息计算的。首先，可以使用任务的周期和基于公式的偏移量来获得任务τijk(表示为αijk(N))的==第n个实例==的激活时间（activation time）。(6)![image-20230704210401748](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307042104812.png)。此外，任务的最坏情况响应时间由Rijk表示。此外，任务τijk的第n个实例由τijk(N)表示。

### 4.3.网络模型

网络属性由公式中的一组参数表示。(7)：![image-20230704210528759](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307042105011.png)

其中s是整体网速。我们假设网络在所有链路上以相同的速度运行。![image-20230704211125013](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402890.png)持有网络中的一组链路。我们认为每个链路在终端站和交换机之间或在两个交换机之间创建双向连接。网络中的所有交换机都是TSN交换机，因此网络中可以有不同的流量类别。我们用等式中的集合![image-20230704211136797](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402597.png)来表示业务类别。(8)，其中AVB可以是A、B类或经过CBS的其他类。此外，ST和BE分别表示调度业务和尽力而为业务类别。![image-20230704211151706](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307042111810.png)

网络中的消息由mjk指示，其中下标j标识该消息所属的事务。此外，下标k是网络范围内的消息的唯一标识符。情商。(9)显示定义消息属性的属性集。![image-20230704211253751](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402756.png)

其中，消息的优先级由指定发送消息的TSN类别的Pjk表示，例如，类别ST、AVB(A、B等)。然后就是。在该模型中，ST类的优先级最高，而AVB的优先级低于ST类。此外，在所有其他类中，BE类的优先级最低。数据的大小(以字节为单位的有效负载大小)由Sizejk表示。我们假设==所有定义消息属性的属性集。![image-20230704211253751](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402756.png)==的，因此Tjk是消息的周期。消息的释放抖动由JJK表示。被指定为从源终端站到目的地终端站的消息的路由的链路集合被存储在集合JK中。此外，在集合Jk中指定的每个链路处的消息的偏移量的集合被存储在集合![image-20230704211356193](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402689.png)中。我们**假设我们只知道ST流量的偏移量，因为它是离线调度的**。因此，假设为非ST业务(AVB或BE)设置的Ojk为空，即Ojk={}。
> ST流量的偏移量已知，O。⭐️⭐️⭐️⭐️⭐️

基于上述属性，我们可以通过利用TSN[31]中各种类别的响应时间分析来计算消息mjk的其他属性，例如传输时间(Cjk)以及最坏情况响应时间(Rjk)。此外，通过公式计算出==消息mjk在链路L的第n个实例的激活时间==。(10)，其中，Ol jk是链路L上Mjk的偏移量。

![image-20230704211515028](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307042115181.png)
我们假设==ST和非ST流量都继承了相应发送任务的周期==。因此，==Tijk表示属于第i个终端站并且是第j个事务的一部分的第k个任务（发送任务）的周期。==此外，我们用mjk（n）表示消息mjk的第n个实例。
### 4.4.传输模型

事务Γj表示分布式任务链的模型，该分布式任务链由经由一个或多个消息彼此通信的两个或多个任务组成。==事务的第一个任务读取的数据被视为事务的输入，链的最后一个任务写入的数据对应于事务的输出。==传输的周期由TJ表示。请注意，此模型将==消息数量限制为每个事务一条==。

图8显示了采用该模型的基于TSN的分布式嵌入式系统的实例。有两个终端站连接到一个TSN网络。更具体地说，终端站1和2通过链路L1和L2连接到交换机1(SW1)。系统中有两个事务，即Γ1和Γ2，如图8所示。这些事务在图9中进一步详细说明。

根据图8中的例子，事务1是在单个终端站(2)内的事务，并且只包括来自终端2的任务。因此，终端2既是事务1的发起者，也是Γ1的终止者。如图9所示，事务Γ1在终端站2内发起和终止。另一方面，事务Γ2分布在两个终端站上。从终端1开始并在终端2中终止Γ2。消息M21从链路L1、和L2在事务发起方和终止方之间传输。应该注意的是，==事务模型没有考虑事务中任务的分叉和联接==。

![image-20230704211913295](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402713.png)

![image-20230704212115678](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307042121780.png)

> 在交换机时，考虑排队问题吗

#### 4.4.1.触发模式

根据[51]，对分布式事务中任务和消息的激活时间的假设影响事务的延迟。在本文中，我们假设事务中的每个实体，无论是任务还是消息，都可以在两种模式下触发，即“从属”或“独立”。触发模式由参数triggerMode选择，如下式所示。(11)。![image-20230704212416705](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402505.png)

任务可以由事件源(例如周期性时钟)独立地触发。此外，可以基于1、来自前导任务的激活信号。2、从前导任务接收数据。3、两者的组合来触发任务。

> 怎么结合？

#### 4.4.2。消息激活时间⭐️⭐️⭐️⭐️⭐️

如果==消息是ST，则独立触发==。这意味着该消息基于在其到目的地终端站的路线中指定的每条链路上为**其定义的静态偏移量来触发**。在==从属触发模式的情况下，消息在其发送方任务执行结束时触发==。例如，在TSN网络(AVB或BE)中分配给**非ST类的消息一旦消息的发送者任务完成其执行并且链路上的带宽可用，就可以使用该链路，并且不存在需要传输的更高优先级的消息**。

#### 4.4.3.接收方任务的激活时间⭐️⭐️⭐️⭐️⭐️

消息接收任务的激活时间可以根据不同的假设进行计算。例如，如果发送方和接收方终端站是同步的，则假定它们的任务的第一个实例被同时激活。在这种情况下，==接收器任务轮询TSN网络以从消息中读取数据。==因此，同步网络内的接收任务的激活时间由公式中的通式计算。(6)。其中接收端站内的任务的每个实例n被周期性地释放(Tijk)并且可以具有由参数Oijk指定的偏移量。在==非同步网络中，==现有的分析假设==一旦消息在网络上可用，接收者任务就获得读访问权限==。因此，消息接收任务的激活时间用Eq(12)来表示。。

![image-20230704224646155](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402179.png)

> 同步：接收任务轮询TSN网络读取，激活时间=n*周期+偏移量
>
> 非同步：一旦消息在网络上可用，接受任务立刻读取，激活时间=n*周期+偏移量+最差响应时间

#### 4.4.4。传输约束

由Crj表示的对事务的定时约束定义了延迟的最大允许值，例如数据年龄(Agej)和反应时间(Reacj)。此外，可以在传输上指定截止日期约束(DJ)。截止日期约束对应于端到端的响应时间，即事务从输入到输出的响应时间。这些约束条件如公式所示。(13)对于传输Γj：

![image-20230705152848716](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402455.png)

## 5.端到端数据传播时延分析

这一部分给出了分布在TSN网络上的任务链的端到端数据传播延迟分析。该分析基于现有的分析[5，7]，该分析考虑了像CAN这样的遗留网络。端到端数据传播延迟分析需要计算分布式任务链中所有相关的数据路径(也称为可达定时路径)。==与CAN不同，在TSN中，不同的业务类别将在同一网络中进行分析，这将需要合并同步和非同步终端站。==现有的端到端数据传播时延分析[5，7]中的数据路径计算算法只支持非同步的端站。在这一部分中，我们提出了一种适用于TSN网络的扩展算法，该算法覆盖了TSN的所有业务特征，同时支持同步和非同步终端。

### 5.1.可达定时路径

任务的每个实例从事务的输入到输出的读写顺序由一组计时路径表示。这些定时路径跟踪数据从事务的输入到输出的传播。因此，每个事务可以具有一组定时路径。属于事务Γj的==定时路径由tpi j表示，其中i是定时路径的ID==。根据如[5]中给出的一组条件来选择写入器和读取器任务实例之间的有效时间路径(术语‘’实例‘’等价于术语‘’任务作业‘’)。在本节的后续段落中，我们将简要解释用于检查定时路径的可达性的布尔函数，如[5]所示。

**标识有效定时路径的第一个条件检查读取器任务(比如τdbe)在激活写入器任务的当前实例(比如τabc)之后是否被激活。违反这一条件也称为激活时间阶段(att())，因此方程。(14)以否定的形式定义这一条件。因为，==激活时间阶段不应该发生在有效的定时路径中==。注意，α(W)显示根据公式计算的任务的第w个实例的激活时间。(6)**。

![image-20230705153504054](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307051535130.png)

公式(14)在写入器和读取器任务之间发生激活时间阶段的情况下为真。否则，对于有效的定时路径，当方程中的条件为.(14)是虚假的。

此外，**写入器和读取器任务的完成不应在有效的定时路径中重叠**。因此，下一个可达性条件检查读取器任务的激活时间是否在写入器任务的当前实例完成之后(根据Rabc，写入器任务的最坏情况响应时间，参考第4节中给出的系统模型)。违反此条件也称为==关键条件==，由关键函数(crit())表示，如等式所示。(15)。如果**读取器任务在写入器任务完成之前被激活，则crit()函数返回TRUE**。在这种情况下，读取器任务会遗漏来自写入器任务的数据。否则，公式中的函数。(15)返回FALSE，这对于有效的定时路径是可取的。

![image-20230705154149429](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402076.png)

图10(A)和10(B)中指示了写入器和读取器任务的每个实例的实例编号。图10(A)示出了恰好在写入器任务完成之后激活读取器任务的情况的示例。在本例中，我们有一个从写入器任务的第一个实例到读取器任务的第一个实例的可到达的定时路径。请注意，从写入器任务的第二个实例到读取器任务的第一个实例的定时路径是不可到达的，它将被公式(14)和(15)排除。。

![image-20230705154335869](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307051543976.png)

此外，只有在同一单核终端站中同时激活读取器和写入器任务实例时，它们才能重叠。在这种情况下，如果读取器任务(Pdbe)的优先级低于写入器任务(Pabc)的优先级，则读取器任务不会遗漏写入器任务的数据，如公式所示。(16)。如果读取器任务在写入器任务之前执行，则读取器任务需要等待直到其下一周期激活，以便从写入器任务读取最新数据。这是根据等式(16)中的等待函数(Wait())考虑的。其中P根据第4.1节中的系统模型表示任务的优先级。

![image-20230705202324093](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402023.png)

图10(B)示出了终端站内两个任务之间的定时路径的示例。如果同时激活写入器和读取器任务，则假设写入器任务在读取器任务之前执行，则在写入器和读取器任务之间存在可到达的定时路径。

因此，**如果写入器和读取器任务实例来自两个不同的终端站，则参考在写入器和读取器任务之间通信的消息的最坏情况响应时间和写入器任务实例的激活时间来获得通过网络的定时路径的可达性，**如图11所示。例如，如果存在通过消息Msg通信的写入器任务τw和读取器任务τr，则存在如图11所示的三个不同的定时路径。然而，这些定时路径中只有一个是从事务的输入到输出的可达定时路径。

![image-20230705202442885](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402332.png)

根据前面提到的函数(att()、Crit()和Wait())，基于公式中给出的前向可达性函数forw()来检查定时路径中的两个任务的前向可达性。(17)。

![image-20230705202549822](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307052025896.png)

此外，重要的是要注意到公式。(17)没有涵盖检查定时路径的可达性的所有情况，因为可能发生写入器任务的两个实例到达读取器任务的实例，例如，当写入器任务的周期短于读取器任务时。在这种情况下，读取器任务可以访问的数据将被后续的写入器任务实例覆盖。我们确保只有最后一个写入器任务实例到达读取器任务实例，即没有下一个写入器任务实例到达该读取器任务实例。当等式中的函数。(18)返回TRUE，其中τabc(w+1)表示任务实例τabc(w)的下一个实例。

![image-20230705202647994](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402316.png)

==在检查了两个任务实例之间的可达性之后，我们通过评估从第一个任务到最后一个任务在时间路径上每两个连续的任务实例来检查整个时间路径。我们用公式(19)来表示这一点。==其中**定时路径tpij属于事务Γj**。为简单起见，时间路径中的两个连续任务实例由τw和τr表示。

![image-20230705205925445](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402425.png)

根据等式，我们最终评估**事务Γj中的所有可能的定时路径**，以获得集合TP-reach-j中的所有可达(有效)定时路径。(20)假设在事务中有z个定时路径。

![image-20230705211743579](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402132.png)

### 5.2.关于ST消息的说明

**每个ST消息在其从发送器(写入器)任务到接收器(读取器)任务的路由内的每条链路上具有确定性调度**。ST消息在其最后一条链路上的激活时间(可用于读取器任务实例的时间)不直接依赖于发送方任务的响应时间或消息本身在先前链路上的响应时间。==然而，在定义每条链路的ST消息的偏移量时，可以考虑发送方任务的响应时间、每条链路的ST消息的传输时间和/或其他优化目标等参数。==这与非ST消息的情况相反，**在非ST消息的情况下，消息在发送方和接收方任务之间的最后一条链路上的激活时间取决于发送方任务的响应时间和它自己在先前链路上的响应时间**。然而，ST消息由时隙隔离，这些时隙在其到接收器任务的路径中的每条链路上配置为离线。

以**满足我们先前工作[52]中提出的一组调度约束的方式定义消息路由中后续链路处的ST偏移量**。调度约束不同于本文前面提到的时间约束。调度约束是在每个链路的消息的偏移量集合上设置的一组逻辑规则，以找到导致可行的离线调度的偏移量的可满足值。在执行数据传播延迟分析之前，离线配置TSN计划。

**最重要的调度约束集合如下：(1)对帧大小的约束；(2)对链路上消息重叠的约束；(3)对遍历链路的顺序的约束；以及(4)对最后期限满足的约束。**首先，对帧的约束确保一条链路上的偏移量的值不会强制消息在其下一周期激活之后到达。其次，重叠约束检查同一链路上两个不同消息的偏移是否不会导致这两个消息的时隙重叠。第三，后续链路上相同消息的偏移顺序必须考虑消息从源终端站的链路到宿终端站的链路的传播(避免时间旅行)。第四，消息路由中的每条链路的偏移量必须强制消息在消息的最后期限(隐含地是发送任务的下一周期激活)之前到达目的地终端站。

根据可行的TSN调度，考虑沿着消息的路由的每条链路的偏移量来确定ST消息的实例对于读取器任务的实例的可达性。在这种情况下，**找到可达定时路径的现有约束要求跟踪ST消息的路由中的所有跳，并考虑每条链路的ST消息的激活时间。**

图12中显示了一个事务的例子，其中ST类被用于两个终端站之间的通信。两个终端站通过链路L1和L2连接，因此链路L1上的ST消息的实例由偏移量OL1-11调度，并由ML1-11表示。同样，链路L2上的ST消息的实例由符号ML2-11表示，其在链路上的偏移量由OL2-11定义。此外，在本例中所示的事务(Γ1)中的可达定时路径随后是Tp1 1，Tp21，Tp31和Tp41)源端站的。然后，**该消息根据其在每条链路上的偏移量使用其路径中的链路的带宽**。

如图12所示，由于ST消息在每个链路上具有确定的激活时间，因此必须扩展该分析以支持在几个链路上的消息的多个激活。在对ST报文进行端到端数据传播时延分析时，可以忽略报文路径中除最后一条链路外的链路的激活时间。定时路径的这种减少显著地减少了要评估的定时路径的数量，进而减少了分析的计算时间。我们用下面的引理来说明这一点。

引理1.在通过TSN网络提取可达定时路径时，考虑ST消息在其发送方和接收方终端站之间的最后一条链路上的激活时间就足够了。

证据。==由于ST流量是离线调度的，因此不需要对ST流量进行响应时间分析==。用于ST类的可行TSN调度通过构造ST业务的可调度性来保证。此外，可行的TSN调度确保在ST消息的传输期间，直到其到达目的地终端站，将不会有ST消息的后续实例的新激活。在**端到端分析之前，网络内的ST帧的激活和到达是已知的**，因此在调度ST业务时，对于几个链路上的ST消息，总是存在确定性的可到达的定时路径，该路径已经被计算并被离线配置。因为该确定性路径的可达性已经被离线调度算法批准，所以**只需要检查该路径到接收器节点的可达性**。因此，**在提取可达定时路径时，考虑最后一条链路(网络的可达路径的末端)上ST消息的激活就足够了。**

> 端到端分析之前，网络内的ST帧的激活和到达是已知的

![image-20230705220247315](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402335.png)

基于引理1，在图12中描述的场景的情况下，在识别用于端到端数据传播延迟分析的可达定时路径时，在其最后一跳(ml2-11)的消息足以被考虑，如图13所示。因此，需要扩展现有的分析以支持TSN类。

![image-20230705224915839](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307052249969.png)

根据引理1，仅考虑其最后一条链路上的ST消息激活就足以导出定时路径。然而，为了考虑最后一条链路上的ST消息，我们建议将**ST消息的整个路径建模为单独的任务**，以简化将ST消息合并到现有分析中。情商。(21)展示了这样一个任务的模型。我们把这个任务**看作是网络任务**，并用τnetj表示这项任务与mrjk的消息相对应。==参数r是将消息传递到接收端站(最后一跳)的链路的ID。==因此，每个ST消息都用一个τ网任务建模。

![image-20230705225157624](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402550.png)

其中，T T()==根据消息的大小和网络速度计算消息的传输时间(秒)==。T T()由((Sizejk+OH)∗8)∕(S)计算。其中，OH是TSN帧的开销，以字节为单位。

通过使用任务对ST消息进行建模，我们可以使用公式。(20)评估事务对应的定时路径的可达性，其中τnetj可以是事务j中的读取器或写入器任务，其激活时间根据公式计算。(10)。

> 激活时间=周期*n+ 偏移量
>
> 还是把网络传输看成一个任务，这里是因为TSN的ST任务传输的离线以及确定性。

### 5.3.对非ST消息进行核算

假定在发送方任务完成其执行后立即安排传输非ST消息。**消息实例到达读取器任务实例的时间根据写入器任务实例的激活时间和周期以及消息的响应时间来计算**。如图14所示，非ST消息m11在其到读取器任务的路由中的两个链路的集合中没有偏移，即τ211。因此，假定该消息的激活时间与其先前的写入器任务相同。在图14中，在发送方任务τ112完成之后，不立即发送M11的每个实例，因为我们假设该消息从其他较高优先级消息接收干扰(和/或它被较低优先级消息阻止)。**通过知道消息(R11)的最坏情况响应时间，可以确定读取器任务的可达实例**。例如，考虑图14中的TP1 1和TP2 1。在这些定时路径中，消息的第一个实例对于读取器任务的第三个和第四个实例是可到达的。因此，Eq.(17)用于评估事务中定时路径的可达性。

![image-20230705225559818](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402207.png)

### 5.4.最坏情况下数据年龄和反应时间延迟的计算

数据年龄和反应时间延迟是**基于时间路径**得出的(在第5.1节中介绍)。在本节中，我们将进一步解释根据[5]计算最坏情况下的数据年龄和反应时间延迟的方法。属于事务Γj的定时路径Tpn j的数据年龄延迟由公式(22)计算。，其计算**输入数据与对应输出数据的最后样本之间的时间差**。
> 先通过约束得到多个不同的链路
> tp11，下角标事务1，上角标该事务的第一个可到达链路
> 计算所有链路的延迟，取max

![image-20230705230203178](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307052302292.png)

其中，αFirst()返回任务实例的激活时间，该任务实例是第一个接收新输入数据的任务。该任务是发起方终端站内的事务发起方任务的实例。此外，αLast()和RTLast()从终结器终端站返回终结器任务实例的激活时间和最坏情况的响应时间，之后数据被覆盖。

反应时间由方程计算。(23)，其中P red()表示在分析TPN j的定时路径之前的定时路径的第一实例。请注意，在任务链的输入端刚刚错过一个事件的影响被P red()所覆盖。

![image-20230705230549888](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402191.png)

> 和向前/向后作业链一样，
>
> 反应时间=最后一个任务的释放+最后一个任务的WCRT-第一个任务之前一个任务的释放
>
> 数据年龄=最后一个任务的释放+最后一个任务的WCRT-第一个任务的释放

提取每个事务的所有定时路径的数据年龄和反应时间延迟，最长的对应值表示最坏情况下的数据年龄和反应延迟，根据公式计算。(24)。

![image-20230705230838301](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402634.png)

周期性系统中任务集的实例以由任务集中任务周期的LCM指定的给定有界模式重复。此外，要找到最坏情况下的数据年龄和反应时间延迟，只需列举并比较两个超周期(事务中所有涉及的周期的LCM)的有限界限内的所有计时路径就足够了。

> 和扩展作业链一样，周期任务考虑超周期

传统上希望数据年龄和反应时间延迟小于或等于其根据公式的相应约束。(25)。

![image-20230705230937096](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402624.png)

在分析之后，可以根据用户定义的端到端定时约束，即基于如文献[16，48]中解释的不同标准，检查数据年龄和反应时间延迟的值是否满足目标系统的特定需求。

## 6.车辆应用案例研究

在这一部分中，我们将讨论一个用于评估所提出的端到端数据传播延迟分析的车辆工业用例。用例由==14个终端站组成，这些终端站由一个双交换机TSN网络连接==，如图15所示。假设==每个终端站包括多个任务==。图15的灵感来自于在[53]中开发的用例，并且==相应地指定了流量==。我们将建议的分析作为内部工具实施。用例中的配置和消息集作为实现的分析的输入给出(参见图15)。

![image-20230705231202917](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402118.png)

### 6.1.实验装置

我们对图15中的用例进行了扩展的以及现有的端到端数据传播延迟分析。分析的评估是在给出用例的不同流量场景下进行的。在本实验中，我们假设从终端站1到7开始的14个事务使用不同的TSN业务类别与ID为8到10的三个汇聚终端站通信。表1显示了事务设置。此外，图16说明了表1所示的交易元素之间的关系。注意，在图16中，为了增强图的可读性，我们没有示出一个节点或两个终端站内的任何两个消息之间的寄存器。**每个事务由不同终端站内的任务发起和终止**。每笔交易共包括四项任务。此外，每个事务包括构成链的每个终端站的两个任务。**在源端站中，第一个任务是计算任务，后续任务是通信任务**，它接收来自前一个任务的数据输入，然后准备消息并将消息注入网络。在这些事务的**目的地终端站中，第一个任务是接收和处理来自网络的消息的通信任务。通信任务将消息发送到事务中的最后一个任务以进行进一步处理。**根据[54]中的汽车数据集选择任务周期，即以毫秒(Ms)为单位的{1，2，5，10，20，50,100}。所有**消息的大小固定为1500字节，作为最大有效负载大小**，每个任务的最坏情况执行时间**(WCET)被认为是0.5ms**。终端站根据**固定优先级抢占式**调度算法运行任务。在每个事务中，我们假设一个任务的优先级高于其在同一终端站内的后续任务的优先级。因为，我们希望以这样的顺序在同一终端站内保持两个后续任务的执行，以避免在写入数据时造成延迟。这确保在同时激活两个任务以执行的情况下，事务中的每个先行任务(写入器任务)必须在链中的后续任务(读取器任务)之前执行。

> 每条任务链上，有五个任务，源节点两个（计算+发送），网络任务，目的节点两个（接收+计算）

14个事务中有5个使用ST业务类；3个事务使用A类；3个事务使用B类；3个事务使用BE类。CBS机制根据表2设置，其中，根据这些类别在网络链路上的使用情况来选择类别A和B的信用。整体**网速设置为1 Gbps**。我们根据A类和B类业务的利用率来设置空闲斜率(IdleSlope)，如表2所示。交易6、7和8在链路10和15上使用A类，因此链路L10和L15的信用被设置为0.78。此外，交易9、10和11使用链路1、2和7上的B类。因此，链路L1、L2和L7上的B类的信用被设置为0.4。我们注意到，零信用意味着链路上没有来自相关CBS类的消息。在表2中，仅显示了使用CBS的链路的信用。最后，表3描述了在每个事务上指定的数据年龄和反应时间约束。

### 6.2.对现有分析和扩展分析的评价

在本节中，我们将比较通过执行现有的[5]和扩展的端到端数据传播延迟分析而获得的分析结果。表4分别显示了每个消息(Ri，j)及其发送任务(Ri，j，k)的响应时间。此外，每个事务中最后一个任务的响应时间如表4所示。

表1中描述的每个单独事务的数据年龄和反应时间延迟是通过现有的和扩展的端到端数据传播延迟分析来计算的。分析结果如表5所示。

在表5中可以观察到，扩展的端到端数据传播延迟分析计算的反应时间和数据年龄延迟小于现有分析计算的反应时间和数据年龄延迟。例如，用现有分析计算的交易Γ5的反应时间和数据年龄延迟分别为22.09ms和12.09ms。而用扩展分析计算的事务Γ5的反应时间和数据年龄延迟分别为21ms和11ms。我们注意到，与扩展分析相比，现有分析计算的Γ5的反应时间和数据年龄延迟分别高估了5.19%和9.90%(悲观)。借助图17中的执行轨迹，我们直观地演示了在Γ5中的反应时间和数据年龄延迟。在Γ5中，发送端站(SP5)和接收端站(9)中的任务==因为使用ST类而被同步==。扩展分析考虑了Γ5中节点的同步，即每个节点看到相同的时间0。图17(A)示出了在两个超周期(Γ5中所有任务的周期的Lcm，即20ms)内的可达定时路径。另一方面，现有分析考虑的执行轨迹如图17(B)所示。

![image-20230709105025926](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402407.png)

### 6.3.不同参数对数据年龄和反应时间延迟的影响

在这一小节中，我们使用扩展的端到端数据传播延迟分析来演示各种参数对数据年龄和反应时间延迟的影响。感兴趣的参数包括ST消息的偏移量和接收器终端站中的任务的周期(即，消息接收任务的周期)。评估是在图15所示用例中的事务中执行的。事务的详细信息如表6所示。

分析中的事务从作为发送端站的CAM1开始，以作为接收端站的AVSink结束。该事务使用CAM1中的一个任务，==固定周期为50毫秒，WCET为1毫秒==。根据图15所示的拓扑结构，通过L2、L0和L15三条链路将ST消息发送到AVSink。在AVSink中有两个任务参与该事务，即τ911和τ912。每个任务都有1ms的WCET。从τnet接收消息的AVSink中的任务TSN911具有最高优先级。我们改变接收器终端站的任务周期(AVSink)，如表6中的符号Y所示。Y可以从范围{15，20，25，30，40，50，60，70，90,100,150,200,250}获得值，单位为毫秒(Ms)。AVSink的两项任务都有相同的周期。

当我们考虑正在分析的事务中的ST消息时，我们可以为其最后一条链路上的最小偏移量和最大偏移量之间的偏移量赋予任何值。偏移量的变量值在表6中用X符号表示。最后一条链路上的消息的最小偏移量(ML15，1，1)等于发送方任务的响应时间之和，τ111(1ms)，如图19所示，==消息在第一链路上的传输时间ML21，1(0.0126毫秒)和消息==在第二链路上的传输时间ML01，1(0.0126毫秒)。这三个项的总和等于1.0252毫秒，其定义了在其通向目的地终端站的最后一条链路上可以分配给正在分析的消息的偏移量的最小值。类似地，可以在其最后一条链路上向目的地终端站分配给被分析消息的**最大偏移量是49.9874毫秒，这等于该消息的周期(50毫秒)与该消息在最后一条链路上的传输时间(0.0126毫秒)之间的差**。在该事务中没有其他TSN消息干扰ST消息。根据TSN[31，33，34]的最坏情况响应时间分析，消息的响应时间(接收端站接收消息的时间)为1.025毫秒。通过计算和比较ST偏移量的参数X和接收器终端站任务周期的参数Y与表6中给出的设定值的变化，计算和比较数据年龄和反应时间延迟。

![image-20230709142255469](https://gcore.jsdelivr.net/gh/wsm6636/pic/202307211402093.png)

图20和图21分别给出了正在分析的交易的数据年龄和反应时间延迟。图20和图21中的水平轴显示了接收器任务的周期的变化。垂直轴表示数据年龄延迟(图20)和反应时间延迟(图21)。颜色编码的折线图表示根据分配给ST消息的不同偏移量计算的延迟。

图20示出了当消息的偏移量被设置为最小值1.0252毫秒时，随着事务中的消息接收任务的周期的变化，数据年龄延迟保持在52ms不变。随着偏移量的值增加到其最大值49.9874毫秒，数据老化延迟也会增加。类似地，图21中描述了通过设置ST消息偏移量的不同值以及通过改变牵引线内的消息接收任务的周期来为同一事务计算的反应时间延迟。

我们注意到图20中的一些特定情况，其中消息接收任务的周期是一个调和倍数(50ms，100ms，.。。)在事务内发送方任务的周期(50毫秒)中，数据年龄延迟保持不变，为52毫秒。此外，ST消息的偏移量的任何变化(在偏移量的最小值和最大值之间选择)在这种情况下也不影响数据年龄延迟。在这些特定情况下获得相同数据年龄延迟的原因是，数据年龄延迟考虑了定时路径中未被先前输入覆盖的最后一个输入[5，7]。我们通过在图22和23中绘制事务的执行轨迹来演示这种情况，其中消息接收任务(τ911)的周期被设置为发送者任务的周期(τ111，周期=50ms)的前两个谐波倍数(50ms和100ms)。图22(a，c，e)和23(a，c，e)表示当考虑ST消息偏移量的不同值时，发送方任务(τ1，1，1)和接收方任务(τ9，1，1)的周期被设置为50ms时事务的执行轨迹。然而，图22(b，d，f)和23(b，d，f)表示在改变ST消息的偏移量的同时，当发送方任务(τ1，1，1)的周期被设置为50ms而接收方任务(τ9，1，1)的周期被设置为100ms时事务的执行轨迹。

例如，图22(A)中的数据年龄延迟是52ms。尽管(τ9，1，1)的周期在图22(B)中相对于其在图22(A)中的周期增加了一倍，但是消息的第一实例将被图22(B)中的消息的第二实例重写。因此，τ1，1，1的第一实例通过消息的第一实例提供的数据不能到达τ9，1，1的第二实例。事实上，τ9，1，1的第二实例将读取由τ1，1，1的第二实例产生的数据。因此，图22(B)中的数据年龄延迟与图22(A)中的数据年龄延迟相同。事实上，当考虑τ9，1，1的周期的高次谐波倍数时，数据年龄延迟保持不变，包括150ms，200ms和250ms，如图20所示。此外，通过改变ST消息的偏移量的值，年龄延迟的数据路径保持不变，因为消息偏移量不能超过其发送者任务(τ1，1，1)的周期，而接收者任务的周期(τ9，1，1)是τ1，1，1的周期的调和倍数。

另一方面，反应时间延迟受到接收消息的任务周期的增加的显著影响，如图21所示。我们注意到，对于τ9，1，1的周期，即τ1，1，1周期的前两个谐波倍数，反应时间延迟是相同的。但是，反应延迟随着τ9，1，1周期的增加而不断增加，这等于τ1，1，1周期的后续谐波倍数(150ms，200ms和250ms)，如图21所示。

### 6.4.讨论

由现有定时分析计算的端到端数据传播延迟，例如数据年龄和反应时间延迟，可能==基于不同的网络实现，即当发送者终端站和接收者终端站被同步时是悲观的(过度估计的)。此外，网络配置的变化，如偏移量配置或发送方和接收方任务的周期，会影响数据从事务的输入到输出的传播。==因此，端到端数据传播延迟也可能因不同设置而显著不同。由于需要离线调度，使用ST类的事务需要更多的配置和优化工作。但是，ST类允许灵活调整端到端数据传播延迟。

## 7.结论和下一步工作

提出了一种==基于TSN的车载分布式嵌入式系统的端到端时序模型==。端到端时序模型支持将TSN功能与现有的端到端数据传播分析相集成。所提出的端到端定时模型的特点是具有本地同步任务的两个或多个同步终端站上的分布式TSN事务。分布式TSN事务定义了可以通过TSN消息在两个不同终端站内通信的任务链。TSN类具有不同的时钟同步要求，这在现有的端到端数据传播延迟分析中没有考虑到。在本文中，我们提出了在端到端数据传播延迟分析中综合考虑所有TSN流量需求的模型和方法。

通过一个车辆用例对所提出的端到端时序模型和分析进行了评估。我们在用例的基础上对==现有的分析和扩展的分析==进行了比较评估。此外，==评估的依据是事务周期和消息偏移量可能对数据年龄和反应时间延迟造成的影响==。

综上所述，我们从结果中得出结论，非ST交易处理的数据年龄和反应时间延迟的有效参数较少。ST事务的数据年龄和反应时间延迟被更灵活地重新调整，尽管关于其多个可配置参数的优化是复杂的。

这项工作的结果还指出了一些潜在的未来工作方向。首先，这项工作实现了端到端时延的基于分析的优化(主动方法)。<span style="background:#fbc2eb !important;">例如，还可以包括对终端站内的任务的调度，以便优化端到端数据传播延迟。其次，通过任务和消息的协同调度来实现端到端数据传播延迟的系统级优化可以看作是本文工作的扩展。最后，未来可能的工作是将所提出的端到端数据传播延迟分析与基于模型的分布式嵌入式系统软件开发框架(例如Rubus-ICE[12])相结合。</span>

---



# 笔记⭐️⭐️⭐️⭐️⭐️



## **1、这篇论文，在端到端的分析计算方式上，还是采用向前向后作业链的方式，计算数据年龄和反应时间，并且没有像扩展向前向后作业链一样，考虑是否z，也没考虑什么时候可以不用计算WCRT**。

计算公式：

反应时间=最后一个任务的释放+最后一个任务的WCRT-第一个任务之前一个任务的释放

数据年龄=最后一个任务的释放+最后一个任务的WCRT-第一个任务的释放

> 关注点在于分析网络，还需要加上z吗，但是可以考虑WCRT。本文使用已有的WCRT分析
>
> QBV中的保留带等怎么考虑

## 2、本文的创新在于，其他论文采用CAN总线方式，时间在多个终端内不同步，但**采用TSN时间同步，所以需要根据同步的情况计算延迟。不同步的延迟会比同步的高**

> 参考，背景，动机

## 3、如何同时涵盖时间同步和不同步。

根据不同情况，**在计算任务激活时间上略有不同（**这里的激活时间和释放时间是否一样，有待研究）。

同步：接收任务轮询TSN网络读取，激活时间=n*周期+偏移量

非同步：一旦消息在网络上可用，接受任务立刻读取，激活时间=n*周期+偏移量+最差响应时间

> 参考，是否还有其他可以考虑的同步与非同步区别

## 4、本文考虑的任务链很简单，每个终端只有两个任务，网络只经过一个交换机

**所有任务都是周期性的**

每条任务链上，有五个任务，源节点两个（计算+发送），网络任务，目的节点两个（接收+计算）

还是把网络传输看成一个任务，这里是因为TSN的ST任务传输的离线以及确定性。

> 先考虑周期性的任务

## 5、如何考虑TSN中不同流量的调度

ST任务是离线，以及设定好的。其他几类有优先级之分

ST任务的数据通过轮询读取，其他的根据网络任务而定。

**这里并没有考虑具体采用TSN的哪一个标准**，考虑AS，qbv

> ~~可以先考虑QCH，从降低抖动的方面考虑~~
>
> ~~**QCH：当一个帧通过网络时引入的==延迟完全由周期时间和跳数描述==，不受任何其他拓扑考虑因素的影响，包括来自其他非时间敏感流量的干扰。**~~
>
> ~~怎么设定slot长度~~
>
> ~~怎么证明，同步和非同步对于qch影响不大~~
>
> ATS 异步流量整形 QCR

## 6、对于任务链是否满足可调度，结合了向前向后作业链，以及TSN对任务的要求，传输约束（偏移量，ddl等等）

> 之前已经考虑过了，具体参照注入时间的论文

## **7、这篇文章好像没考虑同步带来的延迟，**

终端支持TSN同步，如果考虑到终端不支持呢？需要加上时间同步带来的延迟

> 注入时间的论文提到过，对于同步操作需要消耗的延迟,算在WCRT里了？
>
> 相位同步？

## **8、本文对于TSN网络的设置可以参考⭐️⭐️⭐️⭐️⭐️**

- [ ] 带宽
- [ ] 字节数
- [ ] 计算方式
- [ ] 采用数据集
- [ ] 其他参数配置
- [ ] 模型搭建
- [ ] io

根据[54]中的汽车数据集选择任务周期，即以毫秒(Ms)为单位的{1，2，5，10，20，50,100}。所有**消息的大小固定为1500字节，作为最大有效负载大小**，每个任务的最坏情况执行时间**(WCET)被认为是0.5ms**。终端站根据**固定优先级抢占式**调度算法运行任务。在每个事务中，我们假设一个任务的优先级高于其在同一终端站内的后续任务的优先级。

整体**网速设置为1 Gbps**。我们根据A类和B类业务的利用率来设置空闲斜率(IdleSlope)，如表2所示。

> qbu，高优先级帧抢占
>
> 最差响应时间分析

Qbu 分片将干扰帧分成小块，既满足了传输的时效性要求，也能较好的提高带宽利用率。Qbv 虽然能保 护关键流量免受其他网络流量的干扰，但不一定带来最佳的带宽利用率和最小的通信时延。在支持 Qbu 帧抢占的链路上，允许中断非关键的标准以太网帧或者巨型帧的传输，并优先传输时间关键帧，然后在不 丢弃先前传输的非关键帧片段的情况下恢复传输中断的数据，一个非关键的数据帧可以被多次抢占。在应 用保护带机制时，帧抢占能有效减小保护带的最大长度，缩短信道空闲时间。帧抢占机制在保证关键型数 据确定性低时延的同时，也提供了更细粒度的服务质量，提高了带宽利用率。

> qbv的交换机是fifo的，怎么分析WCRT

 

> 详细分析WCRT？会不会存在不同的分析结果？
>
> QBV（AVB）的还是QBU？
>
> QCH的延迟是固定的，比QBV的延迟高，但是抖动小，要和QBV比吗？
>
> QBU怎么变成任务链

***

# 笔记

## 1 论文创新在于

## 2 解决了什么问题

## 3 方法

## 4 不足&可继续研究

## 5 可参考

## 6 思考

Referred in <a href="zotero://note/u/HWG3PU5P/?ignore=1&#x26;line=-1" rel="noopener noreferrer nofollow" zhref="zotero://note/u/HWG3PU5P/?ignore=1&#x26;line=-1" ztype="znotelink" class="internal-link">cause-effect chain</a>
